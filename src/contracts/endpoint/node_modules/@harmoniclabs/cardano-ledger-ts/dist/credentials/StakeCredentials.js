"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakeCredentials = exports.StakeCredentialsType = exports.StakeValidatorHash = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var Hash28_1 = require("../hashes/Hash28/Hash28.js");
var ints_1 = require("../utils/ints.js");
var Credential_1 = require("./Credential.js");
var StakeKeyHash_1 = require("./StakeKeyHash.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../utils/assert.js");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
var PubKeyHash_1 = require("./PubKeyHash.js");
var StakeValidatorHash = /** @class */ (function (_super) {
    __extends(StakeValidatorHash, _super);
    function StakeValidatorHash() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StakeValidatorHash;
}(Hash28_1.Hash28));
exports.StakeValidatorHash = StakeValidatorHash;
var StakeCredentialsType;
(function (StakeCredentialsType) {
    /** @deprecated use `KeyHash` instead */
    StakeCredentialsType["StakeKey"] = "stakeKey";
    StakeCredentialsType["KeyHash"] = "stakeKey";
    StakeCredentialsType["Script"] = "script";
    StakeCredentialsType["Pointer"] = "pointer";
})(StakeCredentialsType = exports.StakeCredentialsType || (exports.StakeCredentialsType = {}));
var StakeCredentials = /** @class */ (function () {
    function StakeCredentials(type, hash, subCborRef) {
        this.subCborRef = subCborRef;
        (0, assert_1.assert)(hash instanceof Hash28_1.Hash28, "can't construct 'StakeCredentials'; hash must be instance of an 'Hash28'");
        (0, assert_1.assert)(type === "stakeKey" || type === "script" || type === "pointer", "can't construct 'Credential'; specified type is nor 'addres' nor 'script'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "type", type);
        if (type === "pointer") {
            if (!(Array.isArray(hash) &&
                hash.length === 3 &&
                hash.every(ints_1.canBeUInteger)))
                throw new Error("invalid argument for stake credentials of type " + type);
            (0, obj_utils_1.defineReadOnlyProperty)(this, "hash", hash.map(ints_1.forceBigUInt));
        }
        else {
            if (!(hash instanceof Hash28_1.Hash28))
                throw new Error("invalid argument for stake credentials of type " + type);
            (0, obj_utils_1.defineReadOnlyProperty)(this, "hash", type === "stakeKey" ?
                (hash instanceof StakeKeyHash_1.StakeKeyHash ? hash : new StakeKeyHash_1.StakeKeyHash(hash.toBuffer())) :
                (hash instanceof StakeValidatorHash ? hash : new StakeValidatorHash(hash.toBuffer())));
        }
    }
    /** @deprecated use `keyHash` instead */
    StakeCredentials.pubKey = function (hash) {
        return StakeCredentials.keyHash(hash);
    };
    /** @deprecated use `keyHash` instead */
    StakeCredentials.stakeKey = function (hash) {
        return StakeCredentials.keyHash(hash);
    };
    StakeCredentials.keyHash = function (hash) {
        return new StakeCredentials(StakeCredentialsType.KeyHash, hash instanceof PubKeyHash_1.PubKeyHash ?
            hash :
            new PubKeyHash_1.PubKeyHash(hash));
    };
    StakeCredentials.script = function (hash) {
        return new StakeCredentials(StakeCredentialsType.Script, hash instanceof Credential_1.ValidatorHash ?
            hash :
            new Credential_1.ValidatorHash(hash));
    };
    /** @deprecated pointer credentials are deprecated since conway */
    StakeCredentials.pointer = function (hash) {
        return new StakeCredentials(StakeCredentialsType.Pointer, hash);
    };
    StakeCredentials.prototype.clone = function () {
        return new StakeCredentials(this.type, this.hash);
    };
    StakeCredentials.prototype.toData = function (version) {
        var isOldVersion = version !== "v1" && version !== "v2";
        if (this.type === "pointer") {
            if (isOldVersion)
                throw new Error("staking pointer was deprecated in conway, can't convert to data");
            return new plutus_data_1.DataConstr(1, // PStakingPtr
            this.hash
                .map(function (n) { return new plutus_data_1.DataI((0, ints_1.forceBigUInt)(n)); }));
        }
        var credData = new Credential_1.Credential(this.type === "stakeKey" ? Credential_1.CredentialType.KeyHash : Credential_1.CredentialType.Script, this.hash).toData(version);
        if (isOldVersion)
            return new plutus_data_1.DataConstr(0, // PStakingHash
            [credData]);
        return credData;
    };
    StakeCredentials.fromData = function (data) {
        if (!(data instanceof plutus_data_1.DataConstr))
            throw new Error("invalid data for stake credential");
        if (data.constr === BigInt(1))
            return new StakeCredentials(StakeCredentialsType.Pointer, data.fields.map(function (d) {
                if (!(d instanceof plutus_data_1.DataI))
                    throw new Error("invalid data for stake credential");
                return d.int;
            }));
        var creds = Credential_1.Credential.fromData(data.fields[0]);
        return new StakeCredentials(creds.type === Credential_1.CredentialType.KeyHash ? StakeCredentialsType.KeyHash : StakeCredentialsType.Script, creds.hash);
    };
    StakeCredentials.prototype.toCbor = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.subCborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    StakeCredentials.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.type === "stakeKey" ? 0 : 1),
            Array.isArray(this.hash) ?
                new cbor_1.CborArray(this.hash
                    .map(function (n) { return new cbor_1.CborUInt((0, ints_1.forceBigUInt)(n)); })) :
                this.hash.toCborObj()
        ]);
    };
    StakeCredentials.fromCbor = function (cObj) {
        return StakeCredentials.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cObj)));
    };
    StakeCredentials.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray))
            throw new Error("Invalid CBOR fromat for \"StakeCredentials\"");
        var _a = __read(cObj.array, 2), _type = _a[0], _creds = _a[1];
        if (!(_type instanceof cbor_1.CborUInt))
            throw new Error("Invalid CBOR fromat for \"StakeCredentials\"");
        if (!(_creds instanceof cbor_1.CborArray || _creds instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR fromat for \"StakeCredentials\"");
        if (_creds instanceof cbor_1.CborArray) {
            if (!_creds.array.every(function (n) { return n instanceof cbor_1.CborUInt; }))
                throw new Error("Invalid CBOR fromat for \"StakeCredentials\"");
            return new StakeCredentials(StakeCredentialsType.Pointer, _creds.array.map(function (n) { return n.num; }));
        }
        return new StakeCredentials(_type.num === BigInt(0) ? StakeCredentialsType.KeyHash : StakeCredentialsType.Script, Hash28_1.Hash28.fromCborObj(_creds), (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    StakeCredentials.prototype.toJSON = function () { return this.toJson(); };
    StakeCredentials.prototype.toJson = function () {
        switch (this.type) {
            case "script":
                return {
                    type: "script",
                    hash: this.hash.toString()
                };
            case "stakeKey":
                return {
                    type: "stakeKey",
                    hash: this.hash.toString()
                };
            case "pointer":
                return {
                    type: "pointer",
                    pointer: this.hash
                        .map(function (n) { return (0, ints_1.forceBigUInt)(n).toString(); })
                };
            default:
                throw new Error("unknown stake credentials type");
        }
    };
    return StakeCredentials;
}());
exports.StakeCredentials = StakeCredentials;
