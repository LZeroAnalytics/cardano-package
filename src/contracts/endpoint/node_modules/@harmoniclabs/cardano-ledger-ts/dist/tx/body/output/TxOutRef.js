"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxOutRef = exports.ITxOutRefToStr = exports.eqITxOutRef = exports.isITxOutRef = void 0;
var bytestring_1 = require("@harmoniclabs/bytestring");
var cbor_1 = require("@harmoniclabs/cbor");
var ints_1 = require("@harmoniclabs/cbor/dist/utils/ints");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var hashes_1 = require("../../../hashes/index.js");
var BasePlutsError_1 = require("../../../utils/BasePlutsError.js");
var InvalidCborFormatError_1 = require("../../../utils/InvalidCborFormatError.js");
var assert_1 = require("../../../utils/assert.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var getSubCborRef_1 = require("../../../utils/getSubCborRef.js");
function isITxOutRef(stuff) {
    return ((0, obj_utils_1.isObject)(stuff) &&
        (0, obj_utils_1.hasOwn)(stuff, "id") && ((typeof stuff.id === "string" && bytestring_1.ByteString.isValidHexValue(stuff.id) && (stuff.id.length === 64)) ||
        (stuff.id instanceof hashes_1.Hash32)) &&
        (0, obj_utils_1.hasOwn)(stuff, "index") && (typeof stuff.index === "number" &&
        stuff.index === Math.round(Math.abs(stuff.index))));
}
exports.isITxOutRef = isITxOutRef;
function eqITxOutRef(a, b) {
    if (!(0, obj_utils_1.isObject)(a))
        return false;
    if (!(0, obj_utils_1.isObject)(b))
        return false;
    try {
        return (new hashes_1.Hash32(a.id).toString() === new hashes_1.Hash32(b.id).toString() &&
            typeof a.index === "number" &&
            a.index === b.index);
    }
    catch (_a) {
        return false;
    }
}
exports.eqITxOutRef = eqITxOutRef;
function ITxOutRefToStr(iRef) {
    if (!isITxOutRef(iRef))
        throw new BasePlutsError_1.BasePlutsError("'ITxOutRefToStr' works on 'ITxOutRef' like objects");
    return "".concat(iRef.id.toString(), "#").concat(iRef.index.toString());
}
exports.ITxOutRefToStr = ITxOutRefToStr;
var TxOutRef = /** @class */ (function () {
    function TxOutRef(_a, subCborRef) {
        var id = _a.id, index = _a.index;
        this.subCborRef = subCborRef;
        (0, assert_1.assert)((typeof id === "string" && bytestring_1.ByteString.isValidHexValue(id) && (id.length === 64)) ||
            (id instanceof hashes_1.Hash32), "tx output id (tx hash) invalid while constructing a 'UTxO'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "id", id instanceof hashes_1.Hash32 ? id : new hashes_1.Hash32(id));
        (0, obj_utils_1.defineReadOnlyProperty)(this, "index", Number((0, ints_1.forceBigUInt)(index)));
    }
    TxOutRef.prototype.toString = function () {
        return "".concat(this.id.toString(), "#").concat(this.index.toString());
    };
    TxOutRef.fromString = function (str) {
        if (typeof str !== "string")
            throw new Error("TxOutRef.fromString expects a string");
        var _a = __read(str.split('#'), 2), id = _a[0], idx = _a[1];
        return new TxOutRef({
            id: id,
            index: Number(idx)
        });
    };
    TxOutRef.prototype.toData = function (version) {
        if (version === "v1" || version === "v2")
            return new plutus_data_1.DataConstr(0, // PTxOutRef only constructor
            [
                new plutus_data_1.DataConstr(0, // PTxId only constructor
                [new plutus_data_1.DataB(this.id.toBuffer())]),
                new plutus_data_1.DataI(this.index)
            ]);
        return new plutus_data_1.DataConstr(0, // PTxOutRef only constructor
        [
            new plutus_data_1.DataB(this.id.toBuffer()),
            new plutus_data_1.DataI(this.index)
        ]);
    };
    TxOutRef.prototype.toCbor = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.subCborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    TxOutRef.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        return new cbor_1.CborArray([
            this.id.toCborObj(),
            new cbor_1.CborUInt(this.index)
        ]);
    };
    TxOutRef.fromCbor = function (cStr) {
        return TxOutRef.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr), { keepRef: true }));
    };
    TxOutRef.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxOutRef");
        var _a = __read(cObj.array, 2), _id = _a[0], _index = _a[1];
        var idRes = hashes_1.Hash32.fromCborObj(_id);
        if (!(_index instanceof cbor_1.CborUInt))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxOutRef");
        return new TxOutRef({
            id: idRes,
            index: Number(_index.num)
        }, (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    TxOutRef.prototype.toJSON = function () { return this.toJson(); };
    TxOutRef.prototype.toJson = function () {
        return {
            id: this.id.toString(),
            index: this.index
        };
    };
    Object.defineProperty(TxOutRef, "fake", {
        get: function () {
            return new TxOutRef({
                id: "ff".repeat(32),
                index: 0
            });
        },
        enumerable: false,
        configurable: true
    });
    TxOutRef.eq = function (a, b) {
        return eqITxOutRef(a, b);
    };
    TxOutRef.prototype.eq = function (other) {
        return eqITxOutRef(this, other);
    };
    TxOutRef.sort = function (a, b) {
        var ord = (0, uint8array_utils_1.lexCompare)(new hashes_1.Hash32(a.id).toBuffer(), new hashes_1.Hash32(b.id).toBuffer());
        // if equal tx id order based on tx output index
        if (ord === 0)
            return a.index - b.index;
        // else order by tx id
        return ord;
    };
    return TxOutRef;
}());
exports.TxOutRef = TxOutRef;
