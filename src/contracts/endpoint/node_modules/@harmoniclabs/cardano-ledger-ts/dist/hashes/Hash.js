"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash = exports.canBeHashInstance = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var assert_1 = require("../utils/assert.js");
var hex_1 = require("../utils/hex.js");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
function canBeHashInstance(obj) {
    if (typeof obj !== "object")
        return false;
    var ks = Object.keys(obj);
    if (!ks.includes("toBuffer"))
        return false;
    var toBuff = obj["toBuffer"];
    if (typeof toBuff !== "function")
        return false;
    if (toBuff.length !== 0)
        return false;
    if (ks.includes("__str")) {
        var str = obj["__str"];
        if (typeof str === "string" && (0, hex_1.isHex)(str))
            return true;
    }
    if (ks.includes("__bytes")) {
        var bytes = obj["__bytes"];
        if (bytes instanceof Uint8Array)
            return true;
    }
    return false;
}
exports.canBeHashInstance = canBeHashInstance;
var Hash = /** @class */ (function () {
    function Hash(bs, subCborRef) {
        this.subCborRef = subCborRef;
        if (typeof bs == "string") {
            // remove spaces
            bs = bs.trim().split(" ").join("");
            (0, assert_1.assert)((0, hex_1.isHex)(bs), "invalid hex input while constructing a Hash: " + bs);
            // even length
            bs = (0, uint8array_utils_1.fromHex)((bs.length % 2) === 1 ? "0" + bs : bs);
        }
        (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(bs), "invalid Uint8Array input while constructing a Hash");
        this._bytes = bs;
    }
    Hash.isStrictInstance = function (bs) {
        return Object.getPrototypeOf(bs) === Hash.prototype;
    };
    Object.defineProperty(Hash.prototype, "_str", {
        /** @deprecated */
        get: function () {
            return this.toString();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Hash.prototype, "asString", {
        /**
         * @deprecated use `toString()` instead
         */
        get: function () {
            return this.toString();
        },
        enumerable: false,
        configurable: true
    });
    Hash.prototype.toString = function () {
        return (0, uint8array_utils_1.toHex)(this._bytes);
    };
    Object.defineProperty(Hash.prototype, "asBytes", {
        /**
         * @deprecated use `toBuffer()` instead
         */
        get: function () {
            return this._bytes;
        },
        enumerable: false,
        configurable: true
    });
    Hash.prototype.toBuffer = function () {
        return this._bytes;
    };
    /**
     * @deprecated use `toBuffer()` instead
     */
    Hash.prototype.toBytes = function () {
        return this._bytes;
    };
    Hash.prototype.clone = function () {
        return new Hash(Uint8Array.prototype.slice.call(this._bytes));
    };
    Hash.prototype.toCbor = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.subCborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    Hash.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        return new cbor_1.CborBytes(this.toBuffer());
    };
    Hash.fromCbor = function (cStr) {
        return Hash.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr), { keepRef: true }));
    };
    Hash.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR format for \"Hash\"");
        return new Hash(cObj.bytes, (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    Hash.prototype.toData = function (_version) {
        return new plutus_data_1.DataB(this.toBuffer());
    };
    Hash.fromAscii = function (asciiStr) {
        return new Hash((0, uint8array_utils_1.fromAscii)(asciiStr));
    };
    Hash.toAscii = function (bStr) {
        return (0, uint8array_utils_1.toAscii)(bStr.toBuffer());
    };
    Hash.isValidHexValue = function (str) {
        return ((0, hex_1.isHex)(str) &&
            str.length % 2 === 0);
    };
    return Hash;
}());
exports.Hash = Hash;
