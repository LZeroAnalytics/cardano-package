"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XPub = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var add28mul8_1 = require("./add28mul8.js");
var crypto_1 = require("@harmoniclabs/crypto");
var XPub = /** @class */ (function () {
    function XPub(bytes) {
        if (!(bytes instanceof Uint8Array &&
            bytes.length === 64))
            throw new TypeError("invalid bytes for 'XPub'");
        Object.defineProperty(this, "bytes", {
            value: bytes,
            writable: false,
            enumerable: true,
            configurable: false
        });
    }
    XPub.prototype.toPubKeyBytes = function () {
        return this.bytes.slice(0, 32);
    };
    XPub.prototype.chainCode = function () {
        return this.bytes.slice(32, 64);
    };
    XPub.prototype.verify = function (message, signature) {
        return (0, crypto_1.verifyEd25519Signature_sync)(signature, message, this.toPubKeyBytes());
    };
    XPub.prototype.derive = function (index) {
        index = Math.round(Math.abs(index));
        // NO HARD DERIVATION FOR PUB KEY
        if (index >= 0x80000000)
            index = index - 0x80000000;
        var pk = this.toPubKeyBytes();
        var chainCode = this.chainCode();
        var z = new Uint8Array(1 + 32 + 4);
        var i = new Uint8Array(1 + 32 + 4);
        z.set([0x02], 0);
        z.set(pk, 1);
        (0, uint8array_utils_1.writeUint32LE)(z, index, 33);
        i.set([0x03], 0);
        i.set(pk, 1);
        (0, uint8array_utils_1.writeUint32LE)(i, index, 33);
        var zmac = (0, crypto_1.hmacSHA512)(chainCode, z);
        var leftZ = zmac.slice(0, 32);
        // const rightZ = zmac.slice( 32, 64 );
        var left = pointPlus(pk, point_of_trunc28_mul8(leftZ));
        // const right = add256Bits( rightKey, rightZ );
        var imac = (0, crypto_1.hmacSHA512)(chainCode, i);
        var nextChainCode = imac.slice(32, 64);
        var raw = new Uint8Array(64);
        raw.set(left, 0);
        raw.set(nextChainCode, 32);
        return new XPub(raw);
    };
    return XPub;
}());
exports.XPub = XPub;
function point_of_trunc28_mul8(sk) {
    var copy = (0, add28mul8_1.add28mul8)(new Uint8Array(32), sk);
    var scalar = (0, crypto_1.ed25519bigint)(bytesToNumberLE(copy));
    var a = (0, crypto_1.scalarMultBase)(scalar);
    return (0, crypto_1.bigpointToUint8Array)(a);
}
function pointPlus(p1, p2) {
    return (0, crypto_1.bigpointToUint8Array)((0, crypto_1.addPointsEdwards)((0, crypto_1.pointFromBytes)(p1), (0, crypto_1.pointFromBytes)(p2)));
}
function bytesToNumberLE(bytes) {
    return BigInt("0x" + (0, uint8array_utils_1.toHex)(Uint8Array.from(bytes).reverse()));
}
