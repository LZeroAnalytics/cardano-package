import { PLam } from "../PTypes/index.js";
import { Term } from "../Term/index.js";
import { ToPType } from "../type_system/ts-pluts-conversion.js";
import { TermType } from "../type_system/types.js";
import { UtilityTermOf } from "./std/UtilityTerms/addUtilityForType.js";
import { PappArg } from "./pappArg.js";
type PFnFromTypes<Ins extends [TermType, ...TermType[]], Out extends TermType> = Ins extends [infer T extends TermType] ? PLam<ToPType<T>, ToPType<Out>> : Ins extends [infer T extends TermType, ...infer RestTs extends [TermType, ...TermType[]]] ? PLam<ToPType<T>, PFnFromTypes<RestTs, Out>> : never;
type TermFnFromTypes<Ins extends [TermType, ...TermType[]], Out extends TermType> = Ins extends [infer T extends TermType] ? Term<PLam<ToPType<T>, ToPType<Out>>> & {
    $: (input: PappArg<ToPType<T>>) => UtilityTermOf<ToPType<Out>>;
} : Ins extends [infer T extends TermType, ...infer RestIns extends [TermType, ...TermType[]]] ? Term<PLam<ToPType<T>, PFnFromTypes<RestIns, Out>>> & {
    $: (input: PappArg<ToPType<T>>) => TermFnFromTypes<RestIns, Out>;
} : never;
type TsTermFunctionArgs<InputsTypes extends [TermType, ...TermType[]]> = InputsTypes extends [] ? never : InputsTypes extends [infer T extends TermType] ? [UtilityTermOf<ToPType<T>>] : InputsTypes extends [
    infer T extends TermType,
    ...infer RestTs extends [TermType, ...TermType[]]
] ? [UtilityTermOf<ToPType<T>>, ...TsTermFunctionArgs<RestTs>] : never;
export type TsTermFunction<InputsTypes extends [TermType, ...TermType[]], OutputType extends TermType> = (...args: TsTermFunctionArgs<InputsTypes>) => Term<ToPType<OutputType>>;
export declare function pfn<InputsTypes extends [TermType, ...TermType[]], OutputType extends TermType>(inputsTypes: InputsTypes, outputType: OutputType): (termFunction: TsTermFunction<InputsTypes, OutputType>, funcName?: string | undefined) => TermFnFromTypes<InputsTypes, OutputType>;
export {};
