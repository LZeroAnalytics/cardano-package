"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.markRecursiveHoistsAsForced = void 0;
var IRApp_1 = require("../../IRNodes/IRApp.js");
var IRDelayed_1 = require("../../IRNodes/IRDelayed.js");
var IRForced_1 = require("../../IRNodes/IRForced.js");
var IRFunc_1 = require("../../IRNodes/IRFunc.js");
var IRHoisted_1 = require("../../IRNodes/IRHoisted.js");
var IRLetted_1 = require("../../IRNodes/IRLetted.js");
var IRNative_1 = require("../../IRNodes/IRNative/index.js");
function markRecursiveHoistsAsForced(_term) {
    var stack = [{ term: _term, isInRecursiveTerm: false }];
    while (stack.length > 0) {
        var _a = stack.pop(), t = _a.term, isInRecursiveTerm = _a.isInRecursiveTerm, isIRAppArg = _a.isIRAppArg;
        if (t instanceof IRApp_1.IRApp) {
            // must push the arg first and then the fucntion
            // so that we can check if the function is the Z combinator before the arg is processed
            stack.push({ term: t.arg, isIRAppArg: true, isInRecursiveTerm: isInRecursiveTerm }, { term: t.fn, isInRecursiveTerm: isInRecursiveTerm });
            continue;
        }
        if (t instanceof IRNative_1.IRNative &&
            t.tag === -1 /* IRNativeTag.z_comb */ &&
            stack.length > 0 && (stack[stack.length - 1].isIRAppArg === true)) {
            stack[stack.length - 1].isInRecursiveTerm = true;
            continue;
        }
        if (t instanceof IRHoisted_1.IRHoisted ||
            t instanceof IRLetted_1.IRLetted) {
            // if it is an hoisted/letted
            // DIRECTLY applied to something that makes it recursive
            if (isIRAppArg &&
                t.parent instanceof IRApp_1.IRApp &&
                t.parent.fn instanceof IRNative_1.IRNative &&
                t.parent.fn.tag === -1 /* IRNativeTag.z_comb */) {
                // then check the hoisted/letted value instead of marking as hoisted
                if (t instanceof IRLetted_1.IRLetted) {
                    stack.push({ term: t.value, isInRecursiveTerm: isInRecursiveTerm });
                    continue;
                }
                else // if( t instanceof IRHoisted )
                 {
                    stack.push({ term: t.hoisted, isInRecursiveTerm: isInRecursiveTerm });
                    continue;
                }
                continue;
            }
            if (isInRecursiveTerm) {
                t.meta.forceHoist = true;
                // don't push anything to the stack
                // hoisted values are handled normally
                continue;
            }
            // otherwhise check in values too
            else if (t instanceof IRLetted_1.IRLetted) {
                stack.push({ term: t.value, isInRecursiveTerm: isInRecursiveTerm });
                continue;
            }
            else // if( t instanceof IRHoisted )
             {
                stack.push({ term: t.hoisted, isInRecursiveTerm: isInRecursiveTerm });
                continue;
            }
        }
        if (t instanceof IRDelayed_1.IRDelayed) {
            stack.push({ term: t.delayed, isInRecursiveTerm: isInRecursiveTerm });
            continue;
        }
        if (t instanceof IRForced_1.IRForced) {
            stack.push({ term: t.forced, isInRecursiveTerm: isInRecursiveTerm });
            continue;
        }
        if (t instanceof IRFunc_1.IRFunc) {
            stack.push({ term: t.body, isInRecursiveTerm: isInRecursiveTerm });
            continue;
        }
    }
}
exports.markRecursiveHoistsAsForced = markRecursiveHoistsAsForced;
