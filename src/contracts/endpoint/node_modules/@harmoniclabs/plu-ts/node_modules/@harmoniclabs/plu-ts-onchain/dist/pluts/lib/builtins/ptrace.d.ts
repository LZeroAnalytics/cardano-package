import type { TermFn, PString } from "../../PTypes/index.js";
import { Term } from "../../Term/index.js";
import { TermType, ToPType } from "../../type_system/index.js";
export declare function ptrace<ReturnT extends TermType>(returnT: ReturnT): TermFn<[PString, ToPType<ReturnT>], ToPType<ReturnT>>;
export declare const ptraceIfTrue: Term<import("../../PTypes/index.js").PLam<import("../../PTypes/index.js").PDelayed<PString>, import("../../PTypes/index.js").PLam<import("../../PTypes/index.js").PBool, import("../../PTypes/index.js").PBool>>> & {
    $: (input: import("../index.js").PappArg<import("../../PTypes/index.js").PDelayed<PString>>) => Term<import("../../PTypes/index.js").PLam<import("../../PTypes/index.js").PBool, import("../../PTypes/index.js").PBool>> & {
        $: (input: import("../index.js").PappArg<import("../../PTypes/index.js").PBool>) => import("../index.js").UtilityTermOf<import("../../PTypes/index.js").PBool>;
    };
};
export declare const ptraceIfFalse: Term<import("../../PTypes/index.js").PLam<import("../../PTypes/index.js").PDelayed<PString>, import("../../PTypes/index.js").PLam<import("../../PTypes/index.js").PBool, import("../../PTypes/index.js").PBool>>> & {
    $: (input: import("../index.js").PappArg<import("../../PTypes/index.js").PDelayed<PString>>) => Term<import("../../PTypes/index.js").PLam<import("../../PTypes/index.js").PBool, import("../../PTypes/index.js").PBool>> & {
        $: (input: import("../index.js").PappArg<import("../../PTypes/index.js").PBool>) => import("../index.js").UtilityTermOf<import("../../PTypes/index.js").PBool>;
    };
};
export declare function ptraceError<T extends TermType>(t: T, somemsg?: string): TermFn<[PString], ToPType<T>>;
