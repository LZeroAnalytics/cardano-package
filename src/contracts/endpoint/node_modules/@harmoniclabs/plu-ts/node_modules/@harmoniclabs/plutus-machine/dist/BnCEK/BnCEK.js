"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BnCEK = exports.haskellMod = exports.haskellDiv = exports.haskellRem = exports.haskellQuot = void 0;
var bigint_utils_1 = require("@harmoniclabs/bigint-utils");
var bytestring_1 = require("@harmoniclabs/bytestring");
var pair_1 = require("@harmoniclabs/pair");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var uplc_1 = require("@harmoniclabs/uplc");
var ExBudget_1 = require("../Machine/ExBudget.js");
var crypto_1 = require("@harmoniclabs/crypto");
function intToSize(n) {
    n = BigInt(n);
    if (n === BigInt(0))
        return BigInt(1);
    // same as `intToSize( -n - BigInt( 1 ) )` but inlined
    if (n < BigInt(0))
        return ((0, bigint_utils_1.log2)((-n - BigInt(1)) << BigInt(1)) / BigInt(8)) + BigInt(1);
    return ((0, bigint_utils_1.log2)(n << BigInt(1)) / BigInt(8)) + BigInt(1);
}
function bsToSize(bs) {
    var len = ((bs instanceof Uint8Array) ? bs : bs.toBuffer()).length;
    return len === 0 ?
        // TODO: Bug in cardano-node; to fix next hard fork
        BigInt(1) :
        BigInt(len);
}
function strToSize(str) {
    return bsToSize((0, uint8array_utils_1.fromUtf8)(str));
}
;
var BOOL_SIZE = BigInt(1);
var ANY_SIZE = BigInt(1);
function constValueToSize(v) {
    if ((0, uplc_1.isConstValueInt)(v))
        return intToSize(BigInt(v));
    if (v instanceof bytestring_1.ByteString)
        return bsToSize(v.toBuffer());
    if (typeof v === "string")
        return strToSize(v);
    if (typeof v === "undefined")
        return ANY_SIZE;
    if (typeof v === "boolean")
        return BOOL_SIZE;
    if ((0, plutus_data_1.isData)(v))
        return dataToSize(v);
    if (Array.isArray(v))
        return listToSize(v);
    if (v instanceof pair_1.Pair)
        return pairToSize(v);
    console.warn("unexpected 'constValueToSize'; exec costs evaluation might be inaccurate");
    return ANY_SIZE;
}
function listToSize(l) {
    return l.reduce(function (acc, elem) { return acc + constValueToSize(elem); }, BigInt(0));
}
function pairToSize(pairValue) {
    return constValueToSize(pairValue.fst) + constValueToSize(pairValue.snd);
}
function dataToSize(data) {
    var stack = [data];
    var tot = BigInt(0);
    while (stack.length > 0) {
        var top_1 = stack.pop();
        tot += BigInt(4);
        if (top_1 instanceof plutus_data_1.DataConstr) {
            stack.unshift.apply(stack, __spreadArray([], __read(top_1.fields), false));
        }
        else if (top_1 instanceof plutus_data_1.DataMap) {
            stack.unshift.apply(stack, __spreadArray([], __read(top_1.map.reduce(function (accum, elem) { return __spreadArray([elem.fst, elem.snd], __read(accum), false); }, [])), false));
        }
        else if (top_1 instanceof plutus_data_1.DataList) {
            stack.unshift.apply(stack, __spreadArray([], __read(top_1.list), false));
        }
        else if (top_1 instanceof plutus_data_1.DataI) {
            tot += intToSize(top_1.int);
        }
        else if (top_1 instanceof plutus_data_1.DataB) {
            tot += bsToSize(top_1.bytes);
        }
        else
            break; // top === undefined; stack empty (unreachable)
    }
    return tot;
}
function isConstOfType(constant, ty) {
    var checkValue = function (v) {
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.int, ty)) {
            return (0, uplc_1.isConstValueInt)(v);
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.bool, ty)) {
            return typeof v === "boolean";
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.byteStr, ty)) {
            return (bytestring_1.ByteString.isStrictInstance(v));
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.data, ty)) {
            return ((0, plutus_data_1.isData)(v));
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.str, ty)) {
            return typeof v === "string";
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.unit, ty)) {
            return v === undefined;
        }
        return false;
    };
    // if( constant instanceof HoistedUPLC ) constant = constant.UPLC;
    return (constant instanceof uplc_1.UPLCConst &&
        (0, uplc_1.constTypeEq)(constant.type, ty) &&
        checkValue(constant.value));
}
function getInt(a) {
    if (!isConstOfType(a, uplc_1.constT.int))
        return undefined;
    return BigInt(a.value);
}
function getInts(a, b) {
    if (!isConstOfType(a, uplc_1.constT.int))
        return undefined;
    if (!isConstOfType(b, uplc_1.constT.int))
        return undefined;
    return {
        a: BigInt(a.value),
        b: BigInt(b.value)
    };
}
function getBS(a) {
    if (!isConstOfType(a, uplc_1.constT.byteStr))
        return undefined;
    return a.value;
}
function getStr(a) {
    if (!isConstOfType(a, uplc_1.constT.str))
        return undefined;
    return a.value;
}
function getList(list) {
    if (!(list instanceof uplc_1.UPLCConst &&
        list.type[0] === uplc_1.ConstTyTag.list &&
        Array.isArray(list.value)))
        return undefined;
    return list.value.slice();
}
function getPair(pair) {
    if (!(pair instanceof uplc_1.UPLCConst &&
        pair.type[0] === uplc_1.ConstTyTag.pair &&
        pair_1.Pair.isStrictInstance(pair.value)))
        return undefined;
    return pair.clone().value;
}
function getData(data) {
    if (!(data instanceof uplc_1.UPLCConst &&
        (0, uplc_1.constTypeEq)(data.type, uplc_1.constT.data) &&
        (0, plutus_data_1.isData)(data.value)))
        return undefined;
    return data.value;
}
function intBinOp(a, b, op, fnName) {
    var ints = getInts(a, b);
    if (ints === undefined)
        return new uplc_1.ErrorUPLC("".concat(fnName, " :: invalid arguments"), { a: a, b: b });
    var result = op(ints.a, ints.b);
    if (result === undefined)
        return new uplc_1.ErrorUPLC("".concat(fnName, " :: operation error"), { a: a, b: b, ints_a: ints.a, ints_b: ints.b });
    return uplc_1.UPLCConst.int(result);
}
function haskellQuot(a, b) {
    if (b === BigInt(0))
        return undefined;
    return a / b;
}
exports.haskellQuot = haskellQuot;
function haskellRem(a, b) {
    if (b === BigInt(0))
        return undefined;
    return a % b;
}
exports.haskellRem = haskellRem;
function haskellQuotRem(a, b) {
    var quot = haskellQuot(a, b);
    if (quot === undefined)
        return quot;
    var rem = haskellRem(a, b);
    if (rem === undefined)
        return rem;
    return [quot, rem];
}
function haskellDivMod(a, b) {
    if (b === BigInt(0))
        return undefined;
    if (a > BigInt(0) && b < BigInt(0)) {
        var qr = haskellQuotRem(a - BigInt(1), b);
        if (qr === undefined)
            return undefined;
        return [
            qr[0] - BigInt(1),
            qr[1] + b + BigInt(1)
        ];
    }
    if (a < BigInt(0) && b > BigInt(0)) {
        var qr = haskellQuotRem(a + BigInt(1), b);
        if (qr === undefined)
            return undefined;
        return [
            qr[0] - BigInt(1),
            qr[1] + b - BigInt(1)
        ];
    }
    return haskellQuotRem(a, b);
}
function haskellDiv(a, b) {
    var dm = haskellDivMod(a, b);
    if (dm === undefined)
        return undefined;
    return dm[0];
}
exports.haskellDiv = haskellDiv;
function haskellMod(a, b) {
    var dm = haskellDivMod(a, b);
    if (dm === undefined)
        return undefined;
    return dm[1];
}
exports.haskellMod = haskellMod;
var BnCEK = /** @class */ (function () {
    function BnCEK(getBuiltinCostFunc, machineBudget, logs) {
        this.getBuiltinCostFunc = getBuiltinCostFunc;
        this.logs = logs;
        this.machineBudget = machineBudget;
    }
    ;
    BnCEK.prototype.eval = function (bn) {
        switch (bn.tag) {
            case uplc_1.UPLCBuiltinTag.addInteger: return this.addInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.subtractInteger: return this.subtractInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.multiplyInteger: return this.multiplyInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.divideInteger: return this.divideInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.quotientInteger: return this.quotientInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.remainderInteger: return this.remainderInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.modInteger: return this.modInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsInteger: return this.equalsInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanInteger: return this.lessThanInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanEqualInteger: return this.lessThanEqualInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.appendByteString: return this.appendByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.consByteString: return this.consByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sliceByteString: return this.sliceByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lengthOfByteString: return this.lengthOfByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.indexByteString: return this.indexByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsByteString: return this.equalsByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanByteString: return this.lessThanByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanEqualsByteString: return this.lessThanEqualsByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sha2_256: return this.sha2_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sha3_256: return this.sha3_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.blake2b_256: return this.blake2b_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.verifyEd25519Signature: return this.verifyEd25519Signature.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.appendString: return this.appendString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsString: return this.equalsString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.encodeUtf8: return this.encodeUtf8.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.decodeUtf8: return this.decodeUtf8.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.ifThenElse: return this.ifThenElse.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.chooseUnit: return this.chooseUnit.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.trace: return this.trace.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.fstPair: return this.fstPair.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sndPair: return this.sndPair.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.chooseList: return this.chooseList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkCons: return this.mkCons.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.headList: return this.headList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.tailList: return this.tailList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.nullList: return this.nullList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.chooseData: return this.chooseData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.constrData: return this.constrData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mapData: return this.mapData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.listData: return this.listData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.iData: return this.iData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bData: return this.bData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unConstrData: return this.unConstrData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unMapData: return this.unMapData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unListData: return this.unListData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unIData: return this.unIData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unBData: return this.unBData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsData: return this.equalsData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkPairData: return this.mkPairData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkNilData: return this.mkNilData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkNilPairData: return this.mkNilPairData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.serialiseData: return this.serialiseData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.verifyEcdsaSecp256k1Signature: throw new Error("builtin implementation missing"); //return (this.verifyEcdsaSecp256k1Signature as any)( ...bn.args );
            case uplc_1.UPLCBuiltinTag.verifySchnorrSecp256k1Signature: throw new Error("builtin implementation missing"); //return (this.verifySchnorrSecp256k1Signature as any)( ...bn.args );
            default:
                // tag; // check that is of type 'never'
                return new uplc_1.ErrorUPLC("unrecognized builtin tag", { tag: bn.tag });
        }
    };
    BnCEK.prototype.addInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.addInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return a + b;
        }).bind(this), "addInteger");
    };
    BnCEK.prototype.subtractInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.subtractInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return a - b;
        }).bind(this), "subtractInteger");
    };
    BnCEK.prototype.multiplyInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.multiplyInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return a * b;
        }).bind(this), "multiplyInteger");
    };
    BnCEK.prototype.divideInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.divideInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellDiv(a, b);
        }).bind(this), "divideInteger");
    };
    BnCEK.prototype.quotientInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.quotientInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellQuot(a, b);
        }).bind(this), "quotientInteger");
    };
    BnCEK.prototype.remainderInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.remainderInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellRem(a, b);
        }).bind(this), "remainderInteger");
    };
    BnCEK.prototype.modInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.modInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellMod(a, b);
        }).bind(this), "modInteger");
    };
    BnCEK.prototype.equalsInteger = function (a, b) {
        var ints = getInts(a, b);
        if (ints === undefined)
            return new uplc_1.ErrorUPLC("equalsInteger :: not integers", { a: a, b: b, ints: ints });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsInteger);
        var sa = intToSize(ints.a);
        var sb = intToSize(ints.b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.bool(ints.a === ints.b);
    };
    BnCEK.prototype.lessThanInteger = function (a, b) {
        var ints = getInts(a, b);
        if (ints === undefined)
            return new uplc_1.ErrorUPLC("lessThanInteger :: not integers", { a: a, b: b, ints: ints });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanInteger);
        var sa = intToSize(ints.a);
        var sb = intToSize(ints.b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.bool(ints.a < ints.b);
    };
    BnCEK.prototype.lessThanEqualInteger = function (a, b) {
        var ints = getInts(a, b);
        if (ints === undefined)
            return new uplc_1.ErrorUPLC("lessThanEqualInteger :: not integers", { a: a, b: b, ints: ints });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanEqualInteger);
        var sa = intToSize(ints.a);
        var sb = intToSize(ints.b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.bool(ints.a <= ints.b);
    };
    BnCEK.prototype.appendByteString = function (a, b) {
        var _a = getBS(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("appendByteString :: not BS", { a: a });
        var _b = getBS(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("appendByteString :: not BS", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.appendByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString(_a.toString() + _b.toString()));
    };
    BnCEK.prototype.consByteString = function (a, b) {
        var _a = getInt(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("consByteString :: not Int", { a: a });
        _a = (0, bigint_utils_1.abs)(_a) % BigInt(256);
        var _b = getBS(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("consByteString :: not BS", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.consByteString);
        var sa = intToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString(_a.toString(16).padStart(2, '0') + _b.toString()));
    };
    BnCEK.prototype.sliceByteString = function (fromIdx, ofLength, bs) {
        var idx = getInt(fromIdx);
        if (idx === undefined)
            return new uplc_1.ErrorUPLC("sliceByteString :: not int", { fromIdx: fromIdx });
        var length = getInt(ofLength);
        if (length === undefined)
            return new uplc_1.ErrorUPLC("sliceByteString :: not int", { ofLength: ofLength });
        var _bs = getBS(bs);
        if (_bs === undefined)
            return new uplc_1.ErrorUPLC("sliceByteString :: not BS", { bs: bs });
        var i = idx < BigInt(0) ? BigInt(0) : idx;
        var endIdx = idx + length - BigInt(1);
        var maxIdx = BigInt(_bs.toBuffer().length) - BigInt(1);
        var j = endIdx > maxIdx ? maxIdx : endIdx;
        if (j < i)
            return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString(Uint8Array.from([])));
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sliceByteString);
        var sidx = intToSize(idx);
        var slength = intToSize(length);
        var sbs = bsToSize(_bs);
        this.machineBudget.add({
            mem: f.mem.at(sidx, slength, sbs),
            cpu: f.cpu.at(sidx, slength, sbs)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString(Uint8Array.from(_bs.toBuffer().slice(Number(i), Number(j)))));
    };
    BnCEK.prototype.lengthOfByteString = function (bs) {
        var _bs = getBS(bs);
        if (_bs === undefined)
            return new uplc_1.ErrorUPLC("lengthOfByteString :: not BS", { bs: bs });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lengthOfByteString);
        var sbs = bsToSize(_bs);
        this.machineBudget.add({
            mem: f.mem.at(sbs),
            cpu: f.cpu.at(sbs)
        });
        return uplc_1.UPLCConst.int(_bs.toBuffer().length);
    };
    BnCEK.prototype.indexByteString = function (bs, idx) {
        var _bs = getBS(bs);
        if (_bs === undefined)
            return new uplc_1.ErrorUPLC("indexByteString :: not BS", { bs: bs });
        var i = getInt(idx);
        if (i === undefined || i >= _bs.toBuffer().length || i < BigInt(0))
            return new uplc_1.ErrorUPLC("indexByteString :: not int", { idx: idx });
        var result = _bs.toBuffer().at(Number(i));
        if (result === undefined)
            return new uplc_1.ErrorUPLC("indexByteString :: out of bytestring length", { bs_length: _bs.toBuffer().length, index: i });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.indexByteString);
        var sbs = bsToSize(_bs);
        var sidx = intToSize(i);
        this.machineBudget.add({
            mem: f.mem.at(sbs, sidx),
            cpu: f.cpu.at(sbs, sidx)
        });
        return uplc_1.UPLCConst.int(result);
    };
    BnCEK.prototype.equalsByteString = function (a, b) {
        var _a = getBS(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("equalsByteString :: first argument not BS", {
                bs_0: a,
                bs_1: b
            });
        var _b = getBS(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("equalsByteString :: secondt argument not BS", {
                bs_0: a,
                bs_1: b
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.bool(_a.toString() === _b.toString());
    };
    BnCEK.prototype.lessThanByteString = function (a, b) {
        var _c;
        var _a = getBS(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("lessThanByteString :: not BS", { a: a });
        var _b = getBS(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("lessThanByteString :: not BS", { b: b });
        var aBytes = _a.toBuffer();
        var bBytes = _b.toBuffer();
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        if (aBytes.length < bBytes.length)
            return uplc_1.UPLCConst.bool(true);
        // aBytes.length is either greather or equal bBytes.length
        for (var i = 0; i < aBytes.length; i++) {
            var aByte = (_c = aBytes.at(i)) !== null && _c !== void 0 ? _c : Infinity;
            var bByte = bBytes.at(i);
            if (bByte === undefined)
                return uplc_1.UPLCConst.bool(false);
            if (aByte < bByte)
                return uplc_1.UPLCConst.bool(true);
            if (aByte > bByte)
                return uplc_1.UPLCConst.bool(false);
        }
        return uplc_1.UPLCConst.bool(false);
    };
    BnCEK.prototype.lessThanEqualsByteString = function (a, b) {
        var _a = getBS(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("lessThanEqualsByteString :: not BS", { a: a });
        var _b = getBS(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("lessThanEqualsByteString :: not BS", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanEqualsByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        if (_a.toString() === _b.toString())
            return uplc_1.UPLCConst.bool(true);
        // lessThanBytestring but with new environment for costs;
        return (new BnCEK(this.getBuiltinCostFunc, new ExBudget_1.ExBudget(0, 0), [])).lessThanByteString(a, b);
    };
    BnCEK.prototype.sha2_256 = function (stuff) {
        var b = getBS(stuff);
        if (b === undefined)
            return new uplc_1.ErrorUPLC("sha2_256 :: not BS", { stuff: stuff });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sha2_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString((0, uint8array_utils_1.toHex)(new Uint8Array((0, crypto_1.sha2_256)(b.toBuffer())))));
    };
    BnCEK.prototype.sha3_256 = function (stuff) {
        var b = getBS(stuff);
        if (b === undefined)
            return new uplc_1.ErrorUPLC("sha3_256 :: not BS", stuff);
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sha3_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString((0, uint8array_utils_1.toHex)(new Uint8Array((0, crypto_1.sha3)(b.toBuffer())))));
    };
    BnCEK.prototype.blake2b_256 = function (stuff) {
        var b = getBS(stuff);
        if (b === undefined)
            return new uplc_1.ErrorUPLC("blake2b_256 :: not BS", { stuff: stuff });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.blake2b_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString((0, crypto_1.blake2b)(b.toBuffer(), 32)));
    };
    BnCEK.prototype.verifyEd25519Signature = function (key, message, signature) {
        var k = getBS(key);
        if (k === undefined)
            return new uplc_1.ErrorUPLC("verifyEd25519Signature :: key not BS", { key: key });
        var kBytes = k.toBuffer();
        if (kBytes.length !== 32)
            return new uplc_1.ErrorUPLC("sha2_verifyEd25519Signature256 :: wrong message length", {
                kBytes: kBytes,
                kStr: k.toString()
            });
        var m = getBS(message);
        if (m === undefined)
            return new uplc_1.ErrorUPLC("verifyEd25519Signature :: message not BS", { message: message });
        var s = getBS(signature);
        if (s === undefined)
            return new uplc_1.ErrorUPLC("verifyEd25519Signature :: singature not BS", { signature: signature });
        var sBytes = s.toBuffer();
        if (sBytes.length !== 64)
            return new uplc_1.ErrorUPLC("sha2_verifyEd25519Signature256 :: wrong signature length", {
                signature_length: sBytes.length,
                signatureHex: s.toString(),
                signatureBytes: sBytes
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.verifyEd25519Signature);
        var sk = bsToSize(kBytes);
        var sm = bsToSize(m);
        var ss = bsToSize(sBytes);
        this.machineBudget.add({
            mem: f.mem.at(sk, sm, ss),
            cpu: f.cpu.at(sk, sm, ss)
        });
        return uplc_1.UPLCConst.bool((0, crypto_1.verifyEd25519Signature)(sBytes, m.toBuffer(), kBytes));
    };
    BnCEK.prototype.appendString = function (a, b) {
        var _a = getStr(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("appendString :: not Str", { a: a });
        var _b = getStr(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("appendString :: not Str", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.appendString);
        var sa = strToSize(_a);
        var sb = strToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.str(_a + _b);
    };
    BnCEK.prototype.equalsString = function (a, b) {
        var _a = getStr(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("equalsString :: not Str", { a: a });
        var _b = getStr(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("equalsString :: not Str", {
                b: b
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsString);
        var sa = strToSize(_a);
        var sb = strToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.bool(_a === _b);
    };
    BnCEK.prototype.encodeUtf8 = function (a) {
        var _a = getStr(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("encodeUtf8 :: not Str", { a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.encodeUtf8);
        var sa = strToSize(_a);
        this.machineBudget.add({
            mem: f.mem.at(sa),
            cpu: f.cpu.at(sa)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString((0, uint8array_utils_1.fromUtf8)(_a)));
    };
    BnCEK.prototype.decodeUtf8 = function (a) {
        var _a = getBS(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("decodeUtf8 :: not BS", {
                arg: a
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.decodeUtf8);
        var sa = bsToSize(_a);
        this.machineBudget.add({
            mem: f.mem.at(sa),
            cpu: f.cpu.at(sa)
        });
        return uplc_1.UPLCConst.str((0, uint8array_utils_1.toUtf8)(_a.toBuffer()));
    };
    BnCEK.prototype.ifThenElse = function (condition, caseTrue, caseFalse) {
        if (!isConstOfType(condition, uplc_1.constT.bool))
            return new uplc_1.ErrorUPLC("ifThenElse :: condition was not a boolean", { condition: condition });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.ifThenElse);
        this.machineBudget.add({
            mem: f.mem.at(BOOL_SIZE, ANY_SIZE, ANY_SIZE),
            cpu: f.cpu.at(BOOL_SIZE, ANY_SIZE, ANY_SIZE),
        });
        return condition.value ? caseTrue : caseFalse;
    };
    BnCEK.prototype.chooseUnit = function (unit, b) {
        if (!isConstOfType(unit, uplc_1.constT.unit))
            return new uplc_1.ErrorUPLC("chooseUnit :: not a unit", { unit: unit });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.chooseUnit);
        this.machineBudget.add({
            mem: f.mem.at(ANY_SIZE, ANY_SIZE),
            cpu: f.cpu.at(ANY_SIZE, ANY_SIZE)
        });
        return b;
    };
    BnCEK.prototype.trace = function (msg, result) {
        var _msg = getStr(msg);
        this.logs.push(_msg !== null && _msg !== void 0 ? _msg : "_msg_not_a_string_");
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.trace);
        var smsg = _msg ? strToSize(_msg) : BigInt(0);
        this.machineBudget.add({
            mem: f.mem.at(smsg, ANY_SIZE),
            cpu: f.cpu.at(smsg, ANY_SIZE)
        });
        return result;
    };
    BnCEK.prototype.fstPair = function (pair) {
        var p = getPair(pair);
        if (p === undefined)
            return new uplc_1.ErrorUPLC("fstPair :: not a pair", { pair: pair });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.fstPair);
        var sp = pairToSize(p);
        this.machineBudget.add({
            mem: f.mem.at(sp),
            cpu: f.cpu.at(sp)
        });
        return new uplc_1.UPLCConst(uplc_1.constPairTypeUtils.getFirstTypeArgument(pair.type), p.fst);
    };
    BnCEK.prototype.sndPair = function (pair) {
        var p = getPair(pair);
        if (p === undefined)
            return new uplc_1.ErrorUPLC("sndPair :: not a pair", { pair: pair });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sndPair);
        var sp = pairToSize(p);
        this.machineBudget.add({
            mem: f.mem.at(sp),
            cpu: f.cpu.at(sp)
        });
        return new uplc_1.UPLCConst(uplc_1.constPairTypeUtils.getSecondTypeArgument(pair.type), p.snd);
    };
    BnCEK.prototype.chooseList = function (list, whateverA, whateverB) {
        var l = getList(list);
        if (l === undefined)
            return new uplc_1.ErrorUPLC("chooseList :: not a list", { list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.chooseList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl, ANY_SIZE, ANY_SIZE),
            cpu: f.cpu.at(sl, ANY_SIZE, ANY_SIZE)
        });
        return l.length === 0 ? whateverA : whateverB;
    };
    BnCEK.prototype.mkCons = function (elem, list) {
        if (!(elem instanceof uplc_1.UPLCConst &&
            list instanceof uplc_1.UPLCConst &&
            list.type[0] === uplc_1.ConstTyTag.list &&
            (0, uplc_1.constTypeEq)(elem.type, uplc_1.constListTypeUtils.getTypeArgument(list.type))))
            return new uplc_1.ErrorUPLC("mkCons :: incongruent list types; listT: " +
                (list instanceof uplc_1.UPLCConst ? (0, uplc_1.constTypeToStirng)(list.type) : "") +
                "; elemsT: " +
                (elem instanceof uplc_1.UPLCConst ? (0, uplc_1.constTypeToStirng)(elem.type) : ""), {
                list: list,
                elem: elem
            });
        var l = getList(list);
        if (l === undefined)
            return new uplc_1.ErrorUPLC("mkCons :: not a list", { list: list });
        var value = elem.value;
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkCons);
        var sl = listToSize(l);
        var sv = constValueToSize(value);
        this.machineBudget.add({
            mem: f.mem.at(sv, sl),
            cpu: f.cpu.at(sv, sl)
        });
        return new uplc_1.UPLCConst(list.type, __spreadArray([value], __read(l), false));
    };
    BnCEK.prototype.headList = function (list) {
        var l = getList(list);
        if (l === undefined || l.length === 0)
            return new uplc_1.ErrorUPLC(l === undefined ?
                "headList :: not a list" :
                "headList :: empty list passed to 'head'", { list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.headList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl),
            cpu: f.cpu.at(sl)
        });
        return new uplc_1.UPLCConst(uplc_1.constListTypeUtils.getTypeArgument(list.type), l[0]);
    };
    BnCEK.prototype.tailList = function (list) {
        var l = getList(list);
        if (l === undefined || l.length === 0)
            return new uplc_1.ErrorUPLC(l === undefined ?
                "tailList :: not a list" :
                "tailList :: empty list passed to 'tail'", { list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.tailList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl),
            cpu: f.cpu.at(sl)
        });
        return new uplc_1.UPLCConst(list.type, l.slice(1));
    };
    BnCEK.prototype.nullList = function (list) {
        var l = getList(list);
        if (l === undefined)
            return new uplc_1.ErrorUPLC("nullList :: not a list", { arg: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.nullList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl),
            cpu: f.cpu.at(sl)
        });
        return uplc_1.UPLCConst.bool(l.length === 0);
    };
    BnCEK.prototype.chooseData = function (data, constr, map, list, int, bs) {
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("chooseData :: not data", { data: data });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.chooseData);
        var sd = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(sd),
            cpu: f.cpu.at(sd)
        });
        if (d instanceof plutus_data_1.DataConstr)
            return constr;
        if (d instanceof plutus_data_1.DataMap)
            return map;
        if (d instanceof plutus_data_1.DataList)
            return list;
        if (d instanceof plutus_data_1.DataI)
            return int;
        if (d instanceof plutus_data_1.DataB)
            return bs;
        return new uplc_1.ErrorUPLC("unrecognized data, possibly DataPair", { data: data, d: d });
    };
    BnCEK.prototype.constrData = function (idx, fields) {
        var i = getInt(idx);
        if (i === undefined)
            return new uplc_1.ErrorUPLC("constrData :: not int", { idx: idx });
        var _fields = getList(fields);
        if (_fields === undefined)
            return new uplc_1.ErrorUPLC("constrData :: not a list", { fields: fields });
        if (!(0, uplc_1.constTypeEq)(fields.type, uplc_1.constT.listOf(uplc_1.constT.data)))
            return new uplc_1.ErrorUPLC("constrData :: passed fields are not a list of Data", { fields: fields, type: fields === null || fields === void 0 ? void 0 : fields.type });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.constrData);
        var si = intToSize(i);
        var sfields = _fields.reduce(function (acc, elem) { return acc + dataToSize(elem); }, BigInt(0));
        this.machineBudget.add({
            mem: f.mem.at(si, sfields),
            cpu: f.cpu.at(si, sfields),
        });
        // assert we got a list of data
        // ( the type has been forced but not the value )
        if (!_fields.every(function (field) { return (0, plutus_data_1.isData)(field); }))
            return new uplc_1.ErrorUPLC("constrData :: some of the fields are not Data, mismatching UPLCConst type", { _fields: _fields });
        return uplc_1.UPLCConst.data(new plutus_data_1.DataConstr(i, _fields));
    };
    BnCEK.prototype.mapData = function (listOfPair) {
        if (!(listOfPair instanceof uplc_1.UPLCConst &&
            (0, uplc_1.constTypeEq)(listOfPair.type, uplc_1.constT.listOf(uplc_1.constT.pairOf(uplc_1.constT.data, uplc_1.constT.data)))))
            return new uplc_1.ErrorUPLC("mapData :: not a map", { listOfPair: listOfPair });
        var list = getList(listOfPair);
        if (list === undefined)
            return new uplc_1.ErrorUPLC("mapData :: not a list", { listOfPair: listOfPair });
        // assert we got a list of pair of datas
        // ( the type has been forced but not the value )
        if (!list.every(function (pair) {
            return pair_1.Pair.isStrictInstance(pair) &&
                (0, plutus_data_1.isData)(pair.fst) &&
                (0, plutus_data_1.isData)(pair.snd);
        }))
            return new uplc_1.ErrorUPLC("some elements are not a pair, mismatching const type", { listOfPair: listOfPair, list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mapData);
        var size = listToSize(list);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.data(new plutus_data_1.DataMap(list.map(function (pair) { return new plutus_data_1.DataPair(pair.fst, pair.snd); })));
    };
    BnCEK.prototype.listData = function (listOfData) {
        if (!(listOfData instanceof uplc_1.UPLCConst &&
            (0, uplc_1.constTypeEq)(listOfData.type, uplc_1.constT.listOf(uplc_1.constT.data))))
            return new uplc_1.ErrorUPLC("listData :: not a list of data", { listOfData: listOfData });
        var list = getList(listOfData);
        if (list === undefined)
            return new uplc_1.ErrorUPLC("listData :: not a list", { listOfData: listOfData });
        // assert we got a list of data
        // ( the type has been forced but not the value )
        if (!list.every(function (data) { return (0, plutus_data_1.isData)(data); }))
            return new uplc_1.ErrorUPLC("some of the elements are not data, mismatching const type", { listOfData: listOfData });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.listData);
        var size = listToSize(list);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.data(new plutus_data_1.DataList(list));
    };
    BnCEK.prototype.iData = function (int) {
        var i = getInt(int);
        if (i === undefined)
            return new uplc_1.ErrorUPLC("iData :: not an int", {
                arg: int,
                type: int.type,
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.iData);
        var size = intToSize(i);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.data(new plutus_data_1.DataI(i));
    };
    BnCEK.prototype.bData = function (bs) {
        var b = getBS(bs);
        if (b === undefined)
            return new uplc_1.ErrorUPLC("bData :: not BS", {
                arg: bs,
                type: bs.type,
                value: bs.value
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bData);
        var size = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.data(new plutus_data_1.DataB(b));
    };
    BnCEK.prototype.unConstrData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("unConstrData :: not data; ".concat(data instanceof uplc_1.UPLCConst ? "UPLCConst type: " + (0, uplc_1.constTypeToStirng)(data.type) : ""), { data: data });
        if (!(d instanceof plutus_data_1.DataConstr))
            return new uplc_1.ErrorUPLC("unConstrData :: not a data constructor", {
                data: (0, plutus_data_1.dataToCbor)(d).toString()
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unConstrData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.pairOf(uplc_1.constT.int, uplc_1.constT.listOf(uplc_1.constT.data))(d.constr, d.fields);
    };
    BnCEK.prototype.unMapData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("unMapData :: not data", { data: data });
        if (!(d instanceof plutus_data_1.DataMap))
            return new uplc_1.ErrorUPLC("unMapData :: not a data map", { data: data });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unMapData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.listOf(uplc_1.constT.pairOf(uplc_1.constT.data, uplc_1.constT.data))(d.map.map(function (dataPair) { return new pair_1.Pair(dataPair.fst, dataPair.snd); }));
    };
    BnCEK.prototype.unListData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("unListData :: not data", { data: data });
        if (!(d instanceof plutus_data_1.DataList))
            return new uplc_1.ErrorUPLC("unListData :: not a data list", { data: d });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unListData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.listOf(uplc_1.constT.data)(d.list);
    };
    BnCEK.prototype.unIData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("unIData :: not data value", { data: data });
        if (!(d instanceof plutus_data_1.DataI))
            return new uplc_1.ErrorUPLC("unIData :: not a data integer", { data: d });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unIData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.int(d.int);
    };
    BnCEK.prototype.unBData = function (data) {
        var _c;
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("unBData :: not data value", { data: data });
        if (!(d instanceof plutus_data_1.DataB))
            return new uplc_1.ErrorUPLC("unBData :: not a data BS", {
                data: d,
                term: (_c = data === null || data === void 0 ? void 0 : data.value) === null || _c === void 0 ? void 0 : _c.constr
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unBData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return uplc_1.UPLCConst.byteString(d.bytes);
    };
    BnCEK.prototype.equalsData = function (a, b) {
        var _a = getData(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("equalsData :: not data; equalsData <first argument>", { a: a });
        var _b = getData(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("equalsData :: not data; equalsData <second argument>", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsData);
        var sa = dataToSize(_a);
        var sb = dataToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.bool((0, plutus_data_1.eqData)(_a, _b));
    };
    BnCEK.prototype.mkPairData = function (a, b) {
        var _a = getData(a);
        if (_a === undefined)
            return new uplc_1.ErrorUPLC("mkPairData :: not data; mkPairData <frist argument>", { a: a });
        var _b = getData(b);
        if (_b === undefined)
            return new uplc_1.ErrorUPLC("mkPairData :: not data; mkPairData <second argument>", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkPairData);
        var sa = dataToSize(_a);
        var sb = dataToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return uplc_1.UPLCConst.pairOf(uplc_1.constT.data, uplc_1.constT.data)(_a, _b);
    };
    BnCEK.prototype.mkNilData = function (unit) {
        if (!isConstOfType(unit, uplc_1.constT.unit))
            return new uplc_1.ErrorUPLC("mkNilData :: not unit", { unit: unit });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkNilData);
        this.machineBudget.add({
            mem: f.mem.at(ANY_SIZE),
            cpu: f.cpu.at(ANY_SIZE)
        });
        return uplc_1.UPLCConst.listOf(uplc_1.constT.data)([]);
    };
    BnCEK.prototype.mkNilPairData = function (unit) {
        if (!isConstOfType(unit, uplc_1.constT.unit))
            return new uplc_1.ErrorUPLC("mkNilPairData :: not unit", { unit: unit });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkNilPairData);
        this.machineBudget.add({
            mem: f.mem.at(ANY_SIZE),
            cpu: f.cpu.at(ANY_SIZE)
        });
        return uplc_1.UPLCConst.listOf(uplc_1.constT.pairOf(uplc_1.constT.data, uplc_1.constT.data))([]);
    };
    BnCEK.prototype.serialiseData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new uplc_1.ErrorUPLC("serialiseData :: not data input", { data: data });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.serialiseData);
        var sData = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(sData),
            cpu: f.cpu.at(sData)
        });
        return uplc_1.UPLCConst.byteString(new bytestring_1.ByteString((0, plutus_data_1.dataToCbor)(d).toBuffer()));
    };
    return BnCEK;
}());
exports.BnCEK = BnCEK;
