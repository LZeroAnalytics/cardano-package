"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRedeemerValidator = exports.makeValidator = void 0;
var utils_1 = require("../type_system/utils.js");
var perror_1 = require("../lib/perror.js");
var pmakeUnit_1 = require("../lib/std/unit/pmakeUnit.js");
var builtins_1 = require("../lib/builtins/index.js");
var papp_1 = require("../lib/papp.js");
var pfn_1 = require("../lib/pfn.js");
var types_1 = require("../type_system/types.js");
var type_system_1 = require("../type_system/index.js");
var fromData_1 = require("../lib/std/data/conversion/fromData.js");
function makeValidator(typedValidator, errorMessage) {
    return (0, pfn_1.pfn)([
        types_1.data,
        types_1.data,
        types_1.data
    ], types_1.unit)(function (rawDatum, rawRedeemer, rawCtx) {
        var vType = typedValidator.type;
        var err = function () { return new Error("cannot make a validator from a term of type " + (0, utils_1.termTypeToString)(vType)); };
        if (vType[0] !== "lam" /* PrimType.Lambda */)
            throw err();
        var datumType = vType[1];
        if (!(0, type_system_1.isWellFormedType)(datumType))
            throw err();
        var postDatum = vType[2];
        if (postDatum[0] !== "lam" /* PrimType.Lambda */)
            throw err();
        var redeemerType = postDatum[1];
        if (!(0, type_system_1.isWellFormedType)(redeemerType))
            throw err();
        var postRedeemer = postDatum[2];
        if (postRedeemer[0] !== "lam" /* PrimType.Lambda */)
            throw err();
        var ctxType = postRedeemer[1];
        if (!(0, type_system_1.isWellFormedType)(ctxType))
            throw err();
        var expectedBool = postRedeemer[2];
        if (!(0, type_system_1.typeExtends)(expectedBool, types_1.bool))
            throw err();
        var errorTerm = errorMessage === undefined ?
            (0, perror_1.perror)(types_1.unit) : (0, builtins_1.ptraceError)(types_1.unit, errorMessage).$(errorMessage);
        return (0, builtins_1.pif)(types_1.unit).$((0, papp_1.papp)((0, papp_1.papp)((0, papp_1.papp)(typedValidator, (0, fromData_1.fromData)(datumType)(rawDatum)), (0, fromData_1.fromData)(redeemerType)(rawRedeemer)), (0, fromData_1.fromData)(ctxType)(rawCtx)))
            .$((0, pmakeUnit_1.pmakeUnit)())
            .$(errorTerm);
    });
}
exports.makeValidator = makeValidator;
function makeRedeemerValidator(typedValidator, errorMessage) {
    return (0, pfn_1.pfn)([
        types_1.data,
        types_1.data
    ], types_1.unit)(function (rawRedeemer, rawCtx) {
        var vType = typedValidator.type;
        var err = function () { return new Error("cannot make a validator from a term of type " + (0, utils_1.termTypeToString)(vType)); };
        if (vType[0] !== "lam" /* PrimType.Lambda */)
            throw err();
        var redeemerType = vType[1];
        if (!(0, type_system_1.isWellFormedType)(redeemerType))
            throw err();
        var postRedeemer = vType[2];
        if (postRedeemer[0] !== "lam" /* PrimType.Lambda */)
            throw err();
        var ctxType = postRedeemer[1];
        if (!(0, type_system_1.isWellFormedType)(ctxType))
            throw err();
        var expectedBool = postRedeemer[2];
        if (!(0, type_system_1.typeExtends)(expectedBool, types_1.bool))
            throw err();
        var errorTerm = errorMessage === undefined ?
            (0, perror_1.perror)(types_1.unit) : (0, builtins_1.ptraceError)(types_1.unit, errorMessage).$(errorMessage);
        return (0, builtins_1.pif)(types_1.unit).$((0, papp_1.papp)((0, papp_1.papp)(typedValidator, (0, fromData_1.fromData)(redeemerType)(rawRedeemer)), (0, fromData_1.fromData)(ctxType)(rawCtx)))
            .$((0, pmakeUnit_1.pmakeUnit)())
            .$(errorTerm);
    });
}
exports.makeRedeemerValidator = makeRedeemerValidator;
