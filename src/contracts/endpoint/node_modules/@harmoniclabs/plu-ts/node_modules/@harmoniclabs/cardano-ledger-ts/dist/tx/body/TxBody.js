"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxBody = exports.isITxBody = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var crypto_1 = require("@harmoniclabs/crypto");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var credentials_1 = require("../../credentials/index.js");
var hashes_1 = require("../../hashes/index.js");
var ledger_1 = require("../../ledger/index.js");
var InvalidCborFormatError_1 = require("../../utils/InvalidCborFormatError.js");
var ints_1 = require("../../utils/ints.js");
var output_1 = require("./output/index.js");
var assert_1 = require("../../utils/assert.js");
function isITxBody(body) {
    if (!(0, obj_utils_1.isObject)(body))
        return false;
    var fields = Object.keys(body);
    var b = body;
    return (fields.length >= 3 &&
        (0, obj_utils_1.hasOwn)(b, "inputs") &&
        Array.isArray(b.inputs) && b.inputs.length > 0 &&
        b.inputs.every(function (_in) { return _in instanceof output_1.UTxO || (0, output_1.isIUTxO)(_in); }) &&
        (0, obj_utils_1.hasOwn)(b, "outputs") &&
        Array.isArray(b.outputs) && b.outputs.length > 0 &&
        b.outputs.every(function (out) { return out instanceof output_1.TxOut || (0, output_1.isITxOut)(out); }) &&
        (0, obj_utils_1.hasOwn)(b, "fee") && (0, ints_1.canBeUInteger)(b.fee) &&
        (b.ttl === undefined || (0, ints_1.canBeUInteger)(b.ttl)) &&
        (b.certs === undefined || b.certs.every(function (c) { return c instanceof ledger_1.Certificate; })) &&
        (b.withdrawals === undefined || (0, ledger_1.canBeTxWithdrawals)(b.withdrawals)) &&
        (b.protocolUpdate === undefined || (0, ledger_1.isProtocolUpdateProposal)(b.protocolUpdate)) &&
        (b.auxDataHash === undefined || b.auxDataHash instanceof hashes_1.Hash32) &&
        (b.validityIntervalStart === undefined || (0, ints_1.canBeUInteger)(b.validityIntervalStart)) &&
        (b.mint === undefined || b.mint instanceof ledger_1.Value) &&
        (b.scriptDataHash === undefined || b.scriptDataHash instanceof hashes_1.Hash32) &&
        (b.network === undefined || b.network === "mainnet" || b.network === "testnet") &&
        (b.collateralReturn === undefined || b.collateralReturn instanceof output_1.TxOut || (0, output_1.isITxOut)(b.collateralReturn)) &&
        (b.totCollateral === undefined || (0, ints_1.canBeUInteger)(b.totCollateral)) &&
        (b.collateralInputs === undefined || (Array.isArray(b.collateralInputs) &&
            b.collateralInputs.every(function (collateral) { return collateral instanceof output_1.UTxO; }))) &&
        (b.requiredSigners === undefined || (Array.isArray(b.requiredSigners) &&
            b.requiredSigners.every(function (sig) { return sig instanceof credentials_1.PubKeyHash; }))) &&
        (b.refInputs === undefined || (Array.isArray(b.refInputs) &&
            b.refInputs.every(function (ref) { return ref instanceof output_1.UTxO || (0, output_1.isIUTxO)(ref); }))));
}
exports.isITxBody = isITxBody;
var TxBody = /** @class */ (function () {
    /**
     *
     * @param body object describing the transaction
     * @throws only if the the `body` parameter does not respect the `ITxBody` interface
     *      **DOES NOT THROW** if the transaction is unbalanced; that needs to be checked using `TxBody.isValueConserved` static method
     */
    function TxBody(body) {
        var _this = this;
        (0, assert_1.assert)((0, obj_utils_1.hasOwn)(body, "inputs") &&
            (0, obj_utils_1.hasOwn)(body, "outputs") &&
            (0, obj_utils_1.hasOwn)(body, "fee"), "can't construct a 'TxBody' if 'inputs', 'outputs' and 'fee' fields aren't present");
        var inputs = body.inputs, outputs = body.outputs, fee = body.fee, ttl = body.ttl, certs = body.certs, withdrawals = body.withdrawals, protocolUpdate = body.protocolUpdate, auxDataHash = body.auxDataHash, validityIntervalStart = body.validityIntervalStart, mint = body.mint, scriptDataHash = body.scriptDataHash, collateralInputs = body.collateralInputs, requiredSigners = body.requiredSigners, network = body.network, collateralReturn = body.collateralReturn, totCollateral = body.totCollateral, refInputs = body.refInputs;
        var _isHashValid = false;
        var _hash;
        // -------------------------------------- inputs -------------------------------------- //
        (0, assert_1.assert)(Array.isArray(inputs) &&
            inputs.length > 0 &&
            inputs.every(function (input) { return input instanceof output_1.UTxO; }), "invald 'inputs' field");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "inputs", Object.freeze(inputs.map(function (i) { return i instanceof output_1.UTxO ? i : new output_1.UTxO(i); })));
        // -------------------------------------- outputs -------------------------------------- //
        (0, assert_1.assert)(Array.isArray(outputs) &&
            outputs.length > 0 &&
            outputs.every(function (out) { return out instanceof output_1.TxOut; }), "invald 'outputs' field");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "outputs", Object.freeze(outputs));
        // -------------------------------------- fee -------------------------------------- //
        (0, assert_1.assert)((typeof fee === "number" && fee === Math.round(Math.abs(fee))) ||
            (typeof fee === "bigint" && fee >= BigInt(0)), "invald 'fee' field");
        var _fee = (0, ints_1.forceBigUInt)(fee);
        (0, obj_utils_1.definePropertyIfNotPresent)(this, "fee", {
            get: function () { return _fee; },
            set: function () {
                var whatever = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    whatever[_i] = arguments[_i];
                }
            },
            enumerable: true,
            configurable: false
        });
        (0, obj_utils_1.defineReadOnlyProperty)(this, "ttl", ttl === undefined ? undefined : (0, ints_1.forceBigUInt)(ttl));
        // -------------------------------------- certs -------------------------------------- //
        if (certs !== undefined) {
            (0, assert_1.assert)(Array.isArray(certs) &&
                certs.every(function (cert) { return cert instanceof ledger_1.Certificate; }), "invalid 'certs' field");
            if (certs.length <= 0) {
                (0, obj_utils_1.defineReadOnlyProperty)(this, "certs", undefined);
            }
            (0, obj_utils_1.defineReadOnlyProperty)(this, "certs", Object.freeze(certs));
        }
        else
            (0, obj_utils_1.defineReadOnlyProperty)(this, "certs", undefined);
        // -------------------------------------- withdrawals -------------------------------------- //
        if (withdrawals !== undefined)
            (0, assert_1.assert)((0, ledger_1.canBeTxWithdrawals)(withdrawals), "withdrawals was not undefined nor an instance of 'TxWithdrawals'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "withdrawals", withdrawals === undefined ? undefined : (0, ledger_1.forceTxWithdrawals)(withdrawals));
        // -------------------------------------- protocolUpdate -------------------------------------- //
        if (protocolUpdate !== undefined) {
            (0, assert_1.assert)((0, ledger_1.isProtocolUpdateProposal)(protocolUpdate), "invalid 'protocolUpdate' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "protocolUpdate", protocolUpdate);
        // -------------------------------------- auxDataHash -------------------------------------- //
        if (auxDataHash !== undefined) {
            (0, assert_1.assert)(auxDataHash instanceof hashes_1.Hash32, "invalid 'auxDataHash' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "auxDataHash", auxDataHash === undefined ? undefined : new hashes_1.AuxiliaryDataHash(auxDataHash));
        // -------------------------------------- validityIntervalStart -------------------------------------- //
        if (validityIntervalStart !== undefined) {
            (0, assert_1.assert)((0, ints_1.canBeUInteger)(validityIntervalStart), "invalid 'validityIntervalStart' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "validityIntervalStart", validityIntervalStart === undefined ? undefined : (0, ints_1.forceBigUInt)(validityIntervalStart));
        // -------------------------------------- mint -------------------------------------- //
        if (mint !== undefined) {
            (0, assert_1.assert)(mint instanceof ledger_1.Value, "invalid 'mint' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "mint", mint);
        // -------------------------------------- scriptDataHash -------------------------------------- //
        if (scriptDataHash !== undefined) {
            (0, assert_1.assert)(scriptDataHash instanceof hashes_1.Hash32, "invalid 'scriptDataHash' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "scriptDataHash", scriptDataHash === undefined ? undefined : new hashes_1.ScriptDataHash(scriptDataHash));
        // -------------------------------------- collateral inputs -------------------------------------- //
        if (collateralInputs !== undefined) {
            (0, assert_1.assert)(Array.isArray(collateralInputs) &&
                collateralInputs.every(function (input) { return input instanceof output_1.UTxO; }), "invalid 'collateralInputs' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "collateralInputs", (collateralInputs === null || collateralInputs === void 0 ? void 0 : collateralInputs.length) === 0 ? undefined : Object.freeze(collateralInputs));
        // -------------------------------------- requiredSigners -------------------------------------- //
        requiredSigners;
        if (requiredSigners !== undefined) {
            (0, assert_1.assert)(Array.isArray(requiredSigners) &&
                requiredSigners.every(function (sig) { return sig instanceof credentials_1.PubKeyHash; }), "invalid 'requiredSigners' while constructing a 'Tx'");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "requiredSigners", (requiredSigners === null || requiredSigners === void 0 ? void 0 : requiredSigners.length) === 0 ? undefined : Object.freeze(requiredSigners));
        // -------------------------------------- network -------------------------------------- //
        if (network !== undefined)
            (0, assert_1.assert)(network === "mainnet" ||
                network === "testnet", "invalid 'network' while constructing 'Tx'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "network", network);
        // -------------------------------------- collateralReturn -------------------------------------- //
        if (collateralReturn !== undefined)
            (0, assert_1.assert)(collateralReturn instanceof output_1.TxOut, "invalid 'collateralReturn' while constructing 'Tx'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "collateralReturn", collateralReturn);
        // -------------------------------------- totCollateral -------------------------------------- //
        if (totCollateral !== undefined)
            (0, assert_1.assert)((0, ints_1.canBeUInteger)(totCollateral), "invalid 'collateralReturn' while constructing 'Tx'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "collateralReturn", totCollateral === undefined ? undefined : (0, ints_1.forceBigUInt)(totCollateral));
        // -------------------------------------- reference inputs -------------------------------------- //  
        if (refInputs !== undefined)
            (0, assert_1.assert)(Array.isArray(refInputs) &&
                refInputs.every(function (input) { return input instanceof output_1.UTxO; }), "invalid 'refInputs' while constructing a 'Tx'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "refInputs", (refInputs === null || refInputs === void 0 ? void 0 : refInputs.length) === 0 ? undefined : Object.freeze(refInputs));
        // -------------------------------------- hash -------------------------------------- //  
        (0, obj_utils_1.definePropertyIfNotPresent)(this, "hash", {
            get: function () {
                if (_isHashValid === true && _hash !== undefined && _hash instanceof hashes_1.Hash32)
                    return _hash.clone();
                _hash = new hashes_1.Hash32(new Uint8Array((0, crypto_1.blake2b_256)(_this.toCbor().toBuffer())));
                _isHashValid = true;
                return _hash.clone();
            },
            set: function () { },
            enumerable: true,
            configurable: false
        });
    }
    TxBody.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    TxBody.prototype.toCborObj = function () {
        return new cbor_1.CborMap([
            {
                k: new cbor_1.CborUInt(0),
                v: new cbor_1.CborArray(this.inputs.map(function (input) { return input.utxoRef.toCborObj(); }))
            },
            {
                k: new cbor_1.CborUInt(1),
                v: new cbor_1.CborArray(this.outputs.map(function (out) { return out.toCborObj(); }))
            },
            {
                k: new cbor_1.CborUInt(2),
                v: new cbor_1.CborUInt(this.fee)
            },
            this.ttl === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(3),
                    v: new cbor_1.CborUInt(this.ttl)
                },
            this.certs === undefined || this.certs.length === 0 ? undefined :
                {
                    k: new cbor_1.CborUInt(4),
                    v: new cbor_1.CborArray(this.certs.map(function (cert) { return cert.toCborObj(); }))
                },
            this.withdrawals === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(5),
                    v: this.withdrawals.toCborObj()
                },
            this.protocolUpdate === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(6),
                    v: (0, ledger_1.protocolUpdateProposalToCborObj)(this.protocolUpdate)
                },
            this.auxDataHash === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(7),
                    v: this.auxDataHash.toCborObj()
                },
            this.validityIntervalStart === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(8),
                    v: new cbor_1.CborUInt(this.validityIntervalStart)
                },
            this.mint === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(9),
                    v: this.mint.toCborObj()
                },
            this.scriptDataHash === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(11),
                    v: this.scriptDataHash.toCborObj()
                },
            this.collateralInputs === undefined || this.collateralInputs.length === 0 ? undefined :
                {
                    k: new cbor_1.CborUInt(13),
                    v: new cbor_1.CborArray(this.collateralInputs.map(function (collateral) { return collateral.utxoRef.toCborObj(); }))
                },
            this.requiredSigners === undefined || this.requiredSigners.length === 0 ? undefined :
                {
                    k: new cbor_1.CborUInt(14),
                    v: new cbor_1.CborArray(this.requiredSigners.map(function (signer) { return signer.toCborObj(); }))
                },
            this.network === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(15),
                    v: new cbor_1.CborUInt(this.network === "testnet" ? 0 : 1)
                },
            this.collateralReturn === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(16),
                    v: this.collateralReturn.toCborObj()
                },
            this.totCollateral === undefined ? undefined :
                {
                    k: new cbor_1.CborUInt(17),
                    v: new cbor_1.CborUInt(this.totCollateral)
                },
            this.refInputs === undefined || this.refInputs.length === 0 ? undefined :
                {
                    k: new cbor_1.CborUInt(18),
                    v: new cbor_1.CborArray(this.refInputs.map(function (refIn) { return refIn.utxoRef.toCborObj(); }))
                }
        ].filter(function (entry) { return entry !== undefined; }));
    };
    TxBody.fromCbor = function (cStr) {
        return TxBody.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr)));
    };
    TxBody.fromCborObj = function (cObj) {
        var _a;
        if (!(cObj instanceof cbor_1.CborMap))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxBody");
        var fields = new Array(19).fill(undefined);
        var _loop_1 = function (i) {
            var v = ((_a = cObj.map.find(function (_a) {
                var k = _a.k;
                return k instanceof cbor_1.CborUInt && Number(k.num) === i;
            })) !== null && _a !== void 0 ? _a : { v: undefined }).v;
            if (v === undefined)
                return "continue";
            fields[i] = v;
        };
        for (var i = 0; i < 19; i++) {
            _loop_1(i);
        }
        var _b = __read(fields, 19), _ins = _b[0], _outs = _b[1], _fee = _b[2], _ttl = _b[3], _certs = _b[4], _withdrawals = _b[5], _pUp = _b[6], _auxDataHash = _b[7], _validityStart = _b[8], _mint = _b[9], _10 = _b[10], _scriptDataHash = _b[11], _12 = _b[12], _collIns = _b[13], _reqSigs = _b[14], _net = _b[15], _collRet = _b[16], _totColl = _b[17], _refIns = _b[18];
        if (_ins === undefined || _outs === undefined || _fee === undefined)
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxBody");
        if (!(_ins instanceof cbor_1.CborArray &&
            _outs instanceof cbor_1.CborArray &&
            _fee instanceof cbor_1.CborUInt))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxBody");
        var ttl = undefined;
        if (_ttl !== undefined) {
            if (!(_ttl instanceof cbor_1.CborUInt))
                throw new InvalidCborFormatError_1.InvalidCborFormatError("TxBody");
            ttl = _ttl.num;
        }
        return new TxBody({
            inputs: _ins.array.map(txOutRefAsUTxOFromCborObj),
            outputs: _outs.array.map(output_1.TxOut.fromCborObj),
            fee: _fee.num,
            ttl: ttl,
            certs: _certs instanceof cbor_1.CborArray ? _certs.array.map(ledger_1.Certificate.fromCborObj) : undefined,
            withdrawals: _withdrawals === undefined ? undefined : ledger_1.TxWithdrawals.fromCborObj(_withdrawals),
            protocolUpdate: _pUp === undefined ? undefined : (0, ledger_1.protocolUpdateProposalFromCborObj)(_pUp),
            auxDataHash: _auxDataHash === undefined ? undefined : hashes_1.AuxiliaryDataHash.fromCborObj(_auxDataHash),
            validityIntervalStart: _validityStart instanceof cbor_1.CborUInt ? _validityStart.num : undefined,
            mint: _mint === undefined ? undefined : ledger_1.Value.fromCborObj(_mint),
            scriptDataHash: _scriptDataHash === undefined ? undefined : hashes_1.ScriptDataHash.fromCborObj(_scriptDataHash),
            collateralInputs: _collIns instanceof cbor_1.CborArray ? _collIns.array.map(txOutRefAsUTxOFromCborObj) : undefined,
            requiredSigners: _reqSigs instanceof cbor_1.CborArray ? _reqSigs.array.map(credentials_1.PubKeyHash.fromCborObj) : undefined,
            network: _net instanceof cbor_1.CborUInt ? (Number(_net.num) === 0 ? "testnet" : "mainnet") : undefined,
            collateralReturn: _collRet === undefined ? undefined : output_1.TxOut.fromCborObj(_collRet),
            totCollateral: _totColl instanceof cbor_1.CborUInt ? _totColl.num : undefined,
            refInputs: _refIns instanceof cbor_1.CborArray ? _refIns.array.map(txOutRefAsUTxOFromCborObj) : undefined
        });
    };
    TxBody.prototype.toJson = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        return {
            inputs: this.inputs.map(function (i) { return i.toJson(); }),
            outputs: this.outputs.map(function (o) { return o.toJson(); }),
            fee: this.fee.toString(),
            ttl: (_a = this.ttl) === null || _a === void 0 ? void 0 : _a.toString(),
            certs: (_b = this.certs) === null || _b === void 0 ? void 0 : _b.map(function (c) { return c.toJson(); }),
            withdrawals: (_c = this.withdrawals) === null || _c === void 0 ? void 0 : _c.toJson(),
            protocolUpdate: this.protocolUpdate === undefined ? undefined :
                (0, ledger_1.protocolUpdateToJson)(this.protocolUpdate),
            auxDataHash: (_d = this.auxDataHash) === null || _d === void 0 ? void 0 : _d.asString,
            validityIntervalStart: (_e = this.validityIntervalStart) === null || _e === void 0 ? void 0 : _e.toString(),
            mint: (_f = this.mint) === null || _f === void 0 ? void 0 : _f.toJson(),
            scriptDataHash: (_g = this.scriptDataHash) === null || _g === void 0 ? void 0 : _g.asString,
            collateralInputs: (_h = this.collateralInputs) === null || _h === void 0 ? void 0 : _h.map(function (i) { return i.toJson(); }),
            requiredSigners: (_j = this.requiredSigners) === null || _j === void 0 ? void 0 : _j.map(function (sig) { return sig.asString; }),
            network: this.network,
            collateralReturn: (_k = this.collateralReturn) === null || _k === void 0 ? void 0 : _k.toJson(),
            totCollateral: (_l = this.totCollateral) === null || _l === void 0 ? void 0 : _l.toString(),
            refInputs: (_m = this.refInputs) === null || _m === void 0 ? void 0 : _m.map(function (i) { return i.toJson(); })
        };
    };
    /**
     * tests that
     * inputs + withdrawals + refund + mints === outputs + burns + deposit + fee
     *
     * @todo add mints and burns
     * @deprecated until mints and burns are added
     */
    TxBody.isValueConserved = function (tx) {
        var inputs = tx.inputs, withdrawals = tx.withdrawals, outputs = tx.outputs, certs = tx.certs, fee = tx.fee;
        // withdrawals
        var tot = withdrawals === undefined ? ledger_1.Value.zero : withdrawals.toTotalWitdrawn();
        // + inputs
        tot = inputs.reduce(function (a, b) { return ledger_1.Value.add(a, b.resolved.value); }, tot);
        // - (outputs + fee)
        // - outputs - fee
        tot = ledger_1.Value.sub(tot, outputs.reduce(function (a, b) { return ledger_1.Value.add(a, b.value); }, ledger_1.Value.lovelaces(fee)));
        return ledger_1.Value.isZero(certs === undefined ?
            tot :
            ledger_1.Value.add(tot, ledger_1.Value.lovelaces((0, ledger_1.certificatesToDepositLovelaces)(certs))));
    };
    return TxBody;
}());
exports.TxBody = TxBody;
;
function txOutRefAsUTxOFromCborObj(cObj) {
    return new output_1.UTxO({
        utxoRef: output_1.TxOutRef.fromCborObj(cObj),
        resolved: output_1.TxOut.fake
    });
}
