"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MoveInstantRewardsCert = exports.rewardSourceToStr = exports.InstantRewardsSource = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var credentials_1 = require("../../credentials/index.js");
var ints_1 = require("../../utils/ints.js");
var assert_1 = require("../../utils/assert.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var InstantRewardsSource;
(function (InstantRewardsSource) {
    InstantRewardsSource[InstantRewardsSource["Reserves"] = 0] = "Reserves";
    InstantRewardsSource[InstantRewardsSource["Treasurery"] = 1] = "Treasurery";
})(InstantRewardsSource = exports.InstantRewardsSource || (exports.InstantRewardsSource = {}));
Object.freeze(InstantRewardsSource);
function rewardSourceToStr(source) {
    switch (source) {
        case InstantRewardsSource.Reserves: return "Reserves";
        case InstantRewardsSource.Treasurery: return "Treasurery";
        default:
            throw new Error("unknown instant rewards source");
    }
}
exports.rewardSourceToStr = rewardSourceToStr;
function rewardsMapToCborObj(map) {
    return new cbor_1.CborMap(map.map(function (entry) {
        var amt = entry.amount;
        return {
            k: entry.stakeCredentials.toCborObj(),
            v: amt < 0 ? new cbor_1.CborNegInt(amt) : new cbor_1.CborUInt(amt)
        };
    }));
}
function rewardsMapFromCborObj(cObj) {
    if (!(cObj instanceof cbor_1.CborMap))
        throw new Error("Invalid CBOR fromat for \"MoveInstantRewardsCert\"");
    var map = cObj.map;
    var len = map.length;
    var rewMap = new Array(len);
    for (var i = 0; i < len; i++) {
        var _a = map[i], k = _a.k, v = _a.v;
        if (!(v instanceof cbor_1.CborUInt ||
            v instanceof cbor_1.CborNegInt))
            throw new Error("Invalid CBOR fromat for \"MoveInstantRewardsCert\"");
        rewMap[i] = {
            stakeCredentials: credentials_1.StakeCredentials.fromCborObj(k),
            amount: v.num
        };
    }
    return rewMap;
}
var MoveInstantRewardsCert = /** @class */ (function () {
    function MoveInstantRewardsCert(source, destintaion) {
        (0, assert_1.assert)(source === InstantRewardsSource.Reserves ||
            source === InstantRewardsSource.Treasurery, "invalid 'source' while constructing 'MoveInstantRewardsCert'");
        (0, assert_1.assert)((0, ints_1.canBeUInteger)(destintaion) ||
            (Array.isArray(destintaion) &&
                destintaion.every(function (entry) { return ((0, obj_utils_1.hasOwn)(entry, "amount") &&
                    (0, obj_utils_1.hasOwn)(entry, "stakeCredentials") &&
                    ((typeof (entry.amount) === "number" && entry.amount === Math.round(entry.amount)) ||
                        (typeof (entry.amount) === "bigint")) &&
                    entry.stakeCredentials instanceof credentials_1.StakeCredentials); })), "invalid 'destintaiton' while constructing 'MoveInstantRewardsCert'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "source", source);
        (0, obj_utils_1.defineReadOnlyProperty)(this, "destintaion", destintaion);
    }
    MoveInstantRewardsCert.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    MoveInstantRewardsCert.prototype.toCborObj = function () {
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.source),
            (0, ints_1.canBeUInteger)(this.destintaion) ?
                new cbor_1.CborUInt((0, ints_1.forceBigUInt)(this.destintaion)) :
                rewardsMapToCborObj(this.destintaion)
        ]);
    };
    MoveInstantRewardsCert.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray))
            throw new Error("Invalid CBOR fromat for \"MoveInstantRewardsCert\"");
        var _a = __read(cObj.array, 2), _src = _a[0], _dst = _a[1];
        if (!(_src instanceof cbor_1.CborUInt))
            throw new Error("Invalid CBOR fromat for \"MoveInstantRewardsCert\"");
        return new MoveInstantRewardsCert(Number(_src.num), _dst instanceof cbor_1.CborUInt ?
            _dst.num :
            rewardsMapFromCborObj(_dst));
    };
    MoveInstantRewardsCert.prototype.toJson = function () {
        return {
            source: rewardSourceToStr(this.source),
            destination: (0, ints_1.canBeUInteger)(this.destintaion) ?
                (0, ints_1.forceBigUInt)(this.destintaion).toString() :
                this.destintaion.map(function (_a) {
                    var stakeCredentials = _a.stakeCredentials, amount = _a.amount;
                    return ({
                        stakeCreds: stakeCredentials.toJson(),
                        amount: (0, ints_1.forceBigUInt)(amount).toString()
                    });
                })
        };
    };
    return MoveInstantRewardsCert;
}());
exports.MoveInstantRewardsCert = MoveInstantRewardsCert;
