import { PType } from "../PType/index.js";
import { PLam } from "../PTypes/index.js";
import { Term } from "../Term/index.js";
import { type UtilityTermOf } from "./std/UtilityTerms/addUtilityForType.js";
import { PappArg } from "./pappArg.js";
export type PappResult<Output extends PType> = Output extends PLam<infer OutIn extends PType, infer OutOut extends PType> ? Term<PLam<OutIn, OutOut>> & {
    $: (someInput: PappArg<OutIn>) => PappResult<OutOut>;
} : UtilityTermOf<Output>;
/**
 *
 * @param {Term<PLam<Input, Output>>} a Term that evalueates to an UPLC function ( type: ```Type.Lambda( inputT, outputT )``` )
 * @param {Term<Input>} b the argument of to provide to the first parameter
 * @returns {Term<Output>} the result of the calculation
 *
 * if the type of the output extends the type ```Type.Lambda( Type.Any, Type.Any )```
 */
export declare function papp<Input extends PType, Output extends PType>(a: Term<PLam<Input, Output>>, b: PappArg<Input>): UtilityTermOf<Output>;
