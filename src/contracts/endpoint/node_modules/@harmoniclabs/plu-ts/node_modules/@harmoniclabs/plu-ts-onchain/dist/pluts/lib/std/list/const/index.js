"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pDataList = exports.pList = exports.pconstList = exports.pnil = exports.assertValidListType = void 0;
var plutus_machine_1 = require("@harmoniclabs/plutus-machine");
var IRConst_1 = require("../../../../../IR/IRNodes/IRConst.js");
var assert_1 = require("../../../../../utils/assert.js");
var Term_1 = require("../../../../Term/index.js");
var type_system_1 = require("../../../../type_system/index.js");
var typeExtends_1 = require("../../../../type_system/typeExtends.js");
var types_1 = require("../../../../type_system/types.js");
var data_1 = require("../../../builtins/data/index.js");
var pprepend_1 = require("../../../builtins/pprepend/index.js");
var punsafeConvertType_1 = require("../../../punsafeConvertType/index.js");
var UtilityTerms_1 = require("../../UtilityTerms/index.js");
var minimal_common_1 = require("../../data/conversion/minimal_common.js");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var uplc_1 = require("@harmoniclabs/uplc");
function assertValidListType(elemsT) {
    (0, assert_1.assert)((0, type_system_1.isWellFormedType)(elemsT) &&
        !((elemsT[0] === "lam" /* PrimType.Lambda */) ||
            (elemsT[0] === "delayed" /* PrimType.Delayed */)), "plutus only supports lists of types that can be converted to constants");
}
exports.assertValidListType = assertValidListType;
function pnil(elemsT) {
    assertValidListType(elemsT);
    if ((0, typeExtends_1.typeExtends)(elemsT, (0, types_1.pair)((0, types_1.tyVar)(), (0, types_1.tyVar)()))) {
        return (0, punsafeConvertType_1.punsafeConvertType)(data_1.pnilPairData, (0, types_1.list)(elemsT));
    }
    if ((0, typeExtends_1.typeExtends)(elemsT, types_1.data)) {
        return (0, punsafeConvertType_1.punsafeConvertType)(data_1.pnilData, (0, types_1.list)(elemsT));
    }
    return (0, UtilityTerms_1.addPListMethods)(new Term_1.Term((0, types_1.list)(elemsT), function (_dbn) { return IRConst_1.IRConst.listOf(elemsT)([]); }, true));
}
exports.pnil = pnil;
function pconstList(elemsT) {
    assertValidListType(elemsT);
    return function (elems) {
        (0, assert_1.assert)(Array.isArray(elems) && elems.every(function (el) {
            return el instanceof Term_1.Term &&
                el.isConstant &&
                (0, typeExtends_1.typeExtends)(el.type, elemsT);
        }), "invalid array of elements to construct a list with");
        if (elems.length === 0)
            return pnil(elemsT);
        return (0, UtilityTerms_1.addPListMethods)(new Term_1.Term((0, types_1.list)(elemsT), function (dbn) {
            return IRConst_1.IRConst.listOf(elemsT)(elems.map(function (el) {
                var res = (plutus_machine_1.Machine.evalSimple(el.toUPLC(dbn)));
                if (!(res instanceof uplc_1.UPLCConst)) {
                    console.log("------------------- pconstList -------------------");
                    console.log(res);
                    console.log((0, uplc_1.showUPLC)(el.toUPLC(dbn)));
                    throw res;
                }
                return res.value;
            }));
        }, true));
    };
}
exports.pconstList = pconstList;
function pList(elemsT) {
    return function (elems) {
        (0, assert_1.assert)(Array.isArray(elems) && elems.every(function (el) {
            return el instanceof Term_1.Term &&
                (0, typeExtends_1.typeExtends)(el.type, elemsT);
        }), "invalid array of elements to construct a list with");
        var nConstantFromEnd = 0;
        for (var i = elems.length - 1; i >= 0; i--) {
            if (elems[i].isConstant)
                nConstantFromEnd++;
            else
                break;
        }
        /**
         * if nConstantFromEnd === 0
         *
         * ```ts
         * elems.slice( elems.length - nConstantFromEnd )
         * ```
         *
         * evalueates to ```[]```
         *
         * which makes calling
         *
         * ```ts
         * pconstList( elemsT )([])
         * ```
         *
         * equivalent to
         *
         * ```ts
         * pnil( elemsT )
         * ```
         */
        var plist = pconstList(elemsT)(elems.slice(elems.length - nConstantFromEnd));
        // all the elements where constants
        if (nConstantFromEnd === elems.length)
            return plist;
        for (var i = elems.length - nConstantFromEnd - 1; i >= 0; i--) {
            plist =
                (0, minimal_common_1._papp)((0, minimal_common_1._papp)((0, pprepend_1.pprepend)(elemsT), elems[i]), plist);
        }
        return (0, UtilityTerms_1.addPListMethods)(plist);
    };
}
exports.pList = pList;
function pDataList(datas) {
    (0, assert_1.assert)(Array.isArray(datas) && datas.every(plutus_data_1.isData), "invalid list of data passed to 'pDataList'");
    return new Term_1.Term((0, types_1.list)(types_1.data), function (_dbn) { return IRConst_1.IRConst.listOf(types_1.data)(datas); }, true);
}
exports.pDataList = pDataList;
