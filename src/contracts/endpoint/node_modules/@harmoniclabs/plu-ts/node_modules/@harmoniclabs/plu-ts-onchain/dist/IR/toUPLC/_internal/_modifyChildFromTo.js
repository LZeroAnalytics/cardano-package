"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._modifyChildFromTo = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var IRApp_1 = require("../../IRNodes/IRApp.js");
var IRDelayed_1 = require("../../IRNodes/IRDelayed.js");
var IRForced_1 = require("../../IRNodes/IRForced.js");
var IRFunc_1 = require("../../IRNodes/IRFunc.js");
var IRHoisted_1 = require("../../IRNodes/IRHoisted.js");
var IRLetted_1 = require("../../IRNodes/IRLetted.js");
var plu_ts_onchain_1 = require("@harmoniclabs/plu-ts-onchain");
var utils_1 = require("../../utils/index.js");
/**
 *
 * @param parent node to modify the child of
 * @param currentChild mainly passed to distinguish in case of `IRApp`
 * @param newChild new node's child
 */
function _modifyChildFromTo(parent, currentChild, newChild) {
    if (parent === undefined) {
        throw new Error("'_modifyChildFromTo' received an undefined parent");
    }
    if (
    // currentChild has parent property
    (0, plu_ts_onchain_1.isIRTerm)(currentChild) &&
        // and is not (already) undefined
        currentChild.parent !== undefined &&
        // and the `parent` passed to the function is the parent of the `currentChild`
        currentChild.parent === parent &&
        // and child to be modified is not the same object
        currentChild !== newChild) {
        // we are modifying the child
        // so we remove the reference
        currentChild.parent = undefined;
    }
    if (parent instanceof IRApp_1.IRApp) {
        // DO NO USE **ONLY** SHALLOW EQUALITY
        // child might be cloned
        var currChildHash = currentChild instanceof Uint8Array ? currentChild : currentChild.hash;
        // check the argument first as it is more likely to have a smaller tree
        if (currentChild === parent.arg || (0, uint8array_utils_1.uint8ArrayEq)(parent.arg.hash, currChildHash)) {
            parent.arg = newChild;
        }
        else if (currentChild === parent.fn || (0, uint8array_utils_1.uint8ArrayEq)(parent.fn.hash, currChildHash)) {
            parent.fn = newChild;
        }
        else {
            console.log("currentChild:", (0, utils_1.prettyIRJsonStr)(currentChild, 2, { hoisted: false }), "\nfn :", (0, utils_1.prettyIRJsonStr)(parent.fn, 2, { hoisted: false }), "\narg:", (0, utils_1.prettyIRJsonStr)(parent.arg, 2, { hoisted: false }));
            throw new Error("unknown 'IRApp' child to modify; given child to modify hash: " +
                (0, uint8array_utils_1.toHex)(currChildHash) +
                "; function child hash: " + (0, uint8array_utils_1.toHex)(parent.fn.hash) +
                "; argument child hash: " + (0, uint8array_utils_1.toHex)(parent.arg.hash));
        }
        return;
    }
    if (parent instanceof IRDelayed_1.IRDelayed) {
        parent.delayed = newChild;
        return;
    }
    if (parent instanceof IRForced_1.IRForced) {
        parent.forced = newChild;
        return;
    }
    if (parent instanceof IRFunc_1.IRFunc) {
        parent.body = newChild;
        return;
    }
    if (parent instanceof IRHoisted_1.IRHoisted) {
        parent.hoisted = newChild;
        return;
    }
    if (parent instanceof IRLetted_1.IRLetted) {
        parent.value = newChild;
        return;
    }
}
exports._modifyChildFromTo = _modifyChildFromTo;
