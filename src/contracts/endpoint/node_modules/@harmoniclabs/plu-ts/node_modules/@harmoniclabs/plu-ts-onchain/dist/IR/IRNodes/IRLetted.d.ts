import { IRMetadata } from "../interfaces/IRMetadata.js";
import { Cloneable } from "@harmoniclabs/cbor/dist/utils/Cloneable";
import { ToJson } from "../../utils/ToJson.js";
import { IRTerm } from "../IRTerm.js";
import { IHash, IIRParent } from "../interfaces/index.js";
import { IRParentTerm } from "../utils/isIRParentTerm.js";
import { BaseIRMetadata } from "./BaseIRMetadata.js";
export type LettedSetEntry = {
    letted: IRLetted;
    nReferences: number;
};
export declare function jsonLettedSetEntry(entry: LettedSetEntry): {
    letted: string;
    nReferences: number;
};
export declare function expandedJsonLettedSetEntry(entry: LettedSetEntry): {
    letted: string;
    letted_value: string[];
    nReferences: number;
};
export interface IRLettedMeta extends BaseIRMetadata {
    /**
     * force hoisting even if only a single reference is found
     *
     * useful to hoist letted terms used once in recursive expressions
    **/
    forceHoist: boolean;
    __src__?: string | undefined;
}
export interface IRLettedMetadata extends IRMetadata {
    meta: IRLettedMeta;
}
export declare class IRLetted implements Cloneable<IRLetted>, IHash, IIRParent, ToJson, IRLettedMetadata {
    readonly hash: Uint8Array;
    markHashAsInvalid: () => void;
    value: IRTerm;
    /**
     * we need to keep track of the debruijn at which the `IRLetted` is instantiated
     *
     * this is because stuff like `new IRLetted( new IRVar(0) )` has different meaning
     * at different DeBruijn levels
     *
     * knowing the DeBruijn we can differentiate them
     */
    dbn: number;
    isClosedAtDbn: (dbn: number) => boolean;
    readonly dependencies: LettedSetEntry[];
    parent: IRParentTerm | undefined;
    clone: () => IRLetted;
    readonly meta: IRLettedMeta;
    constructor(DeBruijn: number | bigint, toLet: IRTerm, metadata?: Partial<IRLettedMeta>, unsafe_hash?: Uint8Array | undefined);
    static get tag(): Uint8Array;
    toJson(): any;
}
/**
 * basically an insertion sort;
 *
 * @param {LettedSetEntry[]} lettedTerms
 * @returns {LettedSetEntry[]} a **new** array with ```IRLetted```s with no dependencies first, followed by the dependents
 */
export declare function getSortedLettedSet(lettedTerms: LettedSetEntry[]): LettedSetEntry[];
export interface GetLettedTermsOptions {
    /**
     * looks for letted terms inside other letted terms
     *
     * (unnecessary if called only to later pass the result to `getSortedLettedSet`)
     */
    all: boolean;
    /**
     * look for letted terms inside hoisted terms (always closed)
     */
    includeHoisted: boolean;
}
export declare const default_getLettedTermsOptions: GetLettedTermsOptions;
/**
 *
 * @param {IRTerm} irTerm term to search in
 * @returns direct letted terms (no possible dependencies)
 */
export declare function getLettedTerms(irTerm: IRTerm, options?: Partial<GetLettedTermsOptions>): LettedSetEntry[];
export declare function getNormalizedLettedArgs(lettedDbn: number, value: IRTerm): [normalized_dbn: number, noramlized_value: IRTerm] | undefined;
/**
 *
 * @param term the ir term to iter to search for vars
 * @returns {number | undefined}
 *
 * @example
 * ```ts
 * let minDbn = getMinVarDbn( new IRVar(0) ); // 0
 * minDbn = getMinVarDbn( IRConst.unit ); // undefined
 * minDbn = getMinVarDbn( new IRFunc( 1, new IRVar( 0 ) ) ); // 0
 * ```
 */
export declare function getMinVarDbn(term: IRTerm): number | undefined;
