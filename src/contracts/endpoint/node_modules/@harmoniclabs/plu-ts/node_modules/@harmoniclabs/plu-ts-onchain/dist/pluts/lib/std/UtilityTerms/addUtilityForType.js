"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPAliasMethods = exports.addUtilityForType = void 0;
var isTaggedAsAlias_1 = require("../../../type_system/kinds/isTaggedAsAlias.js");
var isWellFormedType_1 = require("../../../type_system/kinds/isWellFormedType.js");
var typeExtends_1 = require("../../../type_system/typeExtends.js");
var types_1 = require("../../../type_system/types.js");
var unwrapAlias_1 = require("../../../type_system/tyArgs/unwrapAlias.js");
var papp_1 = require("../../papp.js");
var _1 = require("./index.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var utils_1 = require("../../../type_system/utils.js");
var addUserMethods_1 = require("./userMethods/addUserMethods.js");
function addUtilityForType(t) {
    if ((0, isTaggedAsAlias_1.isTaggedAsAlias)(t)) {
        return addPAliasMethods;
        // return addUtilityForType( unwrapAlias( t ) ) as any;
    }
    ;
    if ((0, typeExtends_1.typeExtends)(t, types_1.bool))
        return _1.addPBoolMethods;
    if ((0, typeExtends_1.typeExtends)(t, types_1.bs))
        return _1.addPByteStringMethods;
    if ((0, typeExtends_1.typeExtends)(t, types_1.int))
        return _1.addPIntMethods;
    if ((0, typeExtends_1.typeExtends)(t, (0, types_1.list)((0, types_1.tyVar)())))
        return _1.addPListMethods;
    if ((0, typeExtends_1.typeExtends)(t, (0, types_1.pair)((0, types_1.tyVar)(), (0, types_1.tyVar)())))
        return _1.addPPairMethods;
    if ((0, typeExtends_1.typeExtends)(t, types_1.str))
        return _1.addPStringMethods;
    if ((0, typeExtends_1.typeExtends)(t, (0, types_1.lam)((0, types_1.tyVar)(), (0, types_1.tyVar)()))) {
        return (function (term) { return (0, obj_utils_1.defineNonDeletableNormalProperty)(term, "$", function (input) {
            return (0, papp_1.papp)(term, input);
        }); });
    }
    if ((0, isWellFormedType_1.isStructType)(t)) {
        return _1.addPStructMethods;
    }
    // no utility
    return (function (x) { return x; });
}
exports.addUtilityForType = addUtilityForType;
// `addPAliasMethod` is (necessarily) mutually recursive with `addUtilityForType`
// so it is defined in this file instead of "./UtilityTerms/TermAlias.ts"
function addPAliasMethods(aliasTerm) {
    var originalType = aliasTerm.type;
    if (originalType[0] !== "alias" /* PrimType.Alias */) {
        console.error(originalType);
        try {
            console.error((0, utils_1.termTypeToString)(originalType));
        }
        catch (_a) { }
        throw new Error("addPAliasMethods used on non-alias type");
    }
    var aliasedType = (0, unwrapAlias_1.unwrapAlias)(originalType);
    aliasTerm = addUtilityForType(aliasedType)(aliasTerm);
    aliasTerm = (0, addUserMethods_1.addUserMethods)(aliasTerm, originalType[2]);
    return aliasTerm;
}
exports.addPAliasMethods = addPAliasMethods;
