"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxOutRef = exports.ITxOutRefToStr = exports.isITxOutRef = void 0;
var bytestring_1 = require("@harmoniclabs/bytestring");
var cbor_1 = require("@harmoniclabs/cbor");
var ints_1 = require("@harmoniclabs/cbor/dist/utils/ints");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var hashes_1 = require("../../../hashes/index.js");
var BasePlutsError_1 = require("../../../utils/BasePlutsError.js");
var InvalidCborFormatError_1 = require("../../../utils/InvalidCborFormatError.js");
var assert_1 = require("../../../utils/assert.js");
function isITxOutRef(stuff) {
    return ((0, obj_utils_1.isObject)(stuff) &&
        (0, obj_utils_1.hasOwn)(stuff, "id") && ((typeof stuff.id === "string" && bytestring_1.ByteString.isValidHexValue(stuff.id) && (stuff.id.length === 64)) ||
        (stuff.id instanceof hashes_1.Hash32)) &&
        (0, obj_utils_1.hasOwn)(stuff, "index") && (typeof stuff.index === "number" &&
        stuff.index === Math.round(Math.abs(stuff.index))));
}
exports.isITxOutRef = isITxOutRef;
function ITxOutRefToStr(iRef) {
    if (!isITxOutRef(iRef))
        throw new BasePlutsError_1.BasePlutsError("'ITxOutRefToStr' works on 'ITxOutRef' like objects");
    return "".concat(iRef.id.toString(), "#").concat(iRef.index.toString());
}
exports.ITxOutRefToStr = ITxOutRefToStr;
var TxOutRef = /** @class */ (function () {
    function TxOutRef(_a) {
        var id = _a.id, index = _a.index;
        (0, assert_1.assert)((typeof id === "string" && bytestring_1.ByteString.isValidHexValue(id) && (id.length === 64)) ||
            (id instanceof hashes_1.Hash32), "tx output id (tx hash) invalid while constructing a 'UTxO'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "id", id instanceof hashes_1.Hash32 ? id : new hashes_1.Hash32(id));
        (0, obj_utils_1.defineReadOnlyProperty)(this, "index", Number((0, ints_1.forceBigUInt)(index)));
    }
    TxOutRef.prototype.toString = function () {
        return "".concat(this.id.toString(), "#").concat(this.index.toString());
    };
    TxOutRef.prototype.toData = function () {
        return new plutus_data_1.DataConstr(0, // PTxOutRef only constructor
        [
            new plutus_data_1.DataConstr(0, // PTxId only constructor
            [new plutus_data_1.DataB(this.id.asBytes)]),
            new plutus_data_1.DataI(this.index)
        ]);
    };
    TxOutRef.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    TxOutRef.prototype.toCborObj = function () {
        return new cbor_1.CborArray([
            this.id.toCborObj(),
            new cbor_1.CborUInt(this.index)
        ]);
    };
    TxOutRef.fromCbor = function (cStr) {
        return TxOutRef.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr)));
    };
    TxOutRef.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxOutRef");
        var _a = __read(cObj.array, 2), _id = _a[0], _index = _a[1];
        var idRes = hashes_1.Hash32.fromCborObj(_id);
        if (!(_index instanceof cbor_1.CborUInt))
            throw new InvalidCborFormatError_1.InvalidCborFormatError("TxOutRef");
        return new TxOutRef({
            id: idRes,
            index: Number(_index.num)
        });
    };
    TxOutRef.prototype.toJson = function () {
        return {
            id: this.id.toString(),
            index: this.index
        };
    };
    Object.defineProperty(TxOutRef, "fake", {
        get: function () {
            return new TxOutRef({
                id: "ff".repeat(32),
                index: 0
            });
        },
        enumerable: false,
        configurable: true
    });
    return TxOutRef;
}());
exports.TxOutRef = TxOutRef;
