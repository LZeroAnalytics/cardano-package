import { IRMetadata } from "../interfaces/IRMetadata.js";
import { Cloneable } from "@harmoniclabs/cbor/dist/utils/Cloneable";
import { ToJson } from "../../utils/ToJson.js";
import { IRTerm } from "../IRTerm.js";
import { IHash, IIRParent } from "../interfaces/index.js";
import { IRParentTerm } from "../utils/isIRParentTerm.js";
export type HoistedSetEntry = {
    hoisted: IRHoisted;
    nReferences: number;
};
export interface IRHoistedMeta {
    /**
     * force hoisting even if only a single reference is found
     *
     * useful to hoist terms used once in recursive expressions
    **/
    forceHoist?: boolean;
    name?: string | undefined;
}
export interface IRHoistedMetadata extends IRMetadata {
    meta: IRHoistedMeta;
}
export declare class IRHoisted implements Cloneable<IRHoisted>, IHash, IIRParent, ToJson, IRHoistedMetadata {
    readonly hash: Uint8Array;
    markHashAsInvalid: () => void;
    hoisted: IRTerm;
    readonly dependencies: HoistedSetEntry[];
    parent: IRParentTerm | undefined;
    clone: () => IRHoisted;
    readonly meta: IRHoistedMeta;
    constructor(hoisted: IRTerm, metadata?: Partial<IRHoistedMeta>);
    static get tag(): Uint8Array;
    toJson(): any;
}
/**
 * basically an insertion sort;
 *
 * @param {HoistedSetEntry[]} hoistedTerms
 * @returns {HoistedSetEntry[]} a **new** array with ```IRHoisted```s with no dependencies first, followed by the dependents
 */
export declare function getSortedHoistedSet(hoistedTerms: HoistedSetEntry[]): HoistedSetEntry[];
export declare function getHoistedTerms(irTerm: IRTerm): HoistedSetEntry[];
export declare function cloneHoistedSetEntry({ hoisted, nReferences }: HoistedSetEntry): HoistedSetEntry;
