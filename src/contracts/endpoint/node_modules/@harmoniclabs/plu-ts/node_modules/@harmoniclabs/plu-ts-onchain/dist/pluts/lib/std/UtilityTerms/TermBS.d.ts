import { PByteString, TermFn, PInt, PBool } from "../../../PTypes/index.js";
import { Term } from "../../../Term/index.js";
import { PappArg } from "../../pappArg.js";
import { TermBool } from "./TermBool.js";
import { TermInt } from "./TermInt.js";
import { TermStr } from "./TermStr.js";
export type TermBS = Term<PByteString> & {
    readonly length: TermInt;
    readonly utf8Decoded: TermStr;
    readonly pconcat: TermFn<[PByteString], PByteString>;
    readonly concat: (other: PappArg<PByteString>) => TermBS;
    readonly pprepend: TermFn<[PInt], PByteString>;
    readonly prepend: (byte: PappArg<PInt>) => TermBS;
    readonly psubByteString: TermFn<[PInt, PInt], PByteString>;
    readonly subByteString: (fromInclusive: PappArg<PInt>, ofLength: PappArg<PInt>) => TermBS;
    readonly pslice: TermFn<[PInt, PInt], PByteString>;
    readonly slice: (fromInclusive: PappArg<PInt>, toExclusive: PappArg<PInt>) => TermBS;
    readonly pat: TermFn<[PInt], PInt>;
    readonly at: (index: PappArg<PInt>) => TermInt;
    readonly peq: TermFn<[PByteString], PBool>;
    readonly eq: (other: PappArg<PByteString>) => TermBool;
    readonly plt: TermFn<[PByteString], PBool>;
    readonly lt: (other: PappArg<PByteString>) => TermBool;
    readonly pltEq: TermFn<[PByteString], PBool>;
    readonly ltEq: (other: PappArg<PByteString>) => TermBool;
    readonly pgt: TermFn<[PByteString], PBool>;
    readonly gt: (other: PappArg<PByteString>) => TermBool;
    readonly pgtEq: TermFn<[PByteString], PBool>;
    readonly gtEq: (other: PappArg<PByteString>) => TermBool;
};
export declare function addPByteStringMethods(term: Term<PByteString>): TermBS;
