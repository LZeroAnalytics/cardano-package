"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BnCEK = exports.haskellMod = exports.haskellDiv = exports.haskellRem = exports.haskellQuot = void 0;
var bigint_utils_1 = require("@harmoniclabs/bigint-utils");
var bytestring_1 = require("@harmoniclabs/bytestring");
var pair_1 = require("@harmoniclabs/pair");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var uplc_1 = require("@harmoniclabs/uplc");
var ExBudget_1 = require("../Machine/ExBudget.js");
var crypto_1 = require("@harmoniclabs/crypto");
var CEKError_1 = require("../CEKValue/CEKError.js");
var CEKConst_1 = require("../CEKValue/CEKConst.js");
var shiftU8Arr_1 = require("./impl/shiftU8Arr.js");
var rotateU8Arr_1 = require("./impl/rotateU8Arr.js");
var countSetBits_1 = require("./impl/countSetBits.js");
var findFirstSetBit_1 = require("./impl/findFirstSetBit.js");
var readBit_1 = require("./impl/readBit.js");
var writeBit_1 = require("./impl/writeBit.js");
function intToSize(n) {
    n = BigInt(n);
    if (n === _0n)
        return BigInt(1);
    // same as `intToSize( -n - BigInt( 1 ) )` but inlined
    if (n < _0n)
        return ((0, bigint_utils_1.log2)((-n - BigInt(1)) << BigInt(1)) / BigInt(8)) + BigInt(1);
    return ((0, bigint_utils_1.log2)(n << BigInt(1)) / BigInt(8)) + BigInt(1);
}
function bsToSize(bs) {
    var len = ((bs instanceof Uint8Array) ? bs : bs.toBuffer()).length;
    return len === 0 ?
        // TODO: Bug in cardano-node; to fix next hard fork
        BigInt(1) :
        BigInt(len);
}
function strToSize(str) {
    return bsToSize((0, uint8array_utils_1.fromUtf8)(str));
}
;
var BLS_G1_SIZE = BigInt(48);
var BLS_G2_SIZE = BigInt(96);
var BLS_ML_RESULT_SIZE = BigInt(192);
var BOOL_SIZE = BigInt(1);
var ANY_SIZE = BigInt(1);
function constValueToSize(v) {
    if ((0, uplc_1.isConstValueInt)(v))
        return intToSize(BigInt(v));
    if (v instanceof bytestring_1.ByteString)
        return bsToSize(v.toBuffer());
    if (typeof v === "string")
        return strToSize(v);
    if (typeof v === "undefined")
        return ANY_SIZE;
    if (typeof v === "boolean")
        return BOOL_SIZE;
    if ((0, plutus_data_1.isData)(v))
        return dataToSize(v);
    if (Array.isArray(v))
        return listToSize(v);
    if (v instanceof pair_1.Pair)
        return pairToSize(v);
    console.warn("unexpected 'constValueToSize'; exec costs evaluation might be inaccurate");
    return ANY_SIZE;
}
function listToSize(l) {
    return l.reduce(function (acc, elem) { return acc + constValueToSize(elem); }, BigInt(0));
}
function pairToSize(pairValue) {
    return constValueToSize(pairValue.fst) + constValueToSize(pairValue.snd);
}
function dataToSize(data) {
    var stack = [data];
    var tot = _0n;
    while (stack.length > 0) {
        var top_1 = stack.pop();
        tot += BigInt(4);
        if (top_1 instanceof plutus_data_1.DataConstr) {
            stack.unshift.apply(stack, __spreadArray([], __read(top_1.fields), false));
        }
        else if (top_1 instanceof plutus_data_1.DataMap) {
            stack.unshift.apply(stack, __spreadArray([], __read(top_1.map.reduce(function (accum, elem) { return __spreadArray([elem.fst, elem.snd], __read(accum), false); }, [])), false));
        }
        else if (top_1 instanceof plutus_data_1.DataList) {
            stack.unshift.apply(stack, __spreadArray([], __read(top_1.list), false));
        }
        else if (top_1 instanceof plutus_data_1.DataI) {
            tot += intToSize(top_1.int);
        }
        else if (top_1 instanceof plutus_data_1.DataB) {
            tot += bsToSize(top_1.bytes);
        }
        else
            break; // top === undefined; stack empty (unreachable)
    }
    return tot;
}
function isConstOfType(constant, ty) {
    var checkValue = function (v) {
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.int, ty)) {
            return (0, uplc_1.isConstValueInt)(v);
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.bool, ty)) {
            return typeof v === "boolean";
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.byteStr, ty)) {
            return (bytestring_1.ByteString.isStrictInstance(v));
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.data, ty)) {
            return ((0, plutus_data_1.isData)(v));
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.str, ty)) {
            return typeof v === "string";
        }
        if ((0, uplc_1.constTypeEq)(uplc_1.constT.unit, ty)) {
            return v === undefined;
        }
        return false;
    };
    // if( constant instanceof HoistedUPLC ) constant = constant.UPLC;
    return (constant instanceof CEKConst_1.CEKConst &&
        (0, uplc_1.constTypeEq)(constant.type, ty) &&
        checkValue(constant.value));
}
function getInt(a) {
    if (!isConstOfType(a, uplc_1.constT.int))
        return undefined;
    return BigInt(a.value);
}
function getIntNumFromConstValue(a) {
    if (!(0, uplc_1.isConstValueInt)(a))
        return undefined;
    var n = Number(a);
    if (!Number.isSafeInteger(n))
        return undefined;
    return n;
}
function getInts(a, b) {
    if (!isConstOfType(a, uplc_1.constT.int))
        return undefined;
    if (!isConstOfType(b, uplc_1.constT.int))
        return undefined;
    return {
        a: BigInt(a.value),
        b: BigInt(b.value)
    };
}
function getBS(a) {
    if (!isConstOfType(a, uplc_1.constT.byteStr))
        return undefined;
    return a.value;
}
function getStr(a) {
    if (!isConstOfType(a, uplc_1.constT.str))
        return undefined;
    return a.value;
}
function getList(list) {
    if (!(list instanceof CEKConst_1.CEKConst &&
        list.type[0] === uplc_1.ConstTyTag.list &&
        Array.isArray(list.value)))
        return undefined;
    return list.value.slice();
}
function getPair(pair) {
    if (!(pair instanceof CEKConst_1.CEKConst &&
        pair.type[0] === uplc_1.ConstTyTag.pair &&
        pair_1.Pair.isStrictInstance(pair.value)))
        return undefined;
    // no need to clone
    return pair.value;
}
function getData(data) {
    if (!(data instanceof CEKConst_1.CEKConst &&
        (0, uplc_1.constTypeEq)(data.type, uplc_1.constT.data) &&
        (0, plutus_data_1.isData)(data.value)))
        return undefined;
    return data.value;
}
function getBool(c) {
    if (!(c instanceof CEKConst_1.CEKConst &&
        (0, uplc_1.constTypeEq)(c.type, uplc_1.constT.bool) &&
        typeof c.value === "boolean"))
        return undefined;
    return c.value;
}
function getBlsG1(elem) {
    if (!(elem instanceof CEKConst_1.CEKConst &&
        (0, uplc_1.constTypeEq)(elem.type, uplc_1.constT.bls12_381_G1_element) &&
        (0, crypto_1.isBlsG1)(elem.value)))
        return undefined;
    return elem.value;
}
function getBlsG2(elem) {
    if (!(elem instanceof CEKConst_1.CEKConst &&
        (0, uplc_1.constTypeEq)(elem.type, uplc_1.constT.bls12_381_G2_element) &&
        (0, crypto_1.isBlsG2)(elem.value)))
        return undefined;
    return elem.value;
}
function getBlsResult(elem) {
    if (!(elem instanceof CEKConst_1.CEKConst &&
        (0, uplc_1.constTypeEq)(elem.type, uplc_1.constT.bls12_381_MlResult) &&
        (0, crypto_1.isBlsResult)(elem.value)))
        return undefined;
    return elem.value;
}
function intBinOp(a, b, op, fnName) {
    var ints = getInts(a, b);
    if (ints === undefined)
        return new CEKError_1.CEKError("".concat(fnName, " :: invalid arguments"), { a: a, b: b });
    var result = op(ints.a, ints.b);
    if (result === undefined)
        return new CEKError_1.CEKError("".concat(fnName, " :: operation error"), { a: a, b: b, ints_a: ints.a, ints_b: ints.b });
    return CEKConst_1.CEKConst.int(result);
}
function haskellQuot(a, b) {
    if (b === _0n)
        return undefined;
    return a / b;
}
exports.haskellQuot = haskellQuot;
function haskellRem(a, b) {
    if (b === _0n)
        return undefined;
    return a % b;
}
exports.haskellRem = haskellRem;
function haskellQuotRem(a, b) {
    var quot = haskellQuot(a, b);
    if (quot === undefined)
        return quot;
    var rem = haskellRem(a, b);
    if (rem === undefined)
        return rem;
    return [quot, rem];
}
function haskellDivMod(a, b) {
    if (b === _0n)
        return undefined;
    if (a > _0n && b < _0n) {
        var qr = haskellQuotRem(a - BigInt(1), b);
        if (qr === undefined)
            return undefined;
        return [
            qr[0] - BigInt(1),
            qr[1] + b + BigInt(1)
        ];
    }
    if (a < _0n && b > _0n) {
        var qr = haskellQuotRem(a + BigInt(1), b);
        if (qr === undefined)
            return undefined;
        return [
            qr[0] - BigInt(1),
            qr[1] + b - BigInt(1)
        ];
    }
    return haskellQuotRem(a, b);
}
function haskellDiv(a, b) {
    var dm = haskellDivMod(a, b);
    if (dm === undefined)
        return undefined;
    return dm[0];
}
exports.haskellDiv = haskellDiv;
function haskellMod(a, b) {
    var dm = haskellDivMod(a, b);
    if (dm === undefined)
        return undefined;
    return dm[1];
}
exports.haskellMod = haskellMod;
function constOrErr(getConst) {
    try {
        return getConst();
    }
    catch (e) {
        return new CEKError_1.CEKError(e.message, { e: e });
    }
}
var BnCEK = /** @class */ (function () {
    function BnCEK(getBuiltinCostFunc, machineBudget, logs) {
        this.getBuiltinCostFunc = getBuiltinCostFunc;
        this.logs = logs;
        this.machineBudget = machineBudget;
    }
    ;
    BnCEK.prototype.eval = function (bn) {
        switch (bn.tag) {
            case uplc_1.UPLCBuiltinTag.addInteger: return this.addInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.subtractInteger: return this.subtractInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.multiplyInteger: return this.multiplyInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.divideInteger: return this.divideInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.quotientInteger: return this.quotientInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.remainderInteger: return this.remainderInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.modInteger: return this.modInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsInteger: return this.equalsInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanInteger: return this.lessThanInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanEqualInteger: return this.lessThanEqualInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.appendByteString: return this.appendByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.consByteString: return this.consByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sliceByteString: return this.sliceByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lengthOfByteString: return this.lengthOfByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.indexByteString: return this.indexByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsByteString: return this.equalsByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanByteString: return this.lessThanByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.lessThanEqualsByteString: return this.lessThanEqualsByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sha2_256: return this.sha2_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sha3_256: return this.sha3_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.blake2b_256: return this.blake2b_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.verifyEd25519Signature: return this.verifyEd25519Signature.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.appendString: return this.appendString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsString: return this.equalsString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.encodeUtf8: return this.encodeUtf8.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.decodeUtf8: return this.decodeUtf8.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.ifThenElse: return this.ifThenElse.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.chooseUnit: return this.chooseUnit.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.trace: return this.trace.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.fstPair: return this.fstPair.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.sndPair: return this.sndPair.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.chooseList: return this.chooseList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkCons: return this.mkCons.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.headList: return this.headList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.tailList: return this.tailList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.nullList: return this.nullList.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.chooseData: return this.chooseData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.constrData: return this.constrData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mapData: return this.mapData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.listData: return this.listData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.iData: return this.iData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bData: return this.bData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unConstrData: return this.unConstrData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unMapData: return this.unMapData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unListData: return this.unListData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unIData: return this.unIData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.unBData: return this.unBData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.equalsData: return this.equalsData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkPairData: return this.mkPairData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkNilData: return this.mkNilData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.mkNilPairData: return this.mkNilPairData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.serialiseData: return this.serialiseData.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.verifyEcdsaSecp256k1Signature: return this.verifyEcdsaSecp256k1Signature.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.verifySchnorrSecp256k1Signature: return this.verifySchnorrSecp256k1Signature.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_add: return this.bls12_381_G1_add.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_neg: return this.bls12_381_G1_neg.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_scalarMul: return this.bls12_381_G1_scalarMul.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_equal: return this.bls12_381_G1_equal.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_hashToGroup: return this.bls12_381_G1_hashToGroup.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_compress: return this.bls12_381_G1_compress.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G1_uncompress: return this.bls12_381_G1_uncompress.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_add: return this.bls12_381_G2_add.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_neg: return this.bls12_381_G2_neg.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_scalarMul: return this.bls12_381_G2_scalarMul.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_equal: return this.bls12_381_G2_equal.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_hashToGroup: return this.bls12_381_G2_hashToGroup.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_compress: return this.bls12_381_G2_compress.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_G2_uncompress: return this.bls12_381_G2_uncompress.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_millerLoop: return this.bls12_381_millerLoop.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_mulMlResult: return this.bls12_381_mulMlResult.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.bls12_381_finalVerify: return this.bls12_381_finalVerify.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.keccak_256: return this.keccak_256.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.blake2b_224: return this.blake2b_224.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.byteStringToInteger: return this.byteStringToInteger.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.integerToByteString: return this.integerToByteString.apply(this, __spreadArray([], __read(bn.args), false));
            // plomin
            case uplc_1.UPLCBuiltinTag.andByteString: return this.andByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.orByteString: return this.orByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.xorByteString: return this.xorByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.complementByteString: return this.complementByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.readBit: return this.readBit.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.writeBits: return this.writeBits.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.replicateByte: return this.replicateByte.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.shiftByteString: return this.shiftByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.rotateByteString: return this.rotateByteString.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.countSetBits: return this.countSetBits.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.findFirstSetBit: return this.findFirstSetBit.apply(this, __spreadArray([], __read(bn.args), false));
            case uplc_1.UPLCBuiltinTag.ripemd_160: return this.ripemd_160.apply(this, __spreadArray([], __read(bn.args), false));
            default:
                bn.tag; // check that is of type 'never'
                return new CEKError_1.CEKError("unrecognized builtin tag", { tag: bn.tag });
        }
    };
    BnCEK.prototype.addInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.addInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return a + b;
        }).bind(this), "addInteger");
    };
    BnCEK.prototype.subtractInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.subtractInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return a - b;
        }).bind(this), "subtractInteger");
    };
    BnCEK.prototype.multiplyInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.multiplyInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return a * b;
        }).bind(this), "multiplyInteger");
    };
    BnCEK.prototype.divideInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            if (b === _0n)
                return undefined; // divide by 0
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.divideInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellDiv(a, b);
        }).bind(this), "divideInteger");
    };
    BnCEK.prototype.quotientInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.quotientInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellQuot(a, b);
        }).bind(this), "quotientInteger");
    };
    BnCEK.prototype.remainderInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.remainderInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellRem(a, b);
        }).bind(this), "remainderInteger");
    };
    BnCEK.prototype.modInteger = function (_a, _b) {
        var _this = this;
        return intBinOp(_a, _b, (function (a, b) {
            var f = _this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.modInteger);
            var sa = intToSize(a);
            var sb = intToSize(b);
            _this.machineBudget.add({
                mem: f.mem.at(sa, sb),
                cpu: f.cpu.at(sa, sb)
            });
            return haskellMod(a, b);
        }).bind(this), "modInteger");
    };
    BnCEK.prototype.equalsInteger = function (a, b) {
        var ints = getInts(a, b);
        if (ints === undefined)
            return new CEKError_1.CEKError("equalsInteger :: not integers", { a: a, b: b, ints: ints });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsInteger);
        var sa = intToSize(ints.a);
        var sb = intToSize(ints.b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.bool(ints.a === ints.b);
    };
    BnCEK.prototype.lessThanInteger = function (a, b) {
        var ints = getInts(a, b);
        if (ints === undefined)
            return new CEKError_1.CEKError("lessThanInteger :: not integers", { a: a, b: b, ints: ints });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanInteger);
        var sa = intToSize(ints.a);
        var sb = intToSize(ints.b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.bool(ints.a < ints.b);
    };
    BnCEK.prototype.lessThanEqualInteger = function (a, b) {
        var ints = getInts(a, b);
        if (ints === undefined)
            return new CEKError_1.CEKError("lessThanEqualInteger :: not integers", { a: a, b: b, ints: ints });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanEqualInteger);
        var sa = intToSize(ints.a);
        var sb = intToSize(ints.b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.bool(ints.a <= ints.b);
    };
    BnCEK.prototype.appendByteString = function (a, b) {
        var _a = getBS(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("appendByteString :: not BS", { a: a });
        var _b = getBS(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("appendByteString :: not BS", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.appendByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(_a.toString() + _b.toString()));
    };
    BnCEK.prototype.consByteString = function (a, b) {
        var _a = getInt(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("consByteString :: not Int", { a: a });
        if (_a < 0)
            return new CEKError_1.CEKError("consByteString :: negative byte");
        if (_a >= BigInt(256))
            return new CEKError_1.CEKError("consByteString :: UInt8 overflow");
        var _b = getBS(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("consByteString :: not BS", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.consByteString);
        var sa = intToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(_a.toString(16).padStart(2, '0') + _b.toString()));
    };
    BnCEK.prototype.sliceByteString = function (fromIdx, ofLength, bs) {
        var idx = getInt(fromIdx);
        if (idx === undefined)
            return new CEKError_1.CEKError("sliceByteString :: not int", { fromIdx: fromIdx });
        var length = getInt(ofLength);
        if (length === undefined)
            return new CEKError_1.CEKError("sliceByteString :: not int", { ofLength: ofLength });
        var _bs = getBS(bs);
        if (_bs === undefined)
            return new CEKError_1.CEKError("sliceByteString :: not BS", { bs: bs });
        var i = idx < _0n ? _0n : idx;
        var endIdx = i + length;
        var maxIdx = BigInt(_bs.toBuffer().length);
        var j = endIdx > maxIdx ? maxIdx : endIdx;
        if (j < i)
            return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(Uint8Array.from([])));
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sliceByteString);
        var sidx = intToSize(idx);
        var slength = intToSize(length);
        var sbs = bsToSize(_bs);
        this.machineBudget.add({
            mem: f.mem.at(sidx, slength, sbs),
            cpu: f.cpu.at(sidx, slength, sbs)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(Uint8Array.from(_bs.toBuffer().slice(Number(i), Number(j)))));
    };
    BnCEK.prototype.lengthOfByteString = function (bs) {
        var _bs = getBS(bs);
        if (_bs === undefined)
            return new CEKError_1.CEKError("lengthOfByteString :: not BS", { bs: bs });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lengthOfByteString);
        var sbs = bsToSize(_bs);
        this.machineBudget.add({
            mem: f.mem.at(sbs),
            cpu: f.cpu.at(sbs)
        });
        return CEKConst_1.CEKConst.int(_bs.toBuffer().length);
    };
    BnCEK.prototype.indexByteString = function (bs, idx) {
        var _bs = getBS(bs);
        if (_bs === undefined)
            return new CEKError_1.CEKError("indexByteString :: not BS", { bs: bs });
        var i = getInt(idx);
        if (i === undefined || i >= _bs.toBuffer().length || i < _0n)
            return new CEKError_1.CEKError("indexByteString :: not int", { idx: idx });
        if (i >= BigInt("9223372036854775808"))
            return new CEKError_1.CEKError("indexByteString :: (maxBound :: Int64) overflow");
        var result = _bs.toBuffer().at(Number(i));
        if (result === undefined)
            return new CEKError_1.CEKError("indexByteString :: out of bytestring length", { bs_length: _bs.toBuffer().length, index: i });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.indexByteString);
        var sbs = bsToSize(_bs);
        var sidx = intToSize(i);
        this.machineBudget.add({
            mem: f.mem.at(sbs, sidx),
            cpu: f.cpu.at(sbs, sidx)
        });
        return CEKConst_1.CEKConst.int(result);
    };
    BnCEK.prototype.equalsByteString = function (a, b) {
        var _a = getBS(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("equalsByteString :: first argument not BS", {
                bs_0: a,
                bs_1: b
            });
        var _b = getBS(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("equalsByteString :: second argument not BS", {
                bs_0: a,
                bs_1: b
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.bool(_a.toString() === _b.toString());
    };
    BnCEK.prototype.lessThanByteString = function (a, b) {
        var _c;
        var _a = getBS(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("lessThanByteString :: not BS", { a: a });
        var _b = getBS(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("lessThanByteString :: not BS", { b: b });
        var aBytes = _a.toBuffer();
        var bBytes = _b.toBuffer();
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        if (aBytes.length < bBytes.length)
            return CEKConst_1.CEKConst.bool(true);
        // aBytes.length is either greather or equal bBytes.length
        for (var i = 0; i < aBytes.length; i++) {
            var aByte = (_c = aBytes.at(i)) !== null && _c !== void 0 ? _c : Infinity;
            var bByte = bBytes.at(i);
            if (bByte === undefined)
                return CEKConst_1.CEKConst.bool(false);
            if (aByte < bByte)
                return CEKConst_1.CEKConst.bool(true);
            if (aByte > bByte)
                return CEKConst_1.CEKConst.bool(false);
        }
        return CEKConst_1.CEKConst.bool(false);
    };
    BnCEK.prototype.lessThanEqualsByteString = function (a, b) {
        var _a = getBS(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("lessThanEqualsByteString :: not BS", { a: a });
        var _b = getBS(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("lessThanEqualsByteString :: not BS", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.lessThanEqualsByteString);
        var sa = bsToSize(_a);
        var sb = bsToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        if (_a.toString() === _b.toString())
            return CEKConst_1.CEKConst.bool(true);
        // lessThanBytestring but with new environment for costs;
        return (new BnCEK(this.getBuiltinCostFunc, new ExBudget_1.ExBudget(0, 0), [])).lessThanByteString(a, b);
    };
    BnCEK.prototype.sha2_256 = function (stuff) {
        var b = getBS(stuff);
        if (b === undefined)
            return new CEKError_1.CEKError("sha2_256 :: not BS", { stuff: stuff });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sha2_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(new Uint8Array((0, crypto_1.sha2_256_sync)(b.toBuffer()))));
    };
    BnCEK.prototype.sha3_256 = function (stuff) {
        var b = getBS(stuff);
        if (b === undefined)
            return new CEKError_1.CEKError("sha3_256 :: not BS", stuff);
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sha3_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(new Uint8Array((0, crypto_1.sha3)(b.toBuffer()))));
    };
    BnCEK.prototype.blake2b_256 = function (stuff) {
        var b = getBS(stuff);
        if (b === undefined)
            return new CEKError_1.CEKError("blake2b_256 :: not BS", { stuff: stuff });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.blake2b_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, crypto_1.blake2b)(b.toBuffer(), 32))); });
    };
    BnCEK.prototype.verifyEd25519Signature = function (key, message, signature) {
        var k = getBS(key);
        if (k === undefined)
            return new CEKError_1.CEKError("verifyEd25519Signature :: key not BS", { key: key });
        var kBytes = k.toBuffer();
        if (kBytes.length !== 32)
            return new CEKError_1.CEKError("sha2_verifyEd25519Signature256 :: wrong message length", {
                kBytes: kBytes,
                kStr: k.toString()
            });
        var m = getBS(message);
        if (m === undefined)
            return new CEKError_1.CEKError("verifyEd25519Signature :: message not BS", { message: message });
        var s = getBS(signature);
        if (s === undefined)
            return new CEKError_1.CEKError("verifyEd25519Signature :: singature not BS", { signature: signature });
        var sBytes = s.toBuffer();
        if (sBytes.length !== 64)
            return new CEKError_1.CEKError("sha2_verifyEd25519Signature256 :: wrong signature length", {
                signature_length: sBytes.length,
                signatureHex: s.toString(),
                signatureBytes: sBytes
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.verifyEd25519Signature);
        var sk = bsToSize(kBytes);
        var sm = bsToSize(m);
        var ss = bsToSize(sBytes);
        this.machineBudget.add({
            mem: f.mem.at(sk, sm, ss),
            cpu: f.cpu.at(sk, sm, ss)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bool((0, crypto_1.verifyEd25519Signature_sync)(sBytes, m.toBuffer(), kBytes)); });
    };
    BnCEK.prototype.appendString = function (a, b) {
        var _a = getStr(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("appendString :: not Str", { a: a });
        var _b = getStr(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("appendString :: not Str", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.appendString);
        var sa = strToSize(_a);
        var sb = strToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.str(_a + _b);
    };
    BnCEK.prototype.equalsString = function (a, b) {
        var _a = getStr(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("equalsString :: not Str", { a: a });
        var _b = getStr(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("equalsString :: not Str", {
                b: b
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsString);
        var sa = strToSize(_a);
        var sb = strToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.bool(_a === _b);
    };
    BnCEK.prototype.encodeUtf8 = function (a) {
        var _a = getStr(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("encodeUtf8 :: not Str", { a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.encodeUtf8);
        var sa = strToSize(_a);
        this.machineBudget.add({
            mem: f.mem.at(sa),
            cpu: f.cpu.at(sa)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, uint8array_utils_1.fromUtf8)(_a)));
    };
    BnCEK.prototype.decodeUtf8 = function (a) {
        var _a = getBS(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("decodeUtf8 :: not BS", { arg: a });
        var _a_buff = _a.toBuffer();
        if (!isValidUtf8(_a_buff))
            return new CEKError_1.CEKError("decodeUtf8 :: invalid utf8", { hex: (0, uint8array_utils_1.toHex)(_a_buff) });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.decodeUtf8);
        var sa = bsToSize(_a_buff);
        this.machineBudget.add({
            mem: f.mem.at(sa),
            cpu: f.cpu.at(sa)
        });
        return CEKConst_1.CEKConst.str((0, uint8array_utils_1.toUtf8)(_a_buff));
    };
    BnCEK.prototype.ifThenElse = function (condition, caseTrue, caseFalse) {
        if (!isConstOfType(condition, uplc_1.constT.bool))
            return new CEKError_1.CEKError("ifThenElse :: condition was not a boolean", { condition: condition });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.ifThenElse);
        this.machineBudget.add({
            mem: f.mem.at(BOOL_SIZE, ANY_SIZE, ANY_SIZE),
            cpu: f.cpu.at(BOOL_SIZE, ANY_SIZE, ANY_SIZE),
        });
        return condition.value ? caseTrue : caseFalse;
    };
    BnCEK.prototype.chooseUnit = function (unit, b) {
        if (!isConstOfType(unit, uplc_1.constT.unit))
            return new CEKError_1.CEKError("chooseUnit :: not a unit", { unit: unit });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.chooseUnit);
        this.machineBudget.add({
            mem: f.mem.at(ANY_SIZE, ANY_SIZE),
            cpu: f.cpu.at(ANY_SIZE, ANY_SIZE)
        });
        return b;
    };
    BnCEK.prototype.trace = function (msg, result) {
        var _msg = getStr(msg);
        this.logs.push(_msg !== null && _msg !== void 0 ? _msg : "_msg_not_a_string_");
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.trace);
        var smsg = _msg ? strToSize(_msg) : BigInt(0);
        this.machineBudget.add({
            mem: f.mem.at(smsg, ANY_SIZE),
            cpu: f.cpu.at(smsg, ANY_SIZE)
        });
        return result;
    };
    BnCEK.prototype.fstPair = function (pair) {
        var p = getPair(pair);
        if (p === undefined)
            return new CEKError_1.CEKError("fstPair :: not a pair", { pair: pair });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.fstPair);
        var sp = pairToSize(p);
        this.machineBudget.add({
            mem: f.mem.at(sp),
            cpu: f.cpu.at(sp)
        });
        return new CEKConst_1.CEKConst(uplc_1.constPairTypeUtils.getFirstTypeArgument(pair.type), p.fst);
    };
    BnCEK.prototype.sndPair = function (pair) {
        var p = getPair(pair);
        if (p === undefined)
            return new CEKError_1.CEKError("sndPair :: not a pair", { pair: pair });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.sndPair);
        var sp = pairToSize(p);
        this.machineBudget.add({
            mem: f.mem.at(sp),
            cpu: f.cpu.at(sp)
        });
        return new CEKConst_1.CEKConst(uplc_1.constPairTypeUtils.getSecondTypeArgument(pair.type), p.snd);
    };
    BnCEK.prototype.chooseList = function (list, whateverA, whateverB) {
        var l = getList(list);
        if (l === undefined)
            return new CEKError_1.CEKError("chooseList :: not a list", { list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.chooseList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl, ANY_SIZE, ANY_SIZE),
            cpu: f.cpu.at(sl, ANY_SIZE, ANY_SIZE)
        });
        return l.length === 0 ? whateverA : whateverB;
    };
    BnCEK.prototype.mkCons = function (elem, list) {
        if (!(elem instanceof CEKConst_1.CEKConst &&
            list instanceof CEKConst_1.CEKConst &&
            list.type[0] === uplc_1.ConstTyTag.list &&
            (0, uplc_1.constTypeEq)(elem.type, uplc_1.constListTypeUtils.getTypeArgument(list.type))))
            return new CEKError_1.CEKError("mkCons :: incongruent list types; listT: " +
                (list instanceof CEKConst_1.CEKConst ? (0, uplc_1.constTypeToStirng)(list.type) : "") +
                "; elemsT: " +
                (elem instanceof CEKConst_1.CEKConst ? (0, uplc_1.constTypeToStirng)(elem.type) : ""), {
                list: list,
                elem: elem
            });
        var l = getList(list);
        if (l === undefined)
            return new CEKError_1.CEKError("mkCons :: not a list", { list: list });
        var value = elem.value;
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkCons);
        var sl = listToSize(l);
        var sv = constValueToSize(value);
        this.machineBudget.add({
            mem: f.mem.at(sv, sl),
            cpu: f.cpu.at(sv, sl)
        });
        return new CEKConst_1.CEKConst(list.type, __spreadArray([value], __read(l), false));
    };
    BnCEK.prototype.headList = function (list) {
        var l = getList(list);
        if (l === undefined || l.length === 0)
            return new CEKError_1.CEKError(l === undefined ?
                "headList :: not a list" :
                "headList :: empty list passed to 'head'", { list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.headList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl),
            cpu: f.cpu.at(sl)
        });
        return new CEKConst_1.CEKConst(uplc_1.constListTypeUtils.getTypeArgument(list.type), l[0]);
    };
    BnCEK.prototype.tailList = function (list) {
        var l = getList(list);
        if (l === undefined || l.length === 0)
            return new CEKError_1.CEKError(l === undefined ?
                "tailList :: not a list" :
                "tailList :: empty list passed to 'tail'", { list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.tailList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl),
            cpu: f.cpu.at(sl)
        });
        return new CEKConst_1.CEKConst(list.type, l.slice(1));
    };
    BnCEK.prototype.nullList = function (list) {
        var l = getList(list);
        if (l === undefined)
            return new CEKError_1.CEKError("nullList :: not a list", { arg: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.nullList);
        var sl = listToSize(l);
        this.machineBudget.add({
            mem: f.mem.at(sl),
            cpu: f.cpu.at(sl)
        });
        return CEKConst_1.CEKConst.bool(l.length === 0);
    };
    BnCEK.prototype.chooseData = function (data, constr, map, list, int, bs) {
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("chooseData :: not data", { data: data });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.chooseData);
        var sd = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(sd),
            cpu: f.cpu.at(sd)
        });
        if (d instanceof plutus_data_1.DataConstr)
            return constr;
        if (d instanceof plutus_data_1.DataMap)
            return map;
        if (d instanceof plutus_data_1.DataList)
            return list;
        if (d instanceof plutus_data_1.DataI)
            return int;
        if (d instanceof plutus_data_1.DataB)
            return bs;
        return new CEKError_1.CEKError("unrecognized data, possibly DataPair", { data: data, d: d });
    };
    BnCEK.prototype.constrData = function (idx, fields) {
        var i = getInt(idx);
        if (i === undefined)
            return new CEKError_1.CEKError("constrData :: not int", { idx: idx });
        var _fields = getList(fields);
        if (_fields === undefined)
            return new CEKError_1.CEKError("constrData :: not a list", { fields: fields });
        if (!(0, uplc_1.constTypeEq)(fields.type, uplc_1.constT.listOf(uplc_1.constT.data)))
            return new CEKError_1.CEKError("constrData :: passed fields are not a list of Data", { fields: fields, type: fields === null || fields === void 0 ? void 0 : fields.type });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.constrData);
        var si = intToSize(i);
        var sfields = _fields.reduce(function (acc, elem) { return acc + dataToSize(elem); }, _0n);
        this.machineBudget.add({
            mem: f.mem.at(si, sfields),
            cpu: f.cpu.at(si, sfields),
        });
        // assert we got a list of data
        // ( the type has been forced but not the value )
        if (!_fields.every(function (field) { return (0, plutus_data_1.isData)(field); }))
            return new CEKError_1.CEKError("constrData :: some of the fields are not Data, mismatching CEKConst type", { _fields: _fields });
        return CEKConst_1.CEKConst.data(new plutus_data_1.DataConstr(i, _fields));
    };
    BnCEK.prototype.mapData = function (listOfPair) {
        if (!(listOfPair instanceof CEKConst_1.CEKConst &&
            (0, uplc_1.constTypeEq)(listOfPair.type, uplc_1.constT.listOf(uplc_1.constT.pairOf(uplc_1.constT.data, uplc_1.constT.data)))))
            return new CEKError_1.CEKError("mapData :: not a map", { listOfPair: listOfPair });
        var list = getList(listOfPair);
        if (list === undefined)
            return new CEKError_1.CEKError("mapData :: not a list", { listOfPair: listOfPair });
        // assert we got a list of pair of datas
        // ( the type has been forced but not the value )
        if (!list.every(function (pair) {
            return pair_1.Pair.isStrictInstance(pair) &&
                (0, plutus_data_1.isData)(pair.fst) &&
                (0, plutus_data_1.isData)(pair.snd);
        }))
            return new CEKError_1.CEKError("some elements are not a pair, mismatching const type", { listOfPair: listOfPair, list: list });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mapData);
        var size = listToSize(list);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.data(new plutus_data_1.DataMap(list.map(function (pair) { return new plutus_data_1.DataPair(pair.fst, pair.snd); })));
    };
    BnCEK.prototype.listData = function (listOfData) {
        if (!(listOfData instanceof CEKConst_1.CEKConst &&
            (0, uplc_1.constTypeEq)(listOfData.type, uplc_1.constT.listOf(uplc_1.constT.data))))
            return new CEKError_1.CEKError("listData :: not a list of data", { listOfData: listOfData });
        var list = getList(listOfData);
        if (list === undefined)
            return new CEKError_1.CEKError("listData :: not a list", { listOfData: listOfData });
        // assert we got a list of data
        // ( the type has been forced but not the value )
        if (!list.every(function (data) { return (0, plutus_data_1.isData)(data); }))
            return new CEKError_1.CEKError("some of the elements are not data, mismatching const type", { listOfData: listOfData });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.listData);
        var size = listToSize(list);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.data(new plutus_data_1.DataList(list));
    };
    BnCEK.prototype.iData = function (int) {
        var i = getInt(int);
        if (i === undefined)
            return new CEKError_1.CEKError("iData :: not an int", {
                arg: int,
                type: int.type,
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.iData);
        var size = intToSize(i);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.data(new plutus_data_1.DataI(i));
    };
    BnCEK.prototype.bData = function (bs) {
        var b = getBS(bs);
        if (b === undefined)
            return new CEKError_1.CEKError("bData :: not BS", {
                arg: bs,
                type: bs.type,
                value: bs.value
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bData);
        var size = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.data(new plutus_data_1.DataB(b));
    };
    BnCEK.prototype.unConstrData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("unConstrData :: not data; ".concat(data instanceof CEKConst_1.CEKConst ? "CEKConst type: " + (0, uplc_1.constTypeToStirng)(data.type) : ""), { data: data });
        if (!(d instanceof plutus_data_1.DataConstr))
            return new CEKError_1.CEKError("unConstrData :: not a data constructor", {
                data: (0, plutus_data_1.dataToCbor)(d).toString()
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unConstrData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.pairOf(uplc_1.constT.int, uplc_1.constT.listOf(uplc_1.constT.data))(d.constr, d.fields);
    };
    BnCEK.prototype.unMapData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("unMapData :: not data", { data: data });
        if (!(d instanceof plutus_data_1.DataMap))
            return new CEKError_1.CEKError("unMapData :: not a data map", { data: data });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unMapData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.listOf(uplc_1.constT.pairOf(uplc_1.constT.data, uplc_1.constT.data))(d.map.map(function (dataPair) { return new pair_1.Pair(dataPair.fst, dataPair.snd); }));
    };
    BnCEK.prototype.unListData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("unListData :: not data", { data: data });
        if (!(d instanceof plutus_data_1.DataList))
            return new CEKError_1.CEKError("unListData :: not a data list", { data: d });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unListData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.listOf(uplc_1.constT.data)(d.list);
    };
    BnCEK.prototype.unIData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("unIData :: not data value", { data: data });
        if (!(d instanceof plutus_data_1.DataI))
            return new CEKError_1.CEKError("unIData :: not a data integer", { data: d });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unIData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.int(d.int);
    };
    BnCEK.prototype.unBData = function (data) {
        var _c;
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("unBData :: not data value", { data: data });
        if (!(d instanceof plutus_data_1.DataB))
            return new CEKError_1.CEKError("unBData :: not a data BS", {
                data: d,
                term: (_c = data === null || data === void 0 ? void 0 : data.value) === null || _c === void 0 ? void 0 : _c.constr
            });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.unBData);
        var size = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(size),
            cpu: f.cpu.at(size)
        });
        return CEKConst_1.CEKConst.byteString(d.bytes);
    };
    BnCEK.prototype.equalsData = function (a, b) {
        var _a = getData(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("equalsData :: not data; equalsData <first argument>", { a: a });
        var _b = getData(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("equalsData :: not data; equalsData <second argument>", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.equalsData);
        var sa = dataToSize(_a);
        var sb = dataToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.bool((0, plutus_data_1.eqData)(_a, _b));
    };
    BnCEK.prototype.mkPairData = function (a, b) {
        var _a = getData(a);
        if (_a === undefined)
            return new CEKError_1.CEKError("mkPairData :: not data; mkPairData <frist argument>", { a: a });
        var _b = getData(b);
        if (_b === undefined)
            return new CEKError_1.CEKError("mkPairData :: not data; mkPairData <second argument>", { b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkPairData);
        var sa = dataToSize(_a);
        var sb = dataToSize(_b);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return CEKConst_1.CEKConst.pairOf(uplc_1.constT.data, uplc_1.constT.data)(_a, _b);
    };
    BnCEK.prototype.mkNilData = function (unit) {
        if (!isConstOfType(unit, uplc_1.constT.unit))
            return new CEKError_1.CEKError("mkNilData :: not unit", { unit: unit });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkNilData);
        this.machineBudget.add({
            mem: f.mem.at(ANY_SIZE),
            cpu: f.cpu.at(ANY_SIZE)
        });
        return CEKConst_1.CEKConst.listOf(uplc_1.constT.data)([]);
    };
    BnCEK.prototype.mkNilPairData = function (unit) {
        if (!isConstOfType(unit, uplc_1.constT.unit))
            return new CEKError_1.CEKError("mkNilPairData :: not unit", { unit: unit });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.mkNilPairData);
        this.machineBudget.add({
            mem: f.mem.at(ANY_SIZE),
            cpu: f.cpu.at(ANY_SIZE)
        });
        return CEKConst_1.CEKConst.listOf(uplc_1.constT.pairOf(uplc_1.constT.data, uplc_1.constT.data))([]);
    };
    BnCEK.prototype.serialiseData = function (data) {
        var d = getData(data);
        if (d === undefined)
            return new CEKError_1.CEKError("serialiseData :: not data input", { data: data });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.serialiseData);
        var sData = dataToSize(d);
        this.machineBudget.add({
            mem: f.mem.at(sData),
            cpu: f.cpu.at(sData)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, plutus_data_1.dataToCbor)(d).toBuffer()));
    };
    BnCEK.prototype.verifyEcdsaSecp256k1Signature = function (a, b, c) {
        var pubKey = getBS(a);
        var messageHash = getBS(b);
        var signature = getBS(c);
        if (pubKey === undefined ||
            messageHash === undefined ||
            signature === undefined)
            return new CEKError_1.CEKError("verifyEcdsaSecp256k1Signature:: some argument was not byetstring", { a: a, b: b, c: c });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.verifyEcdsaSecp256k1Signature);
        var sa = bsToSize(pubKey);
        var sb = bsToSize(messageHash);
        var sc = bsToSize(signature);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb, sc),
            cpu: f.cpu.at(sa, sb, sc)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bool((0, crypto_1.verifyEcdsaSecp256k1Signature)(pubKey.toBuffer(), messageHash.toBuffer(), signature.toBuffer()));
        });
    };
    BnCEK.prototype.verifySchnorrSecp256k1Signature = function (a, b, c) {
        var pubKey = getBS(a);
        var messageHash = getBS(b);
        var signature = getBS(c);
        if (pubKey === undefined ||
            messageHash === undefined ||
            signature === undefined)
            return new CEKError_1.CEKError("verifySchnorrSecp256k1Signature:: some argument was not byetstring", { a: a, b: b, c: c });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.verifySchnorrSecp256k1Signature);
        var sa = bsToSize(pubKey);
        var sb = bsToSize(messageHash);
        var sc = bsToSize(signature);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb, sc),
            cpu: f.cpu.at(sa, sb, sc)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bool((0, crypto_1.verifySchnorrSecp256k1Signature)(pubKey.toBuffer(), messageHash.toBuffer(), signature.toBuffer()));
        });
    };
    BnCEK.prototype.bls12_381_G1_add = function (a, b) {
        var fst = getBlsG1(a);
        if (fst === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_add :: first argument not BlsG1 elem", { a: a, b: b });
        var snd = getBlsG1(b);
        if (snd === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_add :: second argument not BlsG1 elem", { fst: fst, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_add);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G1_SIZE, BLS_G1_SIZE),
            cpu: f.cpu.at(BLS_G1_SIZE, BLS_G1_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G1_element((0, crypto_1.bls12_381_G1_add)(fst, snd)); });
    };
    BnCEK.prototype.bls12_381_G1_neg = function (a) {
        var g1 = getBlsG1(a);
        if (g1 === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_neg :: first argument not BlsG1 elem", { a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_neg);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G1_SIZE),
            cpu: f.cpu.at(BLS_G1_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G1_element((0, crypto_1.bls12_381_G1_neg)(g1)); });
    };
    BnCEK.prototype.bls12_381_G1_scalarMul = function (a, b) {
        var n = getInt(a);
        if (n === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_scalarMul :: first argument not integer", { a: a, b: b });
        var g1 = getBlsG1(b);
        if (g1 === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_scalarMul :: second argument not BlsG1 elem", { n: n, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_scalarMul);
        var nSize = intToSize(n);
        this.machineBudget.add({
            mem: f.mem.at(nSize, BLS_G1_SIZE),
            cpu: f.cpu.at(nSize, BLS_G1_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G1_element((0, crypto_1.bls12_381_G1_scalarMul)(n, g1)); });
    };
    BnCEK.prototype.bls12_381_G1_equal = function (a, b) {
        var fst = getBlsG1(a);
        if (fst === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_equal :: first argument not BlsG1 elem", { a: a, b: b });
        var snd = getBlsG1(b);
        if (snd === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_equal :: second argument not BlsG1 elem", { fst: fst, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_equal);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G1_SIZE, BLS_G1_SIZE),
            cpu: f.cpu.at(BLS_G1_SIZE, BLS_G1_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bool((0, crypto_1.bls12_381_G1_equal)(fst, snd)); });
    };
    BnCEK.prototype.bls12_381_G1_hashToGroup = function (a, b) {
        var fst = getBS(a);
        if (fst === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_hashToGroup :: first argument not bytestring", { a: a, b: b });
        var snd = getBS(b);
        if (snd === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_hashToGroup :: second argument not bytestring", { fst: fst, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_hashToGroup);
        var sa = bsToSize(fst);
        var sb = bsToSize(snd);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G1_element((0, crypto_1.bls12_381_G1_hashToGroup)(fst.toBuffer(), snd.toBuffer())); });
    };
    BnCEK.prototype.bls12_381_G1_compress = function (a) {
        var g1 = getBlsG1(a);
        if (g1 === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_compress :: first argument not BlsG1 elem", { a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_compress);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G1_SIZE),
            cpu: f.cpu.at(BLS_G1_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, crypto_1.bls12_381_G1_compress)(g1))); });
    };
    BnCEK.prototype.bls12_381_G1_uncompress = function (a) {
        var bs = getBS(a);
        if (bs === undefined)
            return new CEKError_1.CEKError("bls12_381_G1_uncompress :: first argument not bs", { a: a });
        var bytes = bs.toBuffer();
        if (bytes.length !== Number(BLS_G1_SIZE)) {
            return new CEKError_1.CEKError("bls12_381_G1_uncompress :: invalid bytes length", { bytes: (0, uint8array_utils_1.toHex)(bytes) });
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G1_uncompress);
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bsSize),
            cpu: f.cpu.at(bsSize)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G1_element((0, crypto_1.bls12_381_G1_uncompress)(bytes)); });
    };
    BnCEK.prototype.bls12_381_G2_add = function (a, b) {
        var fst = getBlsG2(a);
        if (fst === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_add :: first argument not BlsG2 elem", { a: a, b: b });
        var snd = getBlsG2(b);
        if (snd === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_add :: second argument not BlsG2 elem", { fst: fst, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_add);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G2_SIZE, BLS_G2_SIZE),
            cpu: f.cpu.at(BLS_G2_SIZE, BLS_G2_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G2_element((0, crypto_1.bls12_381_G2_add)(fst, snd)); });
    };
    BnCEK.prototype.bls12_381_G2_neg = function (a) {
        var G2 = getBlsG2(a);
        if (G2 === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_neg :: first argument not BlsG2 elem", { a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_neg);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G2_SIZE),
            cpu: f.cpu.at(BLS_G2_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G2_element((0, crypto_1.bls12_381_G2_neg)(G2)); });
    };
    BnCEK.prototype.bls12_381_G2_scalarMul = function (a, b) {
        var n = getInt(a);
        if (n === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_scalarMul :: first argument not integer", { a: a, b: b });
        var G2 = getBlsG2(b);
        if (G2 === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_scalarMul :: second argument not BlsG2 elem", { n: n, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_scalarMul);
        var nSize = intToSize(n);
        this.machineBudget.add({
            mem: f.mem.at(nSize, BLS_G2_SIZE),
            cpu: f.cpu.at(nSize, BLS_G2_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bls12_381_G2_element((0, crypto_1.bls12_381_G2_scalarMul)(n, G2)); });
    };
    BnCEK.prototype.bls12_381_G2_equal = function (a, b) {
        var fst = getBlsG2(a);
        if (fst === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_equal :: first argument not BlsG2 elem", { a: a, b: b });
        var snd = getBlsG2(b);
        if (snd === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_equal :: second argument not BlsG2 elem", { fst: fst, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_equal);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G2_SIZE, BLS_G2_SIZE),
            cpu: f.cpu.at(BLS_G2_SIZE, BLS_G2_SIZE)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.bool((0, crypto_1.bls12_381_G2_equal)(fst, snd)); });
    };
    BnCEK.prototype.bls12_381_G2_hashToGroup = function (a, b) {
        var fst = getBS(a);
        if (fst === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_hashToGroup :: first argument not bytestring", { a: a, b: b });
        var snd = getBS(b);
        if (snd === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_hashToGroup :: second argument not bytestring", { fst: fst, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_hashToGroup);
        var sa = bsToSize(fst);
        var sb = bsToSize(snd);
        this.machineBudget.add({
            mem: f.mem.at(sa, sb),
            cpu: f.cpu.at(sa, sb)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bls12_381_G2_element((0, crypto_1.bls12_381_G2_hashToGroup)(fst.toBuffer(), snd.toBuffer()));
        });
    };
    BnCEK.prototype.bls12_381_G2_compress = function (a) {
        var G2 = getBlsG2(a);
        if (G2 === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_compress :: first argument not BlsG2 elem", { a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_compress);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G2_SIZE),
            cpu: f.cpu.at(BLS_G2_SIZE)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, crypto_1.bls12_381_G2_compress)(G2)));
        });
    };
    BnCEK.prototype.bls12_381_G2_uncompress = function (a) {
        var bs = getBS(a);
        if (bs === undefined)
            return new CEKError_1.CEKError("bls12_381_G2_uncompress :: first argument not bs", { a: a });
        var bytes = bs.toBuffer();
        if (bytes.length !== Number(BLS_G2_SIZE)) {
            return new CEKError_1.CEKError("bls12_381_G2_uncompress :: invalid bytes length", { bytes: (0, uint8array_utils_1.toHex)(bytes) });
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_G2_uncompress);
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bsSize),
            cpu: f.cpu.at(bsSize)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bls12_381_G2_element((0, crypto_1.bls12_381_G2_uncompress)(bytes));
        });
    };
    BnCEK.prototype.bls12_381_millerLoop = function (a, b) {
        var g1 = getBlsG1(a);
        if (g1 === undefined)
            return new CEKError_1.CEKError("bls12_381_millerLoop :: first argument not G1 element", { a: a, b: b });
        var g2 = getBlsG2(b);
        if (g2 === undefined)
            return new CEKError_1.CEKError("bls12_381_millerLoop :: second argument not G2 element", { g1: g1, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_millerLoop);
        this.machineBudget.add({
            mem: f.mem.at(BLS_G1_SIZE, BLS_G2_SIZE),
            cpu: f.cpu.at(BLS_G1_SIZE, BLS_G2_SIZE)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bls12_381_MlResult((0, crypto_1.bls12_381_millerLoop)(g1, g2));
        });
    };
    BnCEK.prototype.bls12_381_mulMlResult = function (a, b) {
        var res1 = getBlsResult(a);
        if (res1 === undefined)
            return new CEKError_1.CEKError("bls12_381_mulMlResult :: first argument not Bls result", { a: a, b: b });
        var res2 = getBlsResult(b);
        if (res2 === undefined)
            return new CEKError_1.CEKError("bls12_381_mulMlResult :: second argument not Bls result", { res1: res1, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_mulMlResult);
        this.machineBudget.add({
            mem: f.mem.at(BLS_ML_RESULT_SIZE, BLS_ML_RESULT_SIZE),
            cpu: f.cpu.at(BLS_ML_RESULT_SIZE, BLS_ML_RESULT_SIZE)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bls12_381_MlResult((0, crypto_1.bls12_381_mulMlResult)(res1, res2));
        });
    };
    BnCEK.prototype.bls12_381_finalVerify = function (a, b) {
        var res1 = getBlsResult(a);
        if (res1 === undefined)
            return new CEKError_1.CEKError("bls12_381_finalVerify :: first argument not Bls result", { a: a, b: b });
        var res2 = getBlsResult(b);
        if (res2 === undefined)
            return new CEKError_1.CEKError("bls12_381_finalVerify :: second argument not Bls result", { res1: res1, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.bls12_381_finalVerify);
        this.machineBudget.add({
            mem: f.mem.at(BLS_ML_RESULT_SIZE, BLS_ML_RESULT_SIZE),
            cpu: f.cpu.at(BLS_ML_RESULT_SIZE, BLS_ML_RESULT_SIZE)
        });
        return constOrErr(function () {
            return CEKConst_1.CEKConst.bool((0, crypto_1.bls12_381_finalVerify)(res1, res2));
        });
    };
    BnCEK.prototype.keccak_256 = function (a) {
        var b = getBS(a);
        if (b === undefined)
            return new CEKError_1.CEKError("keccak_256 :: not BS", { b: b, a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.keccak_256);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, crypto_1.keccak_256)(b.toBuffer()))); });
    };
    BnCEK.prototype.blake2b_224 = function (a) {
        var b = getBS(a);
        if (b === undefined)
            return new CEKError_1.CEKError("blake2b_224 :: not BS", { b: b, a: a });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.blake2b_224);
        var sb = bsToSize(b);
        this.machineBudget.add({
            mem: f.mem.at(sb),
            cpu: f.cpu.at(sb)
        });
        return constOrErr(function () { return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString((0, crypto_1.blake2b_224)(b.toBuffer()))); });
    };
    BnCEK.prototype.integerToByteString = function (a, b, c) {
        var bigEndian = getBool(a);
        if (bigEndian === undefined)
            return new CEKError_1.CEKError("integerToByteString :: first arg not boolean", { a: a, b: b, c: c });
        var size = getInt(b);
        if (size === undefined)
            return new CEKError_1.CEKError("integerToByteString :: second arg not integer", { bigEndian: bigEndian, b: b, c: c });
        var integer = getInt(c);
        if (integer === undefined)
            return new CEKError_1.CEKError("integerToByteString :: third arg not integer", { bigEndian: bigEndian, size: size, c: c });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.integerToByteString);
        var bSize = BOOL_SIZE;
        var nSize = intToSize(size);
        var nInt = intToSize(integer);
        this.machineBudget.add({
            mem: f.mem.at(bSize, nSize, nInt),
            cpu: f.cpu.at(bSize, nSize, nInt)
        });
        return integerToByteString(bigEndian, size, integer);
    };
    BnCEK.prototype.byteStringToInteger = function (a, b) {
        var bigEndian = getBool(a);
        if (bigEndian === undefined)
            return new CEKError_1.CEKError("byteStringToInteger :: first arg not boolean", { a: a, b: b });
        var bs = getBS(b);
        if (bs === undefined)
            return new CEKError_1.CEKError("integerToByteString :: second arg not bs", { bigEndian: bigEndian, b: b });
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.byteStringToInteger);
        var bSize = BOOL_SIZE;
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bSize, bsSize),
            cpu: f.cpu.at(bSize, bsSize)
        });
        return bytestringToInteger(bigEndian, bs);
    };
    BnCEK.prototype.andByteString = function (a, b, c) {
        var _c, _d;
        var shouldExtend = getBool(a);
        if (shouldExtend === undefined)
            return new CEKError_1.CEKError("andByteString :: first arg not boolean", { a: a, b: b, c: c });
        var bs1 = (_c = getBS(b)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs1 === undefined)
            return new CEKError_1.CEKError("andByteString :: second arg not bs", { shouldExtend: shouldExtend, b: b, c: c });
        var bs2 = (_d = getBS(c)) === null || _d === void 0 ? void 0 : _d.toBuffer();
        if (bs2 === undefined)
            return new CEKError_1.CEKError("andByteString :: third arg not bs", { shouldExtend: shouldExtend, b: b, c: c });
        var len = 0;
        if (shouldExtend) {
            len = Math.max(bs1.length, bs2.length);
            bs1 = bitwiseExtend(bs1, len, true);
            bs2 = bitwiseExtend(bs2, len, true);
        }
        else // should truncate
         {
            len = Math.min(bs1.length, bs2.length);
            bs1 = bitwiseTruncate(bs1, len);
            bs2 = bitwiseTruncate(bs2, len);
        }
        var result = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = bs1[i] & bs2[i];
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.andByteString);
        var shouldExtendSize = BOOL_SIZE;
        var bs1Size = bsToSize(bs1);
        var bs2Size = bsToSize(bs2);
        this.machineBudget.add({
            mem: f.mem.at(shouldExtendSize, bs1Size, bs2Size),
            cpu: f.cpu.at(shouldExtendSize, bs1Size, bs2Size)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    BnCEK.prototype.orByteString = function (a, b, c) {
        var _c, _d;
        var shouldExtend = getBool(a);
        if (shouldExtend === undefined)
            return new CEKError_1.CEKError("andByteString :: first arg not boolean", { a: a, b: b, c: c });
        var bs1 = (_c = getBS(b)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs1 === undefined)
            return new CEKError_1.CEKError("andByteString :: second arg not bs", { shouldExtend: shouldExtend, b: b, c: c });
        var bs2 = (_d = getBS(c)) === null || _d === void 0 ? void 0 : _d.toBuffer();
        if (bs2 === undefined)
            return new CEKError_1.CEKError("andByteString :: third arg not bs", { shouldExtend: shouldExtend, b: b, c: c });
        var len = 0;
        if (shouldExtend) {
            len = Math.max(bs1.length, bs2.length);
            bs1 = bitwiseExtend(bs1, len, false);
            bs2 = bitwiseExtend(bs2, len, false);
        }
        else // should truncate
         {
            len = Math.min(bs1.length, bs2.length);
            bs1 = bitwiseTruncate(bs1, len);
            bs2 = bitwiseTruncate(bs2, len);
        }
        var result = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = bs1[i] | bs2[i];
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.orByteString);
        var shouldExtendSize = BOOL_SIZE;
        var bs1Size = bsToSize(bs1);
        var bs2Size = bsToSize(bs2);
        this.machineBudget.add({
            mem: f.mem.at(shouldExtendSize, bs1Size, bs2Size),
            cpu: f.cpu.at(shouldExtendSize, bs1Size, bs2Size)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    BnCEK.prototype.xorByteString = function (a, b, c) {
        var _c, _d;
        var shouldExtend = getBool(a);
        if (shouldExtend === undefined)
            return new CEKError_1.CEKError("andByteString :: first arg not boolean", { a: a, b: b, c: c });
        var bs1 = (_c = getBS(b)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs1 === undefined)
            return new CEKError_1.CEKError("andByteString :: second arg not bs", { shouldExtend: shouldExtend, b: b, c: c });
        var bs2 = (_d = getBS(c)) === null || _d === void 0 ? void 0 : _d.toBuffer();
        if (bs2 === undefined)
            return new CEKError_1.CEKError("andByteString :: third arg not bs", { shouldExtend: shouldExtend, b: b, c: c });
        var len = 0;
        if (shouldExtend) {
            len = Math.max(bs1.length, bs2.length);
            bs1 = bitwiseExtend(bs1, len, true);
            bs2 = bitwiseExtend(bs2, len, true);
        }
        else // should truncate
         {
            len = Math.min(bs1.length, bs2.length);
            bs1 = bitwiseTruncate(bs1, len);
            bs2 = bitwiseTruncate(bs2, len);
        }
        var result = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = bs1[i] ^ bs2[i];
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.xorByteString);
        var shouldExtendSize = BOOL_SIZE;
        var bs1Size = bsToSize(bs1);
        var bs2Size = bsToSize(bs2);
        this.machineBudget.add({
            mem: f.mem.at(shouldExtendSize, bs1Size, bs2Size),
            cpu: f.cpu.at(shouldExtendSize, bs1Size, bs2Size)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    BnCEK.prototype.complementByteString = function (_bs) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("complementByteString :: not bs", { _bs: _bs });
        var len = bs.length;
        var result = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = ~bs[i];
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.complementByteString);
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bsSize),
            cpu: f.cpu.at(bsSize)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    // can fail
    BnCEK.prototype.readBit = function (_bs, _i) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("readBit :: not bs", { _bs: _bs, _i: _i });
        var i = getInt(_i);
        if (i === undefined)
            return new CEKError_1.CEKError("readBit :: not integer", { bs: bs, _i: _i });
        var result = (0, readBit_1.readBit)(bs, Number(i));
        if (result instanceof CEKError_1.CEKError)
            return result;
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.readBit);
        var bsSize = bsToSize(bs);
        var iSize = intToSize(i);
        this.machineBudget.add({
            mem: f.mem.at(bsSize, iSize),
            cpu: f.cpu.at(bsSize, iSize)
        });
        return CEKConst_1.CEKConst.bool(result);
    };
    // can fail
    BnCEK.prototype.writeBits = function (_bs, _idxs, _bit) {
        var e_1, _c;
        var _d;
        var bs = (_d = getBS(_bs)) === null || _d === void 0 ? void 0 : _d.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("writeBits :: not bs", { _bs: _bs, _idxs: _idxs, _bit: _bit });
        var idxs = getList(_idxs);
        if (idxs === undefined)
            return new CEKError_1.CEKError("writeBits :: second arg not a list", { bs: bs, _idxs: _idxs, _bit: _bit });
        var bit = getBool(_bit);
        if (bit === undefined)
            return new CEKError_1.CEKError("writeBits :: not boolean", { bs: bs, idxs: idxs, _bit: _bit });
        var result = Uint8Array.prototype.slice.call(bs);
        var elemIdx = 0;
        try {
            for (var idxs_1 = __values(idxs), idxs_1_1 = idxs_1.next(); !idxs_1_1.done; idxs_1_1 = idxs_1.next()) {
                var elem = idxs_1_1.value;
                var i = getIntNumFromConstValue(elem);
                if (i === undefined)
                    return new CEKError_1.CEKError("writeBits :: list element not integer", { bs: bs, idxs: idxs, elem: elem, elemIdx: elemIdx });
                var res = (0, writeBit_1.writeBit)(result, i, bit);
                if (res instanceof CEKError_1.CEKError)
                    return res;
                elemIdx++;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (idxs_1_1 && !idxs_1_1.done && (_c = idxs_1.return)) _c.call(idxs_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.writeBits);
        var bsSize = bsToSize(bs);
        var idxsSize = listToSize(idxs);
        var bitSize = BOOL_SIZE;
        this.machineBudget.add({
            mem: f.mem.at(bsSize, idxsSize, bitSize),
            cpu: f.cpu.at(bsSize, idxsSize, bitSize)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    // can fail
    BnCEK.prototype.replicateByte = function (_len, _byte) {
        var len = getInt(_len);
        if (len === undefined)
            return new CEKError_1.CEKError("replicateByte :: first arg not integer", { _len: _len, _byte: _byte });
        var byte = getInt(_byte);
        if (byte === undefined)
            return new CEKError_1.CEKError("replicateByte :: second arg not integer", { len: len, _byte: _byte });
        if (len < 0 || len > BYTESTRING_LIMIT_LEN_N)
            return new CEKError_1.CEKError("replicateByte :: invalid length", { len: len, byte: byte });
        if (byte < 0 || byte > 255)
            return new CEKError_1.CEKError("replicateByte :: invalid byte", { len: len, byte: byte });
        var result = new Uint8Array(Number(len)).fill(Number(byte));
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.replicateByte);
        var lenSize = intToSize(len);
        var byteSize = intToSize(byte);
        this.machineBudget.add({
            mem: f.mem.at(lenSize, byteSize),
            cpu: f.cpu.at(lenSize, byteSize)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    BnCEK.prototype.shiftByteString = function (_bs, _k) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("shiftByteString :: not bs", { _bs: _bs });
        var k = getInt(_k);
        if (k === undefined)
            return new CEKError_1.CEKError("shiftByteString :: not integer", { bs: bs, _k: _k });
        var result = (0, shiftU8Arr_1.shiftU8Arr)(bs, Number(k));
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.shiftByteString);
        var bsSize = bsToSize(bs);
        var kSize = intToSize(k);
        this.machineBudget.add({
            mem: f.mem.at(bsSize, kSize),
            cpu: f.cpu.at(bsSize, kSize)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    BnCEK.prototype.rotateByteString = function (_bs, _k) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("shiftByteString :: not bs", { _bs: _bs });
        var k = getInt(_k);
        if (k === undefined)
            return new CEKError_1.CEKError("shiftByteString :: not integer", { bs: bs, _k: _k });
        var result = (0, rotateU8Arr_1.rotateU8Arr)(bs, Number(k));
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.rotateByteString);
        var bsSize = bsToSize(bs);
        var kSize = intToSize(k);
        this.machineBudget.add({
            mem: f.mem.at(bsSize, kSize),
            cpu: f.cpu.at(bsSize, kSize)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    BnCEK.prototype.countSetBits = function (_bs) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("countSetBits :: not bs", { _bs: _bs });
        var result = (0, countSetBits_1.countSetBits)(bs);
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.countSetBits);
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bsSize),
            cpu: f.cpu.at(bsSize)
        });
        return CEKConst_1.CEKConst.int(result);
    };
    BnCEK.prototype.findFirstSetBit = function (_bs) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("findFirstSetBit :: not bs", { _bs: _bs });
        var result = (0, findFirstSetBit_1.findFirstSetBit)(bs);
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.findFirstSetBit);
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bsSize),
            cpu: f.cpu.at(bsSize)
        });
        return CEKConst_1.CEKConst.int(result);
    };
    BnCEK.prototype.ripemd_160 = function (_bs) {
        var _c;
        var bs = (_c = getBS(_bs)) === null || _c === void 0 ? void 0 : _c.toBuffer();
        if (bs === undefined)
            return new CEKError_1.CEKError("ripemd_160 :: not bs", { _bs: _bs });
        var result = (0, crypto_1.ripemd160)(bs);
        var f = this.getBuiltinCostFunc(uplc_1.UPLCBuiltinTag.ripemd_160);
        var bsSize = bsToSize(bs);
        this.machineBudget.add({
            mem: f.mem.at(bsSize),
            cpu: f.cpu.at(bsSize)
        });
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(result));
    };
    return BnCEK;
}());
exports.BnCEK = BnCEK;
var BYTESTRING_LIMIT_LEN_N = 8192;
var INTEGER_TO_BYTE_STRING_MAXIMUM_OUTPUT_LENGTH = BigInt(BYTESTRING_LIMIT_LEN_N);
var _0n = BigInt(0);
var _8n = BigInt(8);
var _1n = BigInt(1);
function integerToByteString(bigEndian, size, integer) {
    if (size < 0)
        return new CEKError_1.CEKError("integerToByteString :: size must be positive");
    if (size > INTEGER_TO_BYTE_STRING_MAXIMUM_OUTPUT_LENGTH)
        return new CEKError_1.CEKError("integerToByteString :: size must NOT exceed " +
            INTEGER_TO_BYTE_STRING_MAXIMUM_OUTPUT_LENGTH +
            "; received " + size, { bigEndian: bigEndian, size: size, integer: integer });
    if (size === _0n &&
        ilog2(integer) > (_8n * INTEGER_TO_BYTE_STRING_MAXIMUM_OUTPUT_LENGTH))
        return new CEKError_1.CEKError("integerToByteString :: required minimum size for integer is " +
            (ilog2(integer) / _8n + _1n) +
            "; while max possible size is " +
            INTEGER_TO_BYTE_STRING_MAXIMUM_OUTPUT_LENGTH, { bigEndian: bigEndian, size: size, integer: integer });
    if (integer < _0n)
        return new CEKError_1.CEKError("integerToByteString :: only positive integers accepted", { bigEndian: bigEndian, size: size, integer: integer });
    var nsize = Number(size);
    if (integer === _0n)
        return CEKConst_1.CEKConst.byteString(new bytestring_1.ByteString(new Uint8Array(nsize)));
    var bytes = new bytestring_1.ByteString(integer.toString(16)
        // already pad to size
        // if integer is already bigger (or equal) than size this has no effect
        .padStart(nsize * 2, "0"));
    var bytesLen = bytes.toBuffer().length;
    bytes = bigEndian ? bytes : new bytestring_1.ByteString(bytes.toBuffer().reverse());
    if (nsize !== 0 && bytesLen > nsize)
        return new CEKError_1.CEKError("integerToByteString :: integer requires more bytes than specified; required: " + bytesLen, { bigEndian: bigEndian, size: size, integer: integer });
    if (bytesLen > 8192)
        return new CEKError_1.CEKError("integerToByteString ::input integer too big, max allowed byte size is 8192", { bigEndian: bigEndian, size: size, integer: integer });
    return CEKConst_1.CEKConst.byteString(bytes);
}
function ilog2(i) {
    return BigInt(i.toString(2).length - 1);
}
function bytestringToInteger(bigEndian, bs) {
    var bytes = bs.toBuffer();
    bytes = bigEndian ? bytes : bytes.reverse();
    if (bytes.length === 0)
        return CEKConst_1.CEKConst.int(0);
    return CEKConst_1.CEKConst.int(BigInt("0x" + (0, uint8array_utils_1.toHex)(bytes)));
}
function isValidUtf8(bytes) {
    if (!(globalThis.TextDecoder))
        return true;
    var decoder = new TextDecoder("utf8", { fatal: true });
    try {
        decoder.decode(bytes);
    }
    catch (_c) {
        return false;
    }
    return true;
}
function bitwiseTruncate(bs, len) {
    if (bs.length <= len)
        return bs;
    return bs.slice(0, len);
}
function bitwiseExtend(bs, len, fill) {
    if (bs.length >= len)
        return bs;
    var newBs = new Uint8Array(len);
    newBs.set(bs);
    if (fill)
        newBs.fill(0xff, bs.length, len);
    return newBs;
}
