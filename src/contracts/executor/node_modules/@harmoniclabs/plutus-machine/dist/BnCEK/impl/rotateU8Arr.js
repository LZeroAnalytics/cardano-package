"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rotateU8Arr = void 0;
function rotateU8Arr(bytes, k) {
    // Create a copy of the input array to avoid modifying the original
    var result = Uint8Array.prototype.slice.call(bytes);
    // Convert to left rotation amount within the range of total bits
    var totalBits = bytes.length * 8;
    // If k is negative, convert to equivalent left rotation
    if (k < 0) {
        k = totalBits - ((-k) % totalBits);
    }
    else {
        k = k % totalBits;
    }
    // No rotation needed
    if (k === 0)
        return result;
    // Calculate full byte rotations and remaining bits
    var byteRotations = Math.floor(k / 8);
    var bitRotations = k % 8;
    // First handle byte-wise rotations
    if (byteRotations > 0) {
        var temp = result.slice(); // Save original array
        for (var i = 0; i < bytes.length; i++) {
            var newIndex = (i + byteRotations) % bytes.length;
            result[newIndex] = temp[i];
        }
    }
    // Then handle remaining bits
    if (bitRotations > 0) {
        var lastBits = result[result.length - 1] >> (8 - bitRotations);
        // Rotate each byte
        for (var i = result.length - 1; i > 0; i--) {
            result[i] = ((result[i] << bitRotations) & 0xFF) |
                (result[i - 1] >> (8 - bitRotations));
        }
        // Handle first byte - combine with saved bits from the last byte
        result[0] = ((result[0] << bitRotations) & 0xFF) | lastBits;
    }
    return result;
}
exports.rotateU8Arr = rotateU8Arr;
