import type { ITxRunnerProvider } from "../IProvider/index.js";
import type { TxBuilder } from "../TxBuilder.js";
import { NormalizedITxBuildArgs } from "../../txBuild/index.js";
import { Address, AddressStr, Hash28, ITxOut, ITxOutRef, IUTxO, IValuePolicyEntry, PlutusScriptType, Script, ScriptType, StakeAddress, StakeAddressBech32, Credential, Tx, TxIn, TxMetadatum, TxOutRefStr, UTxO, Value, IPoolParams, CanBeHash28, Vote, IAnchor, IVoter, ProtocolParameters, IProposalProcedure, ITxWithdrawals, TxWithdrawals, INewCommitteeEntry, IConstitution } from "@harmoniclabs/cardano-ledger-ts";
import { CanBeUInteger } from "../../utils/ints.js";
import { CanResolveToUTxO } from "../CanResolveToUTxO/CanResolveToUTxO.js";
import { CanBeData } from "../../utils/CanBeData.js";
import { CanBePoolKeyHash } from "./CanBePoolKeyHash.js";
import { CanBeStakeCreds } from "./CanBeStakeCreds.js";
import { IProtocolVerision } from "@harmoniclabs/cardano-ledger-ts/dist/ledger/protocol/protocolVersion";
import { Rational } from "../../utils/Rational.js";
declare const enum TxBuilderTaskKind {
    ResolveUTxO = 0,
    ResolveTxIn = 1,
    ValidFromPOSIX = 2,
    ValidToPOSIX = 3,
    DelegateTo = 4,
    DeregisterStake = 5,
    Withdraw = 6,
    RegisterStake = 7
}
/** async */
interface TxBuilderPromiseTask {
    kind: TxBuilderTaskKind;
    getPromise: () => Promise<void>;
}
interface TxBuilderResolveUTxOTask {
    kind: TxBuilderTaskKind.ResolveUTxO;
    arg: ITxOutRef | TxOutRefStr | IUTxO;
    onResolved: (utxo: UTxO) => void;
}
interface TxBuilderResolveTxInTask {
    kind: TxBuilderTaskKind.ResolveTxIn;
    arg: ITxOutRef | TxOutRefStr | IUTxO;
    onResolved: (utxo: TxIn) => void;
}
type TxBuilderTask = TxBuilderPromiseTask | TxBuilderResolveUTxOTask | TxBuilderResolveTxInTask;
export declare class TxBuilderRunner {
    /**
     *  if any unresolved data was passed it is resolved via the provider passed;
     *
     *  if the method needed are not present on the provider throws an `Error`;
     *
     *  finalizes the `TxBuilderRunner` instance,
     *  so that it can be re-used for other transactions,
     *
     *  @returns {Promise<Tx>} a `Tx` instance
     */
    readonly build: () => Promise<Tx>;
    /**
     * clears the `TxBuilderRunner` instance,
     * so that it can be re-used for other transactions,
     * making sure no other action where specified
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly reset: () => TxBuilderRunner;
    /**
     * @deprecated use `addRequiredSigner` instead
     */
    readonly addSigner: (signer: Address | StakeAddress | AddressStr | StakeAddressBech32) => TxBuilderRunner;
    /**
     * adds the **all** credentials of the address to the `requiredSigners`
     * field of a `Tx` instance.
     *
     * only the signers included in that field are passed to a contract's `ScriptContext`.
     *
     * that includes payment credentials and, if present, stake credentials.
     *
     * if you have an address with both payment and stake credentials,
     * but wish only to include one of them,
     * consider using  the `addRequiredSignerKey` method
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly addRequiredSigner: (signer: Address | StakeAddress | AddressStr | StakeAddressBech32) => TxBuilderRunner;
    /**
     * @deprecated use `addRequiredSignerKey` instead
     */
    readonly addSignerKey: (signerKey: Hash28) => TxBuilderRunner;
    /**
     * adds the given key hash to the `requiredSigners` field of a `Tx` instance.
     *
     * only the signers included in that field are passed to a contract's `ScriptContext`.
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly addRequiredSignerKey: (signerKey: Hash28) => TxBuilderRunner;
    /** adds a metadata message according to cip 20 */
    readonly attachMemo: (memo: string) => TxBuilderRunner;
    /** alias for `attachValidator` */
    readonly attachCertificateValidator: (validator: Script<PlutusScriptType>) => TxBuilderRunner;
    /** alias for `attachValidator` */
    readonly attachMintingValidator: (validator: Script<PlutusScriptType>) => TxBuilderRunner;
    /** alias for `attachValidator` */
    readonly attachSpendingValidator: (validator: Script<PlutusScriptType>) => TxBuilderRunner;
    /** alias for `attachValidator` */
    readonly attachWithdrawalValidator: (validator: Script<PlutusScriptType>) => TxBuilderRunner;
    /**
     * includes the script in the witnessSet field of the resulting `Tx`
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly attachValidator: (validator: Script<PlutusScriptType>) => TxBuilderRunner;
    /**
     * adds a metadata entry for the given `label`,
     * or overrides if the same `label` was already present.
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly attachMetadata: (label: CanBeUInteger, metadata: TxMetadatum) => TxBuilderRunner;
    /**
     * alias for `attachMetadata`
     *
     * adds a metadata entry for the given `label`,
     * or overrides if the same `label` was already present.
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly setMetadata: (label: CanBeUInteger, metadata: TxMetadatum) => TxBuilderRunner;
    /**
     * like [`attachMetadata`](./attachMetadata),
     * adds a metadata entry for the given `label`,
     * or overrides if the same `label` was already present.
     *
     * `metadataJson` is a jsavascript value converted as follows
     *
     * - `object` -> `TxMetadatumMap`
     * - `array` -> `TxMetadatumList`
     * - `string` -> `TxMetadatumText`
     * (use `attachMetadataJsonWithConversion`
     * for explicit conversion to `TxMetadatumBytes`
     * or consider using `attachMetadata`)
     * - `number` -> `TxMetadatumInt`
     * - `bigint` -> `TxMetadatumInt`
     *
     * @returns a reference to the same [`TxBuilderRunner`](./TxBuilderRunner).
     */
    readonly attachMetadataJson: (label: CanBeUInteger, metadataJson: any) => TxBuilderRunner;
    /** like `attachMetadataJson` but if a string starts with `0x` is treated as an hexadecimal byte string */
    readonly attachMetadataJsonWithConversion: (label: CanBeUInteger, metadataJson: any) => TxBuilderRunner;
    /**
     * explicitly sets the change address;
     *
     * if missing, an attempt to call the `ITxRunnerProvider` `getChangeAddress` method is done
     *
     * if still missing the first input's address with `PubKeyHash`
     * payment credentials (not script) will be used
     *
     * if all the above fail, a call to the `build` method will throw an `Error`.
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly setChangeAddress: (changeAddr: Address | AddressStr) => TxBuilderRunner;
    /**
     * Sets the collateral input, and optionally output, for a transaction.
     *
     * If this method is not used,
     * but the transaction needs collateral due to the presence of a plutus script,
     * the `TxBuilderRunner` instance will try to use one of the normal inputs as collateral,
     * see `setCollateralAmount`./setCollateralAmount for more infos.
     *
     * `collateral` can either be a resolved `UTxO`
     * or an unresolved `ITxOutRef`
     *
     * in case it is an unresolved `ITxOutRef`
     * a call to the `ITxRunnerProvider` `resolveUtxos` method
     * is done in the `build` method;
     * if `resolveUtxos` is missing on the provider the `build` method will throw an `Error`.
     *
     * an additional `collateralOutput` may be specified.
     *
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly setCollateral: (collateral: CanResolveToUTxO, collateralOutput?: ITxOut) => TxBuilderRunner;
    /**
     * Sets the collateral amount for a transaction.
     *
     * If `setCollateral` is not used,
     * but the transaction needs collateral due to the presence of a plutus script,
     * the `TxBuilderRunner` instance will try to use one of the normal inputs as collateral.
     *
     * In case this happens, it is possible to limit the amount of the collateral using this method.
     *
     * @returns a reference to the same `TxBuilderRunner`.
    **/
    readonly setCollateralAmount: (lovelaces: CanBeUInteger) => TxBuilderRunner;
    /**
     * @deprecated `collectFrom` is unclear; use `addInputs` instead.
     */
    readonly collectFrom: (utxos: CanResolveToUTxO[], redeemer?: CanBeData) => TxBuilderRunner;
    /**
     * adds the given `utxos` to the transaction inputs;
     * the elements of the array that don't satisfy the `IUTxO` interface
     * will be resolved using the provider `resolveUtxos` method.
     *
     * this method does not allow to specify plutus realated arguments.
     *
     * for inputs that need redeemers, scripts and datums use `addInput`.
     *
     * @returns a reference to the same `TxBuilderRunner`.
    **/
    readonly addInputs: (utxos: CanResolveToUTxO[]) => TxBuilderRunner;
    /**
     * adds the given `utxo` to the transaction inputs;
     * if`utxo` doesn't satisfy the `IUTxO` interface
     * it will be resolved using the provider `resolveUtxos` method.
     *
     * `redeemer` and `script_or_ref` must be specified together;
     * if `datum` is missing defaults to `"inline"`.
     *
     * if `script_or_ref` is a `Script`
     * it will be included in the `witnesses`
     * field of the resulting `Tx`;
     *
     * if `script_or_ref` satisfies the `IUTxO` interface
     * it will be used as reference input to provide the attached reference script
     * (`build` fails if missing)
     *
     * if `script_or_ref` satisfies the `ITxOutRef` interface
     * or the `TxOutRefStr` type alias
     * it will be resolved using the provider `resolveUtxos` method and
     * it will be used as reference input to provide the attached reference script
     * (`build` fails if missing)
     *
     * @returns a reference to the same `TxBuilderRunner`.
    **/
    readonly addInput: (utxos: CanResolveToUTxO, redeemer?: CanBeData, script_or_ref?: CanResolveToUTxO | Script<PlutusScriptType>, datum?: CanBeData | "inline") => TxBuilderRunner;
    /**
     * adds a transaction output.
     *
     * if `amount` is `number` or `bigint` it is intended to be lovelaces only.
     *
     * if `datum` is present is always added as inline datum.
     *
     * @param address receiver address
     * @param amount Value to sent
     * @param datum optional inline datum to attach
     * @param refScript optional reference script to attach
     * @returns a reference to the same `TxBuilderRunner`.
     */
    readonly payTo: (address: Address | AddressStr, amount: CanBeUInteger | Value, datum?: CanBeData, refScript?: Script<ScriptType.PlutusV2>) => TxBuilderRunner;
    readonly mintAssets: (assets: IValuePolicyEntry, script_or_ref: Script | CanResolveToUTxO, redeemer?: CanBeData) => TxBuilderRunner;
    readonly withdraw: (stakeAddress: CanBeStakeCreds, amount: CanBeUInteger, redeemer?: CanBeData, script_or_ref?: Script | CanResolveToUTxO) => TxBuilderRunner;
    readonly delegateTo: (delegator: CanBeStakeCreds, poolId: CanBePoolKeyHash, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly registerPool: (params: IPoolParams) => TxBuilderRunner;
    readonly retirePool: (poolId: CanBeHash28, epoch: CanBeUInteger) => TxBuilderRunner;
    readonly registerStake: (delegator: CanBeStakeCreds, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly registerStakeAddress: (delegator: CanBeStakeCreds, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly deregisterStake: (delegator: CanBeStakeCreds, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    /**
     * @deprecated `readFrom` is an ugly name; use `referenceUtxos` instead
     */
    readonly readFrom: (utxos: CanResolveToUTxO[]) => TxBuilderRunner;
    readonly referenceUtxos: (utxos: CanResolveToUTxO[]) => TxBuilderRunner;
    readonly validFrom: (POSIX: CanBeUInteger) => TxBuilderRunner;
    readonly validFromSlot: (slot: CanBeUInteger) => TxBuilderRunner;
    readonly invalidBeforeSlot: (slot: CanBeUInteger) => TxBuilderRunner;
    readonly validTo: (POSIX: CanBeUInteger) => TxBuilderRunner;
    readonly validToSlot: (slot: CanBeUInteger) => TxBuilderRunner;
    readonly invalidAfterSlot: (slot: CanBeUInteger) => TxBuilderRunner;
    readonly vote: (voter: IVoter, governanceActionId: ITxOutRef | TxOutRefStr, vote: Vote, anchor?: IAnchor | undefined, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly voteDRep: (drepKeyHash: CanBeHash28, governanceActionId: ITxOutRef | TxOutRefStr, vote: Vote, anchor?: IAnchor | undefined) => TxBuilderRunner;
    readonly voteScriptDRep: (drepScriptHash: CanBeHash28, governanceActionId: ITxOutRef | TxOutRefStr, vote: Vote, anchor?: IAnchor | undefined, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly voteConstitutionalComittee: (memberKeyHash: CanBeHash28, governanceActionId: ITxOutRef | TxOutRefStr, vote: Vote, anchor?: IAnchor | undefined) => TxBuilderRunner;
    readonly voteScriptConstitutionalComittee: (memberScriptHash: CanBeHash28, governanceActionId: ITxOutRef | TxOutRefStr, vote: Vote, anchor?: IAnchor | undefined, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly voteStakePool: (poolId: CanBeHash28, governanceActionId: ITxOutRef | TxOutRefStr, vote: Vote, anchor?: IAnchor | undefined) => TxBuilderRunner;
    readonly propose: (proposal: IProposalProcedure, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeParametersChanges: (changes: Partial<ProtocolParameters>, procedureInfos: Omit<IProposalProcedure, "govAction">, govActionId?: ITxOutRef | TxOutRefStr, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeHardForkInitiation: (nextProtocolVersion: IProtocolVerision, procedureInfos: Omit<IProposalProcedure, "govAction">, govActionId?: ITxOutRef | TxOutRefStr, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeTreasuryWithdrawal: (withdrawals: ITxWithdrawals | TxWithdrawals, procedureInfos: Omit<IProposalProcedure, "govAction">, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeNoConfidence: (procedureInfos: Omit<IProposalProcedure, "govAction">, govActionId?: ITxOutRef | TxOutRefStr, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeComitteeUpdate: (toRemove: Credential[], toAdd: INewCommitteeEntry[], threshold: Rational, procedureInfos: Omit<IProposalProcedure, "govAction">, govActionId?: ITxOutRef | TxOutRefStr, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeNewConstitution: (constitution: IConstitution, procedureInfos: Omit<IProposalProcedure, "govAction">, govActionId?: ITxOutRef | TxOutRefStr, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly proposeInfos: (procedureInfos: Omit<IProposalProcedure, "govAction">, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner;
    readonly tasks: TxBuilderTask[];
    readonly buildArgs: NormalizedITxBuildArgs;
    constructor(txBuilder: TxBuilder, provider: Partial<ITxRunnerProvider>);
}
export {};
