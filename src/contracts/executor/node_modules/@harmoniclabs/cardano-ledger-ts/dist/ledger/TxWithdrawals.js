"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forceTxWithdrawals = exports.canBeTxWithdrawals = exports.TxWithdrawals = exports.isITxWithdrawals = exports.isTxWithdrawalsMap = void 0;
var StakeAddress_1 = require("./StakeAddress.js");
var cbor_1 = require("@harmoniclabs/cbor");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var hashes_1 = require("../hashes/index.js");
var ints_1 = require("../utils/ints.js");
var Value_1 = require("./Value/index.js");
var assert_1 = require("../utils/assert.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
function isTxWithdrawalsMap(stuff) {
    if (!Array.isArray(stuff))
        return false;
    return stuff.every(function (_a) {
        var rewardAccount = _a.rewardAccount, amount = _a.amount;
        return ((0, hashes_1.canBeHash28)(rewardAccount) ||
            rewardAccount instanceof StakeAddress_1.StakeAddress) &&
            (0, ints_1.canBeUInteger)(amount);
    });
}
exports.isTxWithdrawalsMap = isTxWithdrawalsMap;
function isITxWithdrawals(stuff) {
    if (typeof stuff !== "object")
        return false;
    if (Array.isArray(stuff))
        return isTxWithdrawalsMap(stuff);
    var ks = Object.keys(stuff);
    return ks.every(function (k) {
        try {
            void StakeAddress_1.StakeAddress.fromString(k);
            return (0, ints_1.canBeUInteger)(stuff[k]);
        }
        catch (_a) {
            return false;
        }
    });
}
exports.isITxWithdrawals = isITxWithdrawals;
var TxWithdrawals = /** @class */ (function () {
    function TxWithdrawals(map, subCborRef, network) {
        if (network === void 0) { network = "mainnet"; }
        this.subCborRef = subCborRef;
        (0, assert_1.assert)(isITxWithdrawals(map), "invalid 'ITxWithdrawalsMap' passed to construct a 'TxWithdrawals'");
        if (Array.isArray(map)) {
            var _map = map.map(function (entry) { return ({
                rewardAccount: entry.rewardAccount instanceof StakeAddress_1.StakeAddress ?
                    entry.rewardAccount.clone() :
                    new StakeAddress_1.StakeAddress(network, new hashes_1.Hash28(entry.rewardAccount)),
                amount: (0, ints_1.forceBigUInt)(entry.amount)
            }); });
            (0, obj_utils_1.defineReadOnlyProperty)(this, "map", Object.freeze(_map));
        }
        else {
            (0, assert_1.assert)(typeof map === "object", "invalid object passed as 'ITxWithdrawalsMap' to construct a 'TxWithdrawals'");
            (0, obj_utils_1.defineReadOnlyProperty)(this, "map", Object.freeze(Object.keys(map)
                .map(function (rewAccount) { return Object.freeze({
                rewardAccount: StakeAddress_1.StakeAddress.fromString(rewAccount),
                amount: (0, ints_1.forceBigUInt)(map[rewAccount])
            }); })));
        }
    }
    TxWithdrawals.prototype.toTotalWitdrawn = function () {
        return Value_1.Value.lovelaces(this.map
            .reduce(function (a, b) { return a + b.amount; }, BigInt(0)));
    };
    TxWithdrawals.prototype.toData = function (version) {
        return new plutus_data_1.DataMap(this.map
            .map(function (_a) {
            var rewardAccount = _a.rewardAccount, amount = _a.amount;
            return new plutus_data_1.DataPair(rewardAccount.toStakeCredentials().toData(version), new plutus_data_1.DataI(amount));
        }));
    };
    TxWithdrawals.prototype.toCbor = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.subCborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    TxWithdrawals.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        return new cbor_1.CborMap(this.map.map(function (entry) {
            return {
                k: entry.rewardAccount.toCborObj(),
                v: new cbor_1.CborUInt(entry.amount)
            };
        }));
    };
    TxWithdrawals.fromCbor = function (cStr) {
        return TxWithdrawals.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr), { keepRef: true }));
    };
    TxWithdrawals.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborMap))
            throw new Error("Invalid CBOR fromat for \"TxWithdrawals\"");
        return new TxWithdrawals(cObj.map.map(function (_a) {
            var k = _a.k, v = _a.v;
            if (!(v instanceof cbor_1.CborUInt))
                throw new Error("Invalid CBOR fromat for \"TxWithdrawals\"");
            return {
                rewardAccount: StakeAddress_1.StakeAddress.fromCborObj(k),
                amount: v.num
            };
        }), (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    TxWithdrawals.prototype.toJSON = function () { return this.toJson(); };
    TxWithdrawals.prototype.toJson = function () {
        var e_1, _a;
        var json = {};
        try {
            for (var _b = __values(this.map), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = _c.value, rewardAccount = _d.rewardAccount, amount = _d.amount;
                (0, obj_utils_1.defineReadOnlyProperty)(json, rewardAccount.toString(), amount.toString());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return json;
    };
    TxWithdrawals.fromJson = function (json) {
        var keys = Object.keys(json);
        if (keys.length === 0)
            return new TxWithdrawals({});
        var network = StakeAddress_1.StakeAddress.fromString(keys[0]).network;
        return new TxWithdrawals(keys.map(function (k) { return ({
            rewardAccount: StakeAddress_1.StakeAddress.fromString(k),
            amount: BigInt(json[k])
        }); }), undefined, network);
    };
    return TxWithdrawals;
}());
exports.TxWithdrawals = TxWithdrawals;
function canBeTxWithdrawals(stuff) {
    return (stuff instanceof TxWithdrawals) || isITxWithdrawals(stuff);
}
exports.canBeTxWithdrawals = canBeTxWithdrawals;
function forceTxWithdrawals(stuff) {
    if (stuff instanceof TxWithdrawals)
        return stuff;
    return new TxWithdrawals(stuff);
}
exports.forceTxWithdrawals = forceTxWithdrawals;
