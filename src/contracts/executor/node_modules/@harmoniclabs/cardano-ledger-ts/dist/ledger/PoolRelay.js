"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.poolRelayFromCborObj = exports.poolRelayToCborObj = exports.isPoolRelay = exports.isMultiHostPoolRelay = exports.isDnsPoolRelay = exports.isIpPoolRelay = exports.poolRelayToJson = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var ints_1 = require("../utils/ints.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../utils/assert.js");
function poolRelayToJson(relay) {
    var type = relay.type;
    switch (type) {
        case "ip":
            var ipv4 = relay.ipv4 === undefined ? undefined : relay.ipv4;
            var ipv6 = relay.ipv6 === undefined ? undefined : relay.ipv6;
            return {
                type: "ip",
                port: relay.port === undefined ? undefined : Number((0, ints_1.forceBigUInt)(relay.port)),
                ipv4: ipv4 === undefined ? undefined : "".concat((0, uint8array_utils_1.readUInt8)(ipv4, 0), ".").concat((0, uint8array_utils_1.readUInt8)(ipv4, 1), ".").concat((0, uint8array_utils_1.readUInt8)(ipv4, 2), ".").concat((0, uint8array_utils_1.readUInt8)(ipv4, 3)),
                ipv6: ipv6 === undefined ? undefined :
                    [
                        (0, uint8array_utils_1.readUInt16BE)(ipv6, 0).toString(16),
                        (0, uint8array_utils_1.readUInt16BE)(ipv6, 2).toString(16),
                        (0, uint8array_utils_1.readUInt16BE)(ipv6, 4).toString(16),
                        (0, uint8array_utils_1.readUInt16BE)(ipv6, 6).toString(16),
                        (0, uint8array_utils_1.readUInt16BE)(ipv6, 8).toString(16),
                        (0, uint8array_utils_1.readUInt16BE)(ipv6, 10).toString(16)
                    ].join(':')
            };
        case "dns":
            return {
                type: "dns",
                port: relay.port === undefined ? undefined : Number((0, ints_1.forceBigUInt)(relay.port)),
                dnsName: relay.dnsName
            };
        case "multi-host":
            return {
                type: "multi-host",
                dnsName: relay.dnsName
            };
        default:
            throw new Error("unknown pool realy type");
    }
}
exports.poolRelayToJson = poolRelayToJson;
function minimumPoolRelayCheck(something) {
    return ((0, obj_utils_1.isObject)(something) &&
        (0, obj_utils_1.hasOwn)(something, "type"));
}
function portCheck(something) {
    return (something.port === undefined ||
        (0, ints_1.canBeUInteger)(something.port));
}
function isIpPoolRelay(something) {
    var _a = something, ipv4 = _a.ipv4, ipv6 = _a.ipv6;
    return (minimumPoolRelayCheck(something) &&
        something.type === "ip" &&
        (((0, obj_utils_1.hasOwn)(something, "ipv4") && (0, uint8array_utils_1.isUint8Array)(ipv4)) ||
            ((0, obj_utils_1.hasOwn)(something, "ipv6") && (0, uint8array_utils_1.isUint8Array)(ipv6))) &&
        (ipv4 === undefined || ipv4.length === 4) &&
        (ipv6 === undefined || ipv6.length === 16) &&
        portCheck(something));
}
exports.isIpPoolRelay = isIpPoolRelay;
function isDnsPoolRelay(something) {
    return (minimumPoolRelayCheck(something) &&
        something.type === "dns" &&
        (0, obj_utils_1.hasOwn)(something, "dnsName") &&
        typeof something.dnsName === "string" && something.dnsName.length <= 64 &&
        portCheck(something));
}
exports.isDnsPoolRelay = isDnsPoolRelay;
function isMultiHostPoolRelay(something) {
    return (minimumPoolRelayCheck(something) &&
        something.type === "multi-host" &&
        (0, obj_utils_1.hasOwn)(something, "dnsName") &&
        typeof something.dnsName === "string" && something.dnsName.length <= 64);
}
exports.isMultiHostPoolRelay = isMultiHostPoolRelay;
function isPoolRelay(something) {
    return (isIpPoolRelay(something) ||
        isDnsPoolRelay(something) ||
        isMultiHostPoolRelay(something));
}
exports.isPoolRelay = isPoolRelay;
function poolRelayToCborObj(poolRelay) {
    (0, assert_1.assert)(isPoolRelay(poolRelay), "can't convert ot CborObj using 'poolRelayToCborObj' if the input is not a 'PoolRelay'");
    var type = poolRelay.type;
    if (type === "ip") {
        var _a = poolRelay, ipv4 = _a.ipv4, ipv6 = _a.ipv6;
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(0),
            poolRelay.port === undefined ?
                new cbor_1.CborSimple(null) :
                new cbor_1.CborUInt((0, ints_1.forceBigUInt)(poolRelay.port)),
            ipv4 === undefined ?
                new cbor_1.CborSimple(null) :
                new cbor_1.CborBytes(ipv4),
            ipv6 === undefined ?
                new cbor_1.CborSimple(null) :
                new cbor_1.CborBytes(ipv6),
        ]);
    }
    if (type === "dns") {
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(1),
            poolRelay.port === undefined ?
                new cbor_1.CborSimple(null) :
                new cbor_1.CborUInt((0, ints_1.forceBigUInt)(poolRelay.port)),
            new cbor_1.CborText(poolRelay.dnsName)
        ]);
    }
    if (type === "multi-host") {
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(2),
            new cbor_1.CborText(poolRelay.dnsName)
        ]);
    }
    throw new Error("can't match 'PoolRelay' type");
}
exports.poolRelayToCborObj = poolRelayToCborObj;
function poolRelayFromCborObj(cObj) {
    if (!(cObj instanceof cbor_1.CborArray))
        throw new Error("Invalid CBOR format for \"PoolRelay\"");
    var _a = __read(cObj.array, 4), _type = _a[0], _1 = _a[1], _2 = _a[2], _3 = _a[3];
    if (!(_type instanceof cbor_1.CborUInt))
        throw new Error("Invalid CBOR format for \"PoolRelay\"");
    var n = Number(_type.num);
    if (n === 0) {
        return {
            type: "ip",
            port: _1 instanceof cbor_1.CborUInt ? _1.num : undefined,
            ipv4: _2 instanceof cbor_1.CborBytes ? _2.buffer : undefined,
            ipv6: _3 instanceof cbor_1.CborBytes ? _3.buffer : undefined,
        };
    }
    if (n === 1) {
        return {
            type: "dns",
            port: _1 instanceof cbor_1.CborUInt ? _1.num : undefined,
            dnsName: _2 instanceof cbor_1.CborText ? _2.text : undefined,
        };
    }
    if (n === 2) {
        if (!(_1 instanceof cbor_1.CborText))
            throw new Error("Invalid CBOR format for \"PoolRelay\"");
        return {
            type: "multi-host",
            dnsName: _1.text,
        };
    }
    throw new Error("can't match 'PoolRelay' type");
}
exports.poolRelayFromCborObj = poolRelayFromCborObj;
