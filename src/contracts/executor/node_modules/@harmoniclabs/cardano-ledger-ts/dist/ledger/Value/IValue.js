"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.subIValues = exports.addIValues = exports.getEmptyNameQty = exports.getNameQty = exports.isIValue = exports.cloneIValueEntry = exports.IValueToJson = exports.cloneIValue = exports.isNormalizedIValuePolicyEntry = exports.normalizeIValuePolicyEntry = exports.isIValueAssetBI = exports.normalizeIValueAsset = exports.normalizeIValue = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var Hash28_1 = require("../../hashes/Hash28/Hash28.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
function normalizeIValue(val) {
    return val.map(function (_c) {
        var policy = _c.policy, assets = _c.assets;
        if (policy === "")
            return {
                policy: "",
                assets: [
                    {
                        name: new Uint8Array([]),
                        quantity: BigInt(assets[0].quantity)
                    }
                ]
            };
        policy = new Hash28_1.Hash28(policy);
        // precompute bytes and string representation.
        policy.toBuffer();
        policy.toString();
        return {
            policy: policy,
            assets: assets
                .map(function (_c) {
                var name = _c.name, quantity = _c.quantity;
                return {
                    name: typeof name === "string" ? (0, uint8array_utils_1.fromHex)(name) : name,
                    quantity: BigInt(quantity)
                };
            })
                .sort(function (a, b) { return (0, uint8array_utils_1.lexCompare)(a.name, b.name); })
        };
    })
        .sort(function (a, b) {
        if (a.policy === "")
            return -1;
        if (b.policy === "")
            return 1;
        return (0, uint8array_utils_1.lexCompare)(a.policy.toBuffer(), b.policy.toBuffer());
    });
}
exports.normalizeIValue = normalizeIValue;
function normalizeIValueAsset(asset) {
    return {
        name: typeof asset.name === "string" ? (0, uint8array_utils_1.fromHex)(asset.name) : asset.name,
        quantity: BigInt(asset.quantity)
    };
}
exports.normalizeIValueAsset = normalizeIValueAsset;
function isIValueAssetBI(stuff) {
    return (0, obj_utils_1.isObject)(stuff) && (stuff.name instanceof Uint8Array &&
        typeof stuff.quantity === "bigint");
}
exports.isIValueAssetBI = isIValueAssetBI;
;
function normalizeIValuePolicyEntry(_c) {
    var policy = _c.policy, assets = _c.assets;
    policy = new Hash28_1.Hash28(policy);
    // precompute bytes and string representation.
    policy.toBuffer();
    policy.toString();
    return {
        policy: policy,
        assets: assets.map(function (_c) {
            var name = _c.name, quantity = _c.quantity;
            return {
                name: typeof name === "string" ? (0, uint8array_utils_1.fromHex)(name) : name,
                quantity: BigInt(quantity)
            };
        })
    };
}
exports.normalizeIValuePolicyEntry = normalizeIValuePolicyEntry;
function isNormalizedIValuePolicyEntry(stuff) {
    return (0, obj_utils_1.isObject)(stuff) && (stuff.policy instanceof Hash28_1.Hash28 &&
        Array.isArray(stuff.assets) &&
        stuff.assets.every(isIValueAssetBI));
}
exports.isNormalizedIValuePolicyEntry = isNormalizedIValuePolicyEntry;
function cloneIValue(ival) {
    return ival.map(cloneIValueEntry);
}
exports.cloneIValue = cloneIValue;
function policyToString(policy) {
    return typeof policy === "string" ? policy : (policy instanceof Uint8Array ? (0, uint8array_utils_1.toHex)(policy) :
        policy.toString());
}
function IValueToJson(iVal) {
    var e_1, _c, e_2, _d;
    var result = {};
    try {
        for (var iVal_1 = __values(iVal), iVal_1_1 = iVal_1.next(); !iVal_1_1.done; iVal_1_1 = iVal_1.next()) {
            var _e = iVal_1_1.value, policy = _e.policy, assets = _e.assets;
            var _assets = {};
            try {
                for (var assets_1 = (e_2 = void 0, __values(assets)), assets_1_1 = assets_1.next(); !assets_1_1.done; assets_1_1 = assets_1.next()) {
                    var _f = assets_1_1.value, name_1 = _f.name, quantity = _f.quantity;
                    (0, obj_utils_1.defineReadOnlyProperty)(_assets, typeof name_1 === "string" ? name_1 : (0, uint8array_utils_1.toHex)(name_1), quantity.toString());
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (assets_1_1 && !assets_1_1.done && (_d = assets_1.return)) _d.call(assets_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            (0, obj_utils_1.defineReadOnlyProperty)(result, policyToString(policy), _assets);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (iVal_1_1 && !iVal_1_1.done && (_c = iVal_1.return)) _c.call(iVal_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
exports.IValueToJson = IValueToJson;
function cloneIValueAssets(iValAssets) {
    return iValAssets.map(function (_c) {
        var name = _c.name, quantity = _c.quantity;
        return ({ name: name.slice(), quantity: quantity });
    });
}
function cloneIValueEntry(_c) {
    var policy = _c.policy, assets = _c.assets;
    return {
        policy: policy,
        assets: cloneIValueAssets(assets)
    };
}
exports.cloneIValueEntry = cloneIValueEntry;
/**
 * extended ascii
 */
function isAscii(str) {
    return (typeof str === "string" &&
        //char in range (0b0000_0000, 0b1111_1111)
        /^[\x00-\xFF]*$/.test(str));
}
function isAdaEntry(entry) {
    var assets = entry === null || entry === void 0 ? void 0 : entry.assets;
    return ((0, obj_utils_1.isObject)(entry) &&
        (0, obj_utils_1.hasOwn)(entry, "policy") &&
        (0, obj_utils_1.hasOwn)(entry, "assets") &&
        entry.policy === "" &&
        Array.isArray(assets) && assets.length === 1 &&
        (function (_c) {
            var name = _c.name, quantity = _c.quantity;
            return (name instanceof Uint8Array &&
                name.length === 0 &&
                (typeof quantity === "bigint" ||
                    (typeof quantity === "number" &&
                        quantity === Math.round(quantity))));
        })(assets[0]));
}
function isIValueAsset(entry) {
    return ((0, obj_utils_1.isObject)(entry) &&
        (0, obj_utils_1.hasOwn)(entry, "name") &&
        entry.name instanceof Uint8Array &&
        entry.name.length <= 32 &&
        (0, obj_utils_1.hasOwn)(entry, "quantity") &&
        (typeof entry.quantity === "bigint" ||
            (typeof entry.quantity === "number" &&
                entry.quantity === Math.round(entry.quantity))));
}
function isIValueAssets(assets) {
    return (Array.isArray(assets) &&
        assets.every(isIValueAsset));
}
function isIValue(entries) {
    if (!Array.isArray(entries))
        return false;
    var policies = [];
    var hasAdaEntry = false;
    var len = entries.length;
    for (var i = 0; i < len; i++) {
        var entry = entries[i];
        if (!((0, obj_utils_1.isObject)(entry) &&
            (0, obj_utils_1.hasOwn)(entry, "policy") &&
            (0, obj_utils_1.hasOwn)(entry, "assets")))
            return false;
        if (entry.policy === "") {
            if (hasAdaEntry) {
                // duplicate ada entry
                return false;
            }
            if (!isAdaEntry(entry))
                return false;
            policies.push("");
            hasAdaEntry = true;
            continue;
        }
        if (!(entry.policy instanceof Hash28_1.Hash28))
            return false;
        var policyAsStr = entry.policy.toString();
        // duplicate entry
        if (policies.includes(policyAsStr))
            return false;
        policies.push(policyAsStr);
        if (!isIValueAssets(entry.assets))
            return false;
    }
    return true;
}
exports.isIValue = isIValue;
var empty = new Uint8Array([]);
function getNameQty(assets, searchName) {
    var _c;
    if (!(Array.isArray(assets)))
        return undefined;
    return (_c = assets.find(function (_c) {
        var name = _c.name;
        return (0, uint8array_utils_1.uint8ArrayEq)(typeof name === "string" ? (0, uint8array_utils_1.fromHex)(name) : name, searchName);
    })) === null || _c === void 0 ? void 0 : _c.quantity;
}
exports.getNameQty = getNameQty;
function getEmptyNameQty(assets) {
    return getNameQty(assets, empty);
}
exports.getEmptyNameQty = getEmptyNameQty;
function addIValues(a, b) {
    var _c, _d, _e;
    var sum = [];
    var short = (a.length < b.length ? a : b);
    var long = (a.length < b.length ? b : a);
    var aAdaAssets = ((_c = long.find(function (entry) { return entry.policy === ""; })) !== null && _c !== void 0 ? _c : {}).assets;
    var bAdaAssets = ((_d = short.find(function (entry) { return entry.policy === ""; })) !== null && _d !== void 0 ? _d : {}).assets;
    var longIndiciesIncluded = [];
    if (aAdaAssets !== undefined || bAdaAssets !== undefined) {
        var aVal = 0;
        var bVal = 0;
        if (aAdaAssets !== undefined) {
            aVal = getEmptyNameQty(aAdaAssets);
            longIndiciesIncluded.push(long.findIndex(function (entry) { return entry.policy === ""; }));
            if (aVal === undefined)
                throw new Error("ill formed Value passed to addition");
        }
        if (bAdaAssets !== undefined) {
            bVal = getEmptyNameQty(bAdaAssets);
            if (bVal === undefined)
                throw new Error("ill formed Value passed to addition");
        }
        sum.push({
            policy: "",
            assets: [
                {
                    name: empty.slice(),
                    quantity: BigInt(aVal) + BigInt(bVal)
                }
            ]
        });
    }
    var _loop_1 = function (i) {
        var _f = short[i], policy = _f.policy, sassets = _f.assets;
        if (policy === "")
            return "continue";
        var policyAsStr = policy.toString();
        var lassets = ((_e = long.find(function (entry, i) {
            if (entry.policy.toString() === policyAsStr) {
                longIndiciesIncluded.push(i);
                return true;
            }
            return false;
        })) !== null && _e !== void 0 ? _e : {}).assets;
        sum.push({
            policy: policy,
            assets: lassets === undefined ? sassets : addIValueAssets(sassets, lassets)
        });
    };
    for (var i = 0; i < short.length; i++) {
        _loop_1(i);
    }
    for (var i = 0; i < long.length; i++) {
        if (longIndiciesIncluded.includes(i))
            continue;
        var toAdd = long[i];
        if (toAdd.policy !== "")
            sum.push(toAdd);
    }
    return sum;
}
exports.addIValues = addIValues;
function addInt(a, b) {
    return BigInt(a) + BigInt(b);
}
function addIValueAssets(a, b) {
    var sum = [];
    var aKeys = a.map(function (_c) {
        var name = _c.name;
        return name;
    });
    var bKeys = b.map(function (_c) {
        var name = _c.name;
        return name;
    });
    var short = aKeys.length < bKeys.length ? a : b;
    var shortKeys = a === short ? aKeys : bKeys;
    var long = aKeys.length < bKeys.length ? b : a;
    var longKeys = a === long ? aKeys : bKeys;
    var included = [];
    var _loop_2 = function (i) {
        var name_2 = shortKeys[i];
        included.push(name_2);
        var longKeysIdx = longKeys.findIndex(function (k) { return (0, uint8array_utils_1.uint8ArrayEq)(k, name_2); });
        if (longKeysIdx >= 0) {
            sum.push({
                name: name_2.slice(),
                quantity: addInt(short[i].quantity, long[longKeysIdx].quantity)
            });
        }
        else {
            sum.push({
                name: name_2.slice(),
                quantity: BigInt(short[i].quantity)
            });
        }
    };
    for (var i = 0; i < shortKeys.length; i++) {
        _loop_2(i);
    }
    var _loop_3 = function (i) {
        var name_3 = longKeys[i];
        if (included.some(function (k) { return (0, uint8array_utils_1.uint8ArrayEq)(k, name_3); }))
            return "continue";
        sum.push({
            name: name_3.slice(),
            quantity: BigInt(long[i].quantity)
        });
    };
    for (var i = 0; i < longKeys.length; i++) {
        _loop_3(i);
    }
    return sum;
}
function subIValues(a, b) {
    var e_3, _c;
    var _d, _e, _f;
    var result = [];
    var bIndiciesIncluded = [];
    var aAdaAssets = ((_d = a.find(function (entry) { return entry.policy === ""; })) !== null && _d !== void 0 ? _d : {}).assets;
    var bAdaAssets = ((_e = b.find(function (entry, i) {
        if (entry.policy === "") {
            bIndiciesIncluded.push(i);
            return true;
        }
        return false;
    })) !== null && _e !== void 0 ? _e : {}).assets;
    if (aAdaAssets !== undefined || bAdaAssets !== undefined) {
        var aVal = 0;
        var bVal = 0;
        if (aAdaAssets !== undefined) {
            aVal = getEmptyNameQty(aAdaAssets);
            if (aVal === undefined)
                throw new Error("ill formed Value passed to addition");
        }
        if (bAdaAssets !== undefined) {
            bVal = getEmptyNameQty(bAdaAssets);
            if (bVal === undefined)
                throw new Error("ill formed Value passed to addition");
        }
        var lovelaces = BigInt(aVal) - BigInt(bVal);
        if (lovelaces !== BigInt(0))
            result.push({
                policy: "",
                assets: [
                    {
                        name: empty.slice(),
                        quantity: lovelaces
                    }
                ]
            });
    }
    var _a = a;
    var _b = b;
    var _loop_4 = function (i) {
        var _j = _a[i], policy = _j.policy, aAssets = _j.assets;
        if (policy === "")
            return "continue";
        var policyAsStr = policy.toString();
        var bAssets = ((_f = _b.find(function (entry, i) {
            if (entry.policy.toString() === policyAsStr) {
                bIndiciesIncluded.push(i);
                return true;
            }
            return false;
        })) !== null && _f !== void 0 ? _f : {}).assets;
        if (bAssets !== undefined) {
            var subtractedAssets = subIValueAssets(aAssets, bAssets);
            if (subtractedAssets.length !== 0) {
                result.push({
                    policy: new Hash28_1.Hash28(policy),
                    assets: subtractedAssets
                });
            }
        }
        else {
            result.push({
                policy: new Hash28_1.Hash28(policy),
                assets: aAssets
            });
        }
    };
    for (var i = 0; i < _a.length; i++) {
        _loop_4(i);
    }
    for (var i = 0; i < _b.length; i++) {
        if (bIndiciesIncluded.includes(i))
            continue;
        var subAssets = [];
        var _g = _b[i], policy = _g.policy, assets = _g.assets;
        try {
            for (var assets_2 = (e_3 = void 0, __values(assets)), assets_2_1 = assets_2.next(); !assets_2_1.done; assets_2_1 = assets_2.next()) {
                var _h = assets_2_1.value, name_4 = _h.name, quantity = _h.quantity;
                subAssets.push({
                    name: name_4.slice(),
                    quantity: -BigInt(quantity)
                });
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (assets_2_1 && !assets_2_1.done && (_c = assets_2.return)) _c.call(assets_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        result.push({
            policy: policy.clone(),
            assets: subAssets
        });
    }
    return result;
}
exports.subIValues = subIValues;
function subInt(a, b) {
    return BigInt(a) - BigInt(b);
}
function subIValueAssets(a, b) {
    var e_4, _c;
    var _d, _e;
    var result = [];
    var aKeys = a.map(function (_c) {
        var name = _c.name;
        return name;
    });
    var bKeys = b.map(function (_c) {
        var name = _c.name;
        return name;
    });
    var includedBKeys = [];
    var _loop_5 = function (i) {
        var name_5 = aKeys[i];
        var bKeysIdx = bKeys.findIndex(function (k) { return (0, uint8array_utils_1.uint8ArrayEq)(k, name_5); });
        if (bKeysIdx >= 0) {
            var name_6 = bKeys[bKeysIdx];
            includedBKeys.push(name_6);
            var amt = subInt((_d = getNameQty(a, name_6)) !== null && _d !== void 0 ? _d : 0, (_e = getNameQty(b, name_6)) !== null && _e !== void 0 ? _e : 0);
            if (amt !== BigInt(0)) {
                result.push({
                    name: name_6.slice(),
                    quantity: amt
                });
            }
        }
        else {
            var amt = getNameQty(a, name_5);
            if (amt !== undefined) {
                result.push({
                    name: name_5.slice(),
                    quantity: BigInt(amt)
                });
            }
        }
    };
    for (var i = 0; i < aKeys.length; i++) {
        _loop_5(i);
    }
    var _loop_6 = function (bKey) {
        if (includedBKeys.some(function (k) { return (0, uint8array_utils_1.uint8ArrayEq)(bKey, k); }))
            return "continue";
        var amt = getNameQty(b, bKey);
        if (amt !== undefined) {
            result.push({
                name: bKey.slice(),
                quantity: -BigInt(amt)
            });
        }
    };
    try {
        for (var bKeys_1 = __values(bKeys), bKeys_1_1 = bKeys_1.next(); !bKeys_1_1.done; bKeys_1_1 = bKeys_1.next()) {
            var bKey = bKeys_1_1.value;
            _loop_6(bKey);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (bKeys_1_1 && !bKeys_1_1.done && (_c = bKeys_1.return)) _c.call(bKeys_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return result;
}
