"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Value = void 0;
var bytestring_1 = require("@harmoniclabs/bytestring");
var cbor_1 = require("@harmoniclabs/cbor");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var hashes_1 = require("../../hashes/index.js");
var ints_1 = require("../../utils/ints.js");
var IValue_1 = require("./IValue.js");
var assert_1 = require("../../utils/assert.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var getSubCborRef_1 = require("../../utils/getSubCborRef.js");
var _0n = BigInt(0);
var Value = /** @class */ (function () {
    function Value(map, subCborRef) {
        var _this = this;
        this.subCborRef = subCborRef;
        (0, assert_1.assert)((0, IValue_1.isIValue)(map), "invalid value interface passed to contruct a 'value' instance");
        var _map = (0, IValue_1.normalizeIValue)(map);
        _map.forEach(function (entry, i) {
            var assets = entry.assets;
            assets.forEach(function (a) { return Object.freeze(a); });
            Object.freeze(entry.policy);
        });
        // value MUST have an ada entry
        if (!_map.some(function (entry) { return entry.policy === ""; })) {
            _map.unshift({
                policy: "",
                assets: [
                    {
                        name: new Uint8Array([]),
                        quantity: _0n
                    }
                ]
            });
        }
        _map.sort(function (a, b) {
            if (a.policy === "") {
                if (b.policy === "")
                    return 0 /* Ord.EQ */;
                return -1 /* Ord.LT */;
            }
            ;
            if (b.policy === "") {
                return 1 /* Ord.GT */;
            }
            return (0, uint8array_utils_1.lexCompare)(a.policy.toBuffer(), b.policy.toBuffer());
        });
        (0, obj_utils_1.defineReadOnlyProperty)(this, "map", Object.freeze(_map));
        Object.defineProperty(this, "lovelaces", {
            get: function () {
                var _a, _b;
                return BigInt((_b = (0, IValue_1.getEmptyNameQty)((_a = _this.map
                    .find(function (_a) {
                    var policy = _a.policy;
                    return policy === "";
                })) === null || _a === void 0 ? void 0 : _a.assets)) !== null && _b !== void 0 ? _b : 0);
            },
            set: function () { },
            enumerable: true,
            configurable: false
        });
    }
    Value.prototype[Symbol.iterator] = function () {
        var _a, _b, _c, policy, assets, e_1_1;
        var e_1, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _e.trys.push([0, 5, 6, 7]);
                    _a = __values(this.map), _b = _a.next();
                    _e.label = 1;
                case 1:
                    if (!!_b.done) return [3 /*break*/, 4];
                    _c = _b.value, policy = _c.policy, assets = _c.assets;
                    return [4 /*yield*/, { policy: policy.toString(), assets: assets }];
                case 2:
                    _e.sent();
                    _e.label = 3;
                case 3:
                    _b = _a.next();
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 7];
                case 5:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 7];
                case 6:
                    try {
                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    };
    Value.prototype.get = function (policy, assetName) {
        var _a, _b;
        if (typeof policy === "string") {
            if (policy === "")
                return this.lovelaces;
            policy = new hashes_1.Hash28(policy);
        }
        var policyStr = policy instanceof hashes_1.Hash28 ? policy.toString() : (0, uint8array_utils_1.toHex)(policy);
        return BigInt((_b = (0, IValue_1.getNameQty)((_a = this.map.find(function (_a) {
            var policy = _a.policy;
            return policy.toString() === policyStr;
        })) === null || _a === void 0 ? void 0 : _a.assets, assetName)) !== null && _b !== void 0 ? _b : 0);
    };
    Value.prototype.toUnits = function () {
        return this.map.flatMap(function (_a) {
            var _b;
            var policy = _a.policy, assets = _a.assets;
            if (policy === "") {
                return { unit: 'lovelace', quantity: BigInt((_b = (0, IValue_1.getEmptyNameQty)(assets)) !== null && _b !== void 0 ? _b : 0) };
            }
            return assets.map(function (_a) {
                var _b;
                var assetName = _a.name;
                return ({
                    unit: "".concat(policy.toString()).concat((0, uint8array_utils_1.toHex)(assetName)),
                    quantity: BigInt((_b = (0, IValue_1.getNameQty)(assets, assetName)) !== null && _b !== void 0 ? _b : 0)
                });
            });
        });
    };
    Value.fromUnits = function (units) {
        return units.map(function (_a) {
            var unit = _a.unit, quantity = _a.quantity;
            if (unit.length === 0 || unit === "lovelace") {
                return Value.lovelaces(BigInt(quantity));
            }
            var policy = new hashes_1.Hash28(unit.slice(0, 56));
            var assetName = (0, uint8array_utils_1.fromHex)(unit.slice(56));
            return new Value([
                {
                    policy: policy,
                    assets: [
                        {
                            name: assetName,
                            quantity: BigInt(quantity)
                        }
                    ]
                }
            ]);
        })
            .reduce(function (a, b) { return Value.add(a, b); });
    };
    Object.defineProperty(Value, "zero", {
        get: function () {
            return Value.lovelaces(0);
        },
        enumerable: false,
        configurable: true
    });
    Value.isZero = function (v) {
        return (v.map.length === 0 ||
            v.map.every(function (_a) {
                var assets = _a.assets;
                return assets.every(function (_a) {
                    var quantity = _a.quantity;
                    return (0, ints_1.forceBigUInt)(quantity) === BigInt(0);
                });
            }));
    };
    Value.isPositive = function (v) {
        return v.map.every(function (_a) {
            var assets = _a.assets;
            return assets.every(function (_a) {
                var quantity = _a.quantity;
                return quantity >= 0;
            });
        });
    };
    Value.isAdaOnly = function (v) {
        return v.map.length === 1;
    };
    Value.lovelaceEntry = function (n) {
        return {
            policy: "",
            assets: [
                {
                    name: new Uint8Array([]),
                    quantity: typeof n === "number" ? BigInt(Math.round(n)) : BigInt(n)
                }
            ]
        };
    };
    Value.lovelaces = function (n) {
        return new Value([Value.lovelaceEntry(n)]);
    };
    Value.assetEntry = function (name, qty) {
        if (!(name instanceof Uint8Array &&
            name.length <= 32))
            throw new Error("invalid asset name; must be Uint8Array of length <= 32");
        return {
            name: name.slice(),
            quantity: typeof qty === "number" ? BigInt(Math.round(qty)) : BigInt(qty)
        };
    };
    Value.singleAssetEntry = function (policy, name, qty) {
        return {
            policy: policy,
            assets: [Value.assetEntry(name, qty)]
        };
    };
    Value.singleAsset = function (policy, name, qty) {
        return new Value([
            Value.singleAssetEntry(policy, name, qty)
        ]);
    };
    Value.entry = function (policy, assets) {
        return { policy: policy, assets: assets.map(IValue_1.normalizeIValueAsset) };
    };
    Value.add = function (a, b) {
        return new Value((0, IValue_1.addIValues)(a.map, b.map));
    };
    Value.sub = function (a, b) {
        return new Value((0, IValue_1.subIValues)(a.map, b.map));
    };
    Value.prototype.clone = function () {
        return new Value((0, IValue_1.cloneIValue)(this.map));
    };
    Value.prototype.toData = function (version) {
        return new plutus_data_1.DataMap(this.map.map(function (_a) {
            var policy = _a.policy, assets = _a.assets;
            return new plutus_data_1.DataPair(new plutus_data_1.DataB(new bytestring_1.ByteString(policy === "" ? "" : policy.toBuffer())), new plutus_data_1.DataMap(assets.map(function (_a) {
                var _b;
                var assetName = _a.name;
                return new plutus_data_1.DataPair(new plutus_data_1.DataB(new bytestring_1.ByteString(assetName)), new plutus_data_1.DataI((_b = (0, IValue_1.getNameQty)(assets, assetName)) !== null && _b !== void 0 ? _b : 0));
            })));
        }));
    };
    Value.prototype.toCbor = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.subCborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    Value.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        if (Value.isAdaOnly(this))
            return new cbor_1.CborUInt(this.lovelaces);
        var multiasset = new cbor_1.CborMap(this.map
            // only keep hash28
            .filter(function (_a) {
            var policy = _a.policy;
            return policy.toString().length === 56;
        })
            .map(function (entry) {
            var assets = entry.assets;
            var policy = entry.policy;
            return {
                k: policy === "" ? new cbor_1.CborBytes(new Uint8Array(0)) : policy.toCborObj(),
                v: new cbor_1.CborMap(assets.map(function (_a) {
                    var assetName = _a.name, amt = _a.quantity;
                    return {
                        k: new cbor_1.CborBytes(assetName.slice()),
                        v: amt < 0 ? new cbor_1.CborNegInt(amt) : new cbor_1.CborUInt(amt)
                    };
                }))
            };
        }));
        if (this.lovelaces === BigInt(0))
            return multiasset;
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.lovelaces),
            multiasset
        ]);
    };
    Value.fromCbor = function (cStr) {
        return Value.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr), { keepRef: true }));
    };
    Value.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray || // ada and assets
            cObj instanceof cbor_1.CborMap || // only assets
            cObj instanceof cbor_1.CborUInt // only ada
        ))
            throw new Error("Invalid CBOR format for \"Value\"");
        if (cObj instanceof cbor_1.CborUInt)
            return Value.lovelaces(cObj.num);
        var cborMap;
        var valueMap;
        if (cObj instanceof cbor_1.CborArray) {
            if (!(cObj.array[0] instanceof cbor_1.CborUInt &&
                cObj.array[1] instanceof cbor_1.CborMap))
                throw new Error("Invalid CBOR format for \"Value\"");
            cborMap = cObj.array[1].map;
            valueMap = new Array(cborMap.length + 1);
            valueMap[0] = {
                policy: "",
                assets: [
                    {
                        name: new Uint8Array([]),
                        quantity: cObj.array[0].num
                    }
                ]
            };
        }
        else {
            cborMap = cObj.map;
            valueMap = new Array(cborMap.length + 1);
            valueMap[0] = {
                policy: "",
                assets: [
                    {
                        name: new Uint8Array([]),
                        quantity: BigInt(0)
                    }
                ]
            };
        }
        var n = cborMap.length;
        for (var i = 0; i < n; i++) {
            var _a = cborMap[i], k = _a.k, v = _a.v;
            if (!(k instanceof cbor_1.CborBytes))
                throw new Error("Invalid CBOR format for \"Value\"");
            var policy = k.bytes.length === 0 ? "" : new hashes_1.Hash28(k.bytes);
            if (!(v instanceof cbor_1.CborMap))
                throw new Error("Invalid CBOR format for \"Value\"");
            var assetsMap = v.map;
            var assetsMapLen = v.map.length;
            var assets = [];
            for (var j = 0; j < assetsMapLen; j++) {
                var _b = assetsMap[j], k_1 = _b.k, v_1 = _b.v;
                if (!(k_1 instanceof cbor_1.CborBytes))
                    throw new Error("Invalid CBOR format for \"Value\"");
                if (!(v_1 instanceof cbor_1.CborNegInt || v_1 instanceof cbor_1.CborUInt))
                    throw new Error("Invalid CBOR format for \"Value\"");
                assets.push({
                    name: k_1.bytes,
                    quantity: v_1.num
                });
            }
            valueMap[i + 1] = {
                policy: policy,
                assets: assets
            };
        }
        return new Value(valueMap, (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    Value.prototype.toJSON = function () { return this.toJson(); };
    Value.prototype.toJson = function () {
        return (0, IValue_1.IValueToJson)(this.map);
    };
    /**
     * cardano-cli format
     */
    Value.prototype.toString = function (includeLovelaces) {
        var e_2, _a, e_3, _b;
        if (includeLovelaces === void 0) { includeLovelaces = true; }
        var valueStr = "";
        var valueMap = this.map;
        if (includeLovelaces)
            valueStr += "+".concat(this.lovelaces.toString());
        if (Value.isAdaOnly(this))
            return valueStr;
        valueStr += includeLovelaces ? '+"' : '"';
        try {
            for (var valueMap_1 = __values(valueMap), valueMap_1_1 = valueMap_1.next(); !valueMap_1_1.done; valueMap_1_1 = valueMap_1.next()) {
                var _c = valueMap_1_1.value, policy = _c.policy, assets = _c.assets;
                if (policy === "")
                    continue;
                try {
                    for (var assets_1 = (e_3 = void 0, __values(assets)), assets_1_1 = assets_1.next(); !assets_1_1.done; assets_1_1 = assets_1.next()) {
                        var _d = assets_1_1.value, name_1 = _d.name, quantity = _d.quantity;
                        valueStr += "".concat(quantity
                            .toString(), " ").concat(policy.toString(), ".").concat((0, uint8array_utils_1.toHex)(name_1), "+");
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (assets_1_1 && !assets_1_1.done && (_b = assets_1.return)) _b.call(assets_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (valueMap_1_1 && !valueMap_1_1.done && (_a = valueMap_1.return)) _a.call(valueMap_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        valueStr = valueStr.slice(0, valueStr.length - 1) + '"';
        return valueStr;
    };
    return Value;
}());
exports.Value = Value;
