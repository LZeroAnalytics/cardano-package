"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.harden = exports.XPrv = exports.isXPrvBytes = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var pbkdf2_1 = require("./pbkdf2.js");
var XPub_1 = require("./XPub.js");
var add28mul8_1 = require("./add28mul8.js");
var crypto_1 = require("@harmoniclabs/crypto");
/// Extended Private key size in bytes
var XPRV_SIZE = 96;
var EXTENDED_SECRET_KEY_SIZE = 64;
// export type Uint8Arr32 = Uint8Array & { length: 32 };
function isXPrvBytes(stuff) {
    return stuff instanceof Uint8Array && stuff.length === 96;
}
exports.isXPrvBytes = isXPrvBytes;
/// Extended Public key size in bytes
var XPUB_SIZE = 64;
var PUBLIC_KEY_SIZE = 32;
var CHAIN_CODE_SIZE = 32;
var hmacSoftInputLen = 1 + 32 + 4;
var hmacHardInputLen = 1 + 64 + 4;
var XPrv = /** @class */ (function () {
    function XPrv(xprv) {
        if (!isXPrvBytes(xprv))
            throw new TypeError("invalid argument for 'XPrv'");
        Object.defineProperty(this, "bytes", {
            value: xprv,
            writable: false,
            enumerable: true,
            configurable: false
        });
    }
    /**
     * @returns reference to self
     */
    XPrv.prototype.clear3rdHighestBit = function () {
        this.bytes[31] &= 223;
        ;
        return this;
    };
    XPrv.prototype.toBech32 = function (prefix) {
        if (prefix === void 0) { prefix = "root_xsk"; }
        return (0, crypto_1.encodeBech32)(prefix, this.bytes);
    };
    XPrv.prototype.toString = function () {
        return this.toBech32();
    };
    XPrv.prototype.toBytes = function () {
        return Uint8Array.prototype.slice.call(this.bytes);
    };
    XPrv.prototype.chainCode = function () {
        return Uint8Array.prototype.slice.call(this.bytes, 64, 96);
    };
    XPrv.prototype.toPrivateKeyBytes = function () {
        return this.bytes.slice(0, 64);
    };
    XPrv.prototype.sign = function (message) {
        return (0, crypto_1.signExtendedEd25519_sync)(message, this.toPrivateKeyBytes());
    };
    /**
     * derive extended public key
     */
    XPrv.prototype.public = function () {
        var pk = (0, crypto_1.extendedToPublic)(this.toPrivateKeyBytes());
        var out = new Uint8Array(XPUB_SIZE); // 64
        out.set(pk, 0);
        out.set(this.chainCode(), 32);
        return new XPub_1.XPub(out);
    };
    XPrv.fromBech32 = function (xprv) {
        return new XPrv(Uint8Array.from((0, crypto_1.decodeBech32)(xprv)[1]));
    };
    XPrv.fromString = function (xprv) {
        return XPrv.fromBech32(xprv);
    };
    /**
     *  Takes a non-extended Ed25519 secret key and hash through SHA512 it in the same way the standard
     *  Ed25519 signature system make extended key, but *also* force clear the 3rd highest bit of the key
     *  instead of returning an error
     */
    XPrv.fromNonExended = function (bytes, chainCode) {
        var raw = new Uint8Array(XPRV_SIZE);
        raw.set((0, crypto_1.sha2_512_sync)(bytes), 0);
        raw.set(chainCode, 64);
        normalizeBytesForce3rd(raw);
        return new XPrv(raw);
    };
    XPrv.fromExtended = function (extended, chainCode) {
        var raw = new Uint8Array(XPRV_SIZE);
        raw.set(extended, 0);
        raw.set(chainCode, 64);
        return new XPrv(raw);
    };
    /**
     * construtcts an `XPrv` given bip39 entropy bytes
     *
     * @param password is optional, and in Cardano is more ofthen than not the empty string (`""`)
     * note that this is a totally different password used in cardano wallets (aka. THIS IS **NOT** THE SPENDING PASSWORD)
     * @returns {XPrv} the extended private key
     */
    XPrv.fromEntropy = function (entropy, password) {
        if (password === void 0) { password = ""; }
        entropy = typeof entropy === "string" && /[0-9a-fA-F]*/.test(entropy) ? (0, uint8array_utils_1.fromHex)(entropy) : entropy;
        var bytes = (0, pbkdf2_1.pbkdf2)(password, entropy, 4096, 96);
        normalizeBytesForce3rd(bytes);
        return new XPrv(bytes);
    };
    XPrv.fromBytes = function (bytes) {
        if (!(bytes instanceof Uint8Array &&
            (bytes.length === 96 ||
                bytes.length === 64)))
            throw new TypeError("invalid argument for 'XPrv'");
        if (bytes.length === 64) {
            // fromNonExended
            var tmp = new Uint8Array(96);
            tmp.set((0, crypto_1.sha2_512_sync)(bytes.slice(0, 32)));
            tmp.set(bytes.slice(32, 64), 64);
            normalizeBytesForce3rd(tmp);
            bytes = tmp;
        }
        var scalar = bytes.slice(0, 32);
        var last = scalar[31];
        var first = scalar[0];
        if ((last & 192) !== 64) {
            throw new Error("invalid bytes for XPrv; highest bit invalid");
        }
        if ((first & 7) != 0) {
            throw new Error("invalid bytes for XPrv; lowest bit invalid");
        }
        return new XPrv(bytes);
    };
    XPrv.prototype.derive = function (index) {
        index = Math.round(Math.abs(index));
        var extendedKey = this.bytes.slice(0, 64);
        var leftKey = this.bytes.slice(0, 32);
        var rightKey = this.bytes.slice(32, 64);
        var chainCode = this.bytes.slice(64, 96);
        var hard = index >= 0x80000000;
        var z = new Uint8Array(hard ? hmacHardInputLen : hmacSoftInputLen);
        var i = new Uint8Array(hard ? hmacHardInputLen : hmacSoftInputLen);
        if (hard) {
            z.set([0x00], 0);
            z.set(extendedKey, 1);
            (0, uint8array_utils_1.writeUint32LE)(z, index, 65);
            i.set([0x01], 0);
            i.set(extendedKey, 1);
            (0, uint8array_utils_1.writeUint32LE)(i, index, 65);
        }
        else {
            var pk = (0, crypto_1.extendedToPublic)(extendedKey);
            z.set([0x02], 0);
            z.set(pk, 1);
            (0, uint8array_utils_1.writeUint32LE)(z, index, 33);
            i.set([0x03], 0);
            i.set(pk, 1);
            (0, uint8array_utils_1.writeUint32LE)(i, index, 33);
        }
        var zmac = (0, crypto_1.hmacSHA512)(chainCode, z);
        var leftZ = zmac.slice(0, 32);
        var rightZ = zmac.slice(32, 64);
        var left = (0, add28mul8_1.add28mul8)(leftKey, leftZ);
        var right = add256Bits(rightKey, rightZ);
        // note: we don't perform the check for curve order divisibility because it will not happen:
        // 1. all keys are in the range K=2^254 .. 2^255 (actually the even smaller range 2^254+2^253)
        // 2. all keys are also multiple of 8
        // 3. all existing multiple of the curve order n in the range of K are not multiple of 8
        var imac = (0, crypto_1.hmacSHA512)(chainCode, i);
        var nextChainCode = imac.slice(32, 64);
        var raw = new Uint8Array(XPRV_SIZE);
        raw.set(left, 0);
        raw.set(right, 32);
        raw.set(nextChainCode, 64);
        return new XPrv(raw);
    };
    XPrv.fromParts = function (left, right, chainCode) {
        if (!(left instanceof Uint8Array &&
            right instanceof Uint8Array &&
            chainCode instanceof Uint8Array &&
            left.length === 32 &&
            right.length === 32 &&
            chainCode.length === 32))
            throw new TypeError("invalid XPrv parts");
        var raw = new Uint8Array(XPRV_SIZE);
        raw.set(left, 0);
        raw.set(right, 32);
        raw.set(chainCode, 64);
        return new XPrv(raw);
    };
    return XPrv;
}());
exports.XPrv = XPrv;
function harden(num) {
    return 0x80000000 + num;
}
exports.harden = harden;
/** @returns reference to the same input */
function normalizeBytesForce3rd(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 31;
    bytes[31] |= 64;
    return bytes;
}
function add256Bits(x, y) {
    var carry = 0;
    var out = new Uint8Array(32);
    for (var i = 0; i < 32; i++) {
        var r = x[i] + y[i] + carry;
        out[i] = r & 0xff;
        carry = r >> 8;
    }
    return out;
}
