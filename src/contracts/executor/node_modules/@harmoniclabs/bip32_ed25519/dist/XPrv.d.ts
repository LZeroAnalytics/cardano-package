import { XPub } from "./XPub.js";
export type XPrvBytes = Uint8Array & {
    length: 96;
};
export declare function isXPrvBytes(stuff: any): stuff is XPrvBytes;
export declare class XPrv {
    readonly bytes: XPrvBytes;
    constructor(xprv: Uint8Array);
    /**
     * @returns reference to self
     */
    clear3rdHighestBit(): XPrv;
    toBech32(prefix?: string): string;
    toString(): string;
    toBytes(): XPrvBytes;
    chainCode(): Uint8Array & {
        length: 32;
    };
    toPrivateKeyBytes(): Uint8Array & {
        length: 64;
    };
    sign(message: Uint8Array): {
        pubKey: Uint8Array;
        signature: Uint8Array;
    };
    /**
     * derive extended public key
     */
    public(): XPub;
    static fromBech32(xprv: string): XPrv;
    static fromString(xprv: string): XPrv;
    /**
     *  Takes a non-extended Ed25519 secret key and hash through SHA512 it in the same way the standard
     *  Ed25519 signature system make extended key, but *also* force clear the 3rd highest bit of the key
     *  instead of returning an error
     */
    static fromNonExended(bytes: Uint8Array, chainCode: Uint8Array): XPrv;
    static fromExtended(extended: Uint8Array, chainCode: Uint8Array): XPrv;
    /**
     * construtcts an `XPrv` given bip39 entropy bytes
     *
     * @param password is optional, and in Cardano is more ofthen than not the empty string (`""`)
     * note that this is a totally different password used in cardano wallets (aka. THIS IS **NOT** THE SPENDING PASSWORD)
     * @returns {XPrv} the extended private key
     */
    static fromEntropy(entropy: Uint8Array | string, password?: string): XPrv;
    static fromBytes(bytes: Uint8Array): XPrv;
    derive(index: number): XPrv;
    static fromParts(left: Uint8Array, right: Uint8Array, chainCode: Uint8Array): XPrv;
}
export declare function harden(num: number): number;
