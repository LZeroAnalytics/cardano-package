"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDataSchemaAsData = exports.toDataSchema = void 0;
var type_system_1 = require("../../type_system/index.js");
var tyArgs_1 = require("../../type_system/tyArgs/index.js");
var plu_ts_onchain_1 = require("@harmoniclabs/plu-ts-onchain");
function toDataSchema(t, title) {
    while ((0, type_system_1.isTaggedAsAlias)(t))
        t = (0, type_system_1.unwrapAlias)(t);
    title = typeof title === "string" ? title : undefined;
    if (t[0] === "asData" /* PrimType.AsData */ && (0, type_system_1.typeExtends)(t[1], type_system_1.int))
        return { title: title, dataType: "integer" };
    if ((0, type_system_1.typeExtends)(t, type_system_1.int))
        return { title: title, dataType: "#integer" };
    if (t[0] === "asData" /* PrimType.AsData */ && (0, type_system_1.typeExtends)(t[1], type_system_1.bs))
        return { title: title, dataType: "bytes" };
    if ((0, type_system_1.typeExtends)(t, type_system_1.bs))
        return { title: title, dataType: "#bytes" };
    if (t[0] === "asData" /* PrimType.AsData */ &&
        t[1][0] === "list" /* PrimType.List */ &&
        t[1][1][0] === "pair" /* PrimType.Pair */) {
        var schema = { dataType: "map" };
        var keysSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t)[1]);
        var valueSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t)[2]);
        if (keysSchema.dataType) {
            schema.keys = keysSchema;
        }
        if (valueSchema.dataType) {
            schema.values = valueSchema;
        }
        return schema;
    }
    if ((0, type_system_1.typeExtends)(t, (0, type_system_1.map)(type_system_1.data, type_system_1.data))) {
        throw new Error("unsupported #list( #pair( ... , ... ) ); only lists as data please; term type was: " + (0, type_system_1.termTypeToString)(t));
    }
    if (t[0] === "asData" /* PrimType.AsData */ &&
        t[1][0] === "list" /* PrimType.List */) {
        var schema = { title: title, dataType: "list" };
        var itemsSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t));
        if (itemsSchema.dataType) {
            schema.items = itemsSchema;
        }
        return schema;
    }
    if ((0, type_system_1.typeExtends)(t, (0, type_system_1.list)(type_system_1.data))) {
        var schema = { title: title, dataType: "#list" };
        var itemsSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t));
        if (itemsSchema.dataType) {
            schema.items = itemsSchema;
        }
        return schema;
    }
    if (t[0] === "struct" /* PrimType.Struct */ ||
        (t[0] === "asData" /* PrimType.AsData */ &&
            t[1][0] === "struct" /* PrimType.Struct */)) {
        return toDataSchemaAsData(t, title);
    }
    throw new Error("can't represent type as DataSchema; term type was: " + (0, type_system_1.termTypeToString)(t));
}
exports.toDataSchema = toDataSchema;
function toDataSchemaAsData(t, title) {
    while ((0, type_system_1.isTaggedAsAlias)(t) || t[0] === "asData" /* PrimType.AsData */)
        t = (0, type_system_1.unwrapAlias)((0, tyArgs_1.unwrapAsData)(t));
    title = typeof title === "string" ? title : undefined;
    if ((0, type_system_1.typeExtends)(t, type_system_1.int))
        return { dataType: "integer", title: title };
    if ((0, type_system_1.typeExtends)(t, type_system_1.bs))
        return { dataType: "bytes", title: title };
    if ((0, type_system_1.typeExtends)(t, (0, type_system_1.map)((0, plu_ts_onchain_1.tyVar)(), (0, plu_ts_onchain_1.tyVar)()))) {
        var schema = { dataType: "map", title: title };
        var keysSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t)[1]);
        var valueSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t)[2]);
        if (keysSchema.dataType) {
            schema.keys = keysSchema;
        }
        if (valueSchema.dataType) {
            schema.values = valueSchema;
        }
        return schema;
    }
    if ((0, type_system_1.typeExtends)(t, (0, type_system_1.list)((0, plu_ts_onchain_1.tyVar)()))) {
        var schema = { dataType: "list", title: title };
        var itemsSchema = toDataSchemaAsData((0, tyArgs_1.getElemsT)(t));
        if (itemsSchema.dataType) {
            schema.items = itemsSchema;
        }
        return schema;
    }
    if (t[0] === "struct" /* PrimType.Struct */) {
        var def = t[1];
        var ctors = Object.keys(def);
        if (ctors.length === 1) {
            var ctor = ctors[0];
            var ctorDef_1 = def[ctor];
            var fieldNames = Object.keys(def[ctor]);
            return {
                dataType: "constructor",
                title: ctor.toString(),
                index: 0,
                fields: fieldNames.map(function (field) { return toDataSchemaAsData(ctorDef_1[field], field); })
            };
        }
        var len = ctors.length;
        var alternatives = new Array(len);
        var _loop_1 = function (i) {
            var ctor = ctors[i];
            var ctorDef = def[ctor];
            var fieldNames = Object.keys(def[ctor]);
            alternatives[i] = {
                dataType: "constructor",
                title: ctor.toString(),
                index: i,
                fields: fieldNames.map(function (field) { return toDataSchemaAsData(ctorDef[field], field); })
            };
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
        return {
            title: title,
            anyOf: alternatives
        };
    }
    return { title: title }; // opaque data
}
exports.toDataSchemaAsData = toDataSchemaAsData;
