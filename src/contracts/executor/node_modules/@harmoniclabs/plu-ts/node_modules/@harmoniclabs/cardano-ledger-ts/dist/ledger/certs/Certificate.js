"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.certificatesToDepositLovelaces = exports.certToDepositLovelaces = exports.Certificate = exports.certTypeToString = exports.CertificateType = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var StakeCredentials_1 = require("../../credentials/StakeCredentials.js");
var GenesisDelegateHash_1 = require("../../hashes/Hash28/GenesisDelegateHash.js");
var GenesisHash_1 = require("../../hashes/Hash28/GenesisHash.js");
var Hash28_1 = require("../../hashes/Hash28/Hash28.js");
var PoolKeyHash_1 = require("../../hashes/Hash28/PoolKeyHash.js");
var VRFKeyHash_1 = require("../../hashes/Hash32/VRFKeyHash.js");
var assert_1 = require("../../utils/assert.js");
var ints_1 = require("../../utils/ints.js");
var PoolParams_1 = require("../PoolParams.js");
var MoveInstantRewardsCert_1 = require("./MoveInstantRewardsCert.js");
// number is important as it is included in serialization
var CertificateType;
(function (CertificateType) {
    CertificateType[CertificateType["StakeRegistration"] = 0] = "StakeRegistration";
    CertificateType[CertificateType["StakeDeRegistration"] = 1] = "StakeDeRegistration";
    CertificateType[CertificateType["StakeDelegation"] = 2] = "StakeDelegation";
    CertificateType[CertificateType["PoolRegistration"] = 3] = "PoolRegistration";
    CertificateType[CertificateType["PoolRetirement"] = 4] = "PoolRetirement";
    CertificateType[CertificateType["GenesisKeyDelegation"] = 5] = "GenesisKeyDelegation";
    CertificateType[CertificateType["MoveInstantRewards"] = 6] = "MoveInstantRewards";
})(CertificateType = exports.CertificateType || (exports.CertificateType = {}));
;
Object.freeze(CertificateType);
function certTypeToString(certT) {
    switch (certT) {
        case CertificateType.StakeRegistration: return "StakeRegistration";
        case CertificateType.StakeDeRegistration: return "StakeDeRegistration";
        case CertificateType.StakeDelegation: return "StakeDelegation";
        case CertificateType.PoolRegistration: return "PoolRegistration";
        case CertificateType.PoolRetirement: return "PoolRetirement";
        case CertificateType.GenesisKeyDelegation: return "GenesisKeyDelegation";
        case CertificateType.MoveInstantRewards: return "MoveInstantRewards";
        default:
            throw new Error("unknown certificate type");
    }
}
exports.certTypeToString = certTypeToString;
var Certificate = /** @class */ (function () {
    function Certificate(certType) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        (0, assert_1.assert)(typeof certType === "number" &&
            certType >= 0 && certType <= 6 &&
            certType === Math.round(certType), "unknown certificate type");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "certType", certType);
        (0, assert_1.assert)(params.length > 0, "no certificate paramters provided");
        if (certType === CertificateType.StakeRegistration ||
            certType === CertificateType.StakeDeRegistration) {
            (0, assert_1.assert)(params.length >= 1 &&
                params[0] instanceof StakeCredentials_1.StakeCredentials, "invalid paramters for stake registration / deregistration");
        }
        if (certType === CertificateType.StakeDelegation) {
            (0, assert_1.assert)(params.length >= 2 &&
                params[0] instanceof StakeCredentials_1.StakeCredentials &&
                params[1] instanceof PoolKeyHash_1.PoolKeyHash, "invalid paramters for stake delegation");
        }
        if (certType === CertificateType.PoolRegistration) {
            (0, assert_1.assert)(params.length >= 1 &&
                params[0] instanceof PoolParams_1.PoolParams, "invalid paramters for stake registration / deregistration");
        }
        if (certType === CertificateType.PoolRetirement) {
            (0, assert_1.assert)(params.length >= 2 &&
                params[0] instanceof PoolKeyHash_1.PoolKeyHash &&
                (typeof params[1] === "bigint" ||
                    typeof params[1] === "number"), "invalid paramters for stake delegation");
            var epoch = (0, ints_1.forceBigUInt)(params[1]);
            (0, obj_utils_1.defineReadOnlyProperty)(this, "params", Object.freeze([params[0], epoch]));
            return;
        }
        if (certType === CertificateType.GenesisKeyDelegation) {
            (0, assert_1.assert)(params.length >= 3 &&
                params[0] instanceof GenesisHash_1.GenesisHash &&
                params[1] instanceof GenesisDelegateHash_1.GenesisDelegateHash &&
                params[2] instanceof VRFKeyHash_1.VRFKeyHash, "invalid paramters for stake delegation");
        }
        if (certType === CertificateType.MoveInstantRewards) {
            (0, assert_1.assert)(params.length >= 1 &&
                params[0] instanceof MoveInstantRewardsCert_1.MoveInstantRewardsCert, "invalid paramters for stake registration / deregistration");
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "params", Object.freeze(params));
    }
    Certificate.prototype.toData = function () {
        // every certificate has at most two parameters
        var _a = __read(this.params, 2), fst = _a[0], snd = _a[1];
        switch (this.certType) {
            case CertificateType.StakeRegistration:
            case CertificateType.StakeDeRegistration:
                if (!(fst instanceof StakeCredentials_1.StakeCredentials))
                    throw new Error("stake (de)registration parameter was not 'StakeCredentials'");
                return new plutus_data_1.DataConstr(this.certType === CertificateType.StakeRegistration ? 0 : 1, // KeyRegistration | KeyDeRegistration
                [fst.toData()]);
                break;
            case CertificateType.StakeDelegation:
                if (!(fst instanceof StakeCredentials_1.StakeCredentials))
                    throw new Error("stake delegation frist parameter was not 'StakeCredentials'");
                if (!(snd instanceof Hash28_1.Hash28))
                    throw new Error("stake delegation second parameter was not 'PoolKeyHash'");
                return new plutus_data_1.DataConstr(2, // KeyDelegation
                [fst.toData(), snd.toData()]);
                break;
            case CertificateType.PoolRegistration:
                if (!(fst instanceof PoolParams_1.PoolParams))
                    throw new Error("PoolRegistration frist parameter was not 'PoolRegistration'");
                var poolId = fst.operator, poolVRF = fst.vrfKeyHash;
                if (!(poolId instanceof Hash28_1.Hash28 && poolVRF instanceof Hash28_1.Hash28))
                    throw new Error("invalid pool registration parameters");
                return new plutus_data_1.DataConstr(3, // PoolRegistration
                [poolId.toData(), poolVRF.toData()]);
                break;
            case CertificateType.PoolRetirement:
                if (!(fst instanceof Hash28_1.Hash28))
                    throw new Error("invalid poolId for pool retirement certificate");
                if (!(0, ints_1.canBeUInteger)(snd))
                    throw new Error("invalid epoch as second pool retirement cetificate");
                return new plutus_data_1.DataConstr(4, // PoolRetire
                [fst.toData(), new plutus_data_1.DataI(snd)]);
                break;
            case CertificateType.GenesisKeyDelegation:
            case CertificateType.MoveInstantRewards:
                return new plutus_data_1.DataConstr(this.certType === CertificateType.GenesisKeyDelegation ? 5 : 6, []);
                break;
            default:
                throw new Error("unmatched certificate type");
        }
    };
    Certificate.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    Certificate.prototype.toCborObj = function () {
        if (this.certType === CertificateType.PoolRetirement) {
            return new cbor_1.CborArray([
                new cbor_1.CborUInt(this.certType),
                this.params[0].toCborObj(),
                new cbor_1.CborUInt((0, ints_1.forceBigUInt)(this.params[1]))
            ]);
        }
        if (this.certType === CertificateType.PoolRegistration) {
            return new cbor_1.CborArray(__spreadArray([
                new cbor_1.CborUInt(this.certType)
            ], __read(this.params[0].toCborObjArray()), false));
        }
        return new cbor_1.CborArray(__spreadArray([
            new cbor_1.CborUInt(this.certType)
        ], __read(this.params.map(function (p) { return p.toCborObj(); })), false));
    };
    Certificate.fromCbor = function (cStr) {
        return Certificate.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr)));
    };
    Certificate.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray))
            throw new Error("Invalid CBOR fromat for \"Certificate\"");
        var _a = __read(cObj.array), _type = _a[0], _params = _a.slice(1);
        if (!(_type instanceof cbor_1.CborUInt))
            throw new Error("Invalid CBOR fromat for \"Certificate\"");
        var type = Number(_type.num);
        switch (type) {
            case CertificateType.StakeRegistration:
            case CertificateType.StakeDeRegistration:
                return new Certificate(type, StakeCredentials_1.StakeCredentials.fromCborObj(_params[0]));
            case CertificateType.StakeDelegation:
                return new Certificate(type, StakeCredentials_1.StakeCredentials.fromCborObj(_params[0]), PoolKeyHash_1.PoolKeyHash.fromCborObj(_params[1]));
            case CertificateType.PoolRegistration:
                return new Certificate(type, PoolParams_1.PoolParams.fromCborObjArray(_params));
            case CertificateType.PoolRetirement:
                if (!(_params[1] instanceof cbor_1.CborUInt))
                    throw new Error("Invalid CBOR fromat for \"Certificate\"");
                return new Certificate(type, PoolKeyHash_1.PoolKeyHash.fromCborObj(_params[0]), _params[1].num);
            case CertificateType.GenesisKeyDelegation:
                return new Certificate(type, GenesisHash_1.GenesisHash.fromCborObj(_params[0]), GenesisDelegateHash_1.GenesisDelegateHash.fromCborObj(_params[1]), VRFKeyHash_1.VRFKeyHash.fromCborObj(_params[2]));
            case CertificateType.MoveInstantRewards:
                return new Certificate(type, MoveInstantRewardsCert_1.MoveInstantRewardsCert.fromCborObj(_params[0]));
            default:
                throw new Error("Invalid CBOR fromat for \"Certificate\"");
        }
    };
    Certificate.prototype.toJson = function () {
        var certTypeStr = certTypeToString(this.certType);
        switch (this.certType) {
            case CertificateType.StakeRegistration:
            case CertificateType.StakeDeRegistration:
                return {
                    certType: certTypeStr,
                    stakeCredentials: this.params[0].toJson()
                };
                break;
            case CertificateType.StakeDelegation:
                return {
                    certType: certTypeStr,
                    stakeCredentials: this.params[0].toJson(),
                    poolKeyHash: this.params[1].asString
                };
                break;
            case CertificateType.PoolRegistration:
                return {
                    certType: certTypeStr,
                    poolParams: this.params[0].toJson(),
                };
                break;
            case CertificateType.PoolRetirement:
                return {
                    certType: certTypeStr,
                    poolKeyHash: this.params[0].asString,
                    epoch: Number((0, ints_1.forceBigUInt)(this.params[1])),
                };
                break;
            case CertificateType.GenesisKeyDelegation:
                return {
                    certType: certTypeStr,
                    genesisHash: this.params[0].asString,
                    genesisDelegateHash: this.params[1].asString,
                    vrfKeyHash: this.params[2].asString
                };
                break;
            case CertificateType.MoveInstantRewards:
                return {
                    certType: certTypeStr,
                    mirCert: this.params[0].toJson()
                };
                break;
            default:
                throw new Error("unknown certificate type");
        }
    };
    return Certificate;
}());
exports.Certificate = Certificate;
var ada = BigInt(1000000);
function certToDepositLovelaces(cert) {
    var t = cert.certType;
    if (t === CertificateType.StakeRegistration)
        return BigInt(2) * ada;
    if (t === CertificateType.StakeDeRegistration)
        return BigInt(-2) * ada;
    if (t === CertificateType.PoolRegistration)
        return BigInt(500) * ada;
    if (t === CertificateType.PoolRetirement)
        return BigInt(-500) * ada;
    return BigInt(0);
}
exports.certToDepositLovelaces = certToDepositLovelaces;
function certificatesToDepositLovelaces(certs) {
    return certs.reduce(function (a, b) { return a + certToDepositLovelaces(b); }, BigInt(0));
}
exports.certificatesToDepositLovelaces = certificatesToDepositLovelaces;
