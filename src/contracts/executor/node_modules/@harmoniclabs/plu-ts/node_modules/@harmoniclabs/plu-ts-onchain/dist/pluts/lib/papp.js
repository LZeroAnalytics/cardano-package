"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.papp = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../../utils/assert.js");
var Term_1 = require("../Term/index.js");
var includesDynamicPairs_1 = require("../type_system/includesDynamicPairs.js");
var typeExtends_1 = require("../type_system/typeExtends.js");
var types_1 = require("../type_system/types.js");
var utils_1 = require("../type_system/utils.js");
var addUtilityForType_1 = require("./std/UtilityTerms/addUtilityForType.js");
var pappArg_1 = require("./pappArg.js");
var fromData_minimal_1 = require("./std/data/conversion/fromData_minimal.js");
var IRVar_1 = require("../../IR/IRNodes/IRVar.js");
var IRFunc_1 = require("../../IR/IRNodes/IRFunc.js");
var IRNative_1 = require("../../IR/IRNodes/IRNative/index.js");
var IRHoisted_1 = require("../../IR/IRNodes/IRHoisted.js");
var IRApp_1 = require("../../IR/IRNodes/IRApp.js");
var IRError_1 = require("../../IR/IRNodes/IRError.js");
function isIdentityIR(ir) {
    return ((ir instanceof IRHoisted_1.IRHoisted && isIdentityIR(ir.hoisted)) ||
        (ir instanceof IRNative_1.IRNative && ir.tag === -15 /* IRNativeTag._id */) ||
        (ir instanceof IRFunc_1.IRFunc &&
            ir.body instanceof IRVar_1.IRVar &&
            ir.body.dbn === 0));
}
function unwrapDataIfNeeded(input, expectedInputTy) {
    input = (
    // we know the actual type that the data represents
    input.type[0] === "asData" /* PrimType.AsData */ &&
        // and the function is not expecting actually data
        !(0, typeExtends_1.typeExtends)(expectedInputTy, types_1.data)) ?
        // transform to the value
        (0, fromData_minimal_1._fromData)(input.type[1])(input) :
        // keep the data
        input;
    return input;
}
/**
 *
 * @param {Term<PLam<Input, Output>>} a Term that evalueates to an UPLC function ( type: ```Type.Lambda( inputT, outputT )``` )
 * @param {Term<Input>} b the argument of to provide to the first parameter
 * @returns {Term<Output>} the result of the calculation
 *
 * if the type of the output extends the type ```Type.Lambda( Type.Any, Type.Any )```
 */
function papp(a, b) {
    var _a;
    var lambdaType = a.type;
    if (!(lambdaType[0] === "lam" /* PrimType.Lambda */))
        throw new Error("a term not representing a Lambda (aka. Type.Lambda) was passed to an application");
    var _b;
    if (b instanceof Term_1.Term) {
        // unwrap 'asData' if is the case
        b = unwrapDataIfNeeded(b, lambdaType[1]);
        (0, assert_1.assert)((0, typeExtends_1.typeExtends)(b.type, lambdaType[1]), "while applying 'Lambda'; unexpected type of input;\n\nit should be possible to assign the input to \"" + (0, utils_1.termTypeToString)(lambdaType[1]) +
            "\";\nreceived input was of type: \"" + (0, utils_1.termTypeToString)(b.type) + "\"" +
            "\n\noutput would be of type: \"" + (0, utils_1.termTypeToString)(a.type[2]) + "\"");
        _b = b;
    }
    else {
        _b = (0, pappArg_1.pappArgToTerm)(b, lambdaType[1]);
    }
    var outputType = lambdaType[2]; // applyLambdaType( lambdaType, _b.type );
    var e_stack = (_a = Error().stack) === null || _a === void 0 ? void 0 : _a.split("\n");
    var n = 2;
    var src = e_stack ?
        e_stack[2].includes("$ ") ?
            e_stack[n = 3] :
            e_stack[2]
        : undefined;
    var outputTerm = (0, addUtilityForType_1.addUtilityForType)(outputType)(new Term_1.Term(outputType, function (dbn) {
        var funcIR;
        if (_b.__isDynamicPair || ((0, includesDynamicPairs_1.includesDynamicPairs)(_b.type) && !(0, includesDynamicPairs_1.includesDynamicPairs)(lambdaType[1]))) {
            if (!(0, obj_utils_1.hasOwn)(a, "unsafeWithInputOfType")) {
                funcIR = a.toIR(dbn);
            }
            else
                funcIR = a.unsafeWithInputOfType(_b.type).toIR(dbn);
        }
        else {
            funcIR = a.toIR(dbn);
        }
        if (funcIR instanceof IRError_1.IRError)
            return funcIR;
        var argIR = _b.toIR(dbn);
        if (argIR instanceof IRError_1.IRError)
            return argIR;
        // omit id function
        if (isIdentityIR(funcIR))
            return argIR;
        var app = new IRApp_1.IRApp(funcIR, argIR, { __src__: src });
        return app;
    }, false // isConstant
    ));
    if ((outputTerm.type[0] === "lam" /* PrimType.Lambda */) && (!(0, obj_utils_1.hasOwn)(outputTerm, "$")))
        // defined "$" property can be overridden but not deleted
        // override is necessary to allow a more specific implementation
        // 
        // example is for lazy builtins such as ```pif``` that need to modify the input
        // wrapping it into a "Delay"
        return (0, obj_utils_1.defineNonDeletableNormalProperty)(outputTerm, "$", function (someInput) { return papp(outputTerm, someInput); });
    return outputTerm;
}
exports.papp = papp;
