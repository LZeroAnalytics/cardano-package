"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockPStructMethods = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var isWellFormedType_1 = require("../../../../type_system/kinds/isWellFormedType.js");
var types_1 = require("../../../../type_system/types.js");
var makeMockTerm_1 = require("./makeMockTerm.js");
var makeMockUtilityTerm_1 = require("./makeMockUtilityTerm.js");
var mockPBoolMethods_1 = require("./mockPBoolMethods.js");
var mockPIntMethods_1 = require("./mockPIntMethods.js");
var mockPListMethods_1 = require("./mockPListMethods.js");
var mockUserMethods_1 = require("./mockUserMethods.js");
function mockPStructMethods(struct) {
    var t = struct.type;
    if (!(0, isWellFormedType_1.isStructType)(t))
        return struct;
    var sDef = t[1];
    if (typeof sDef === "symbol" || !(0, isWellFormedType_1.isStructDefinition)(sDef))
        return struct;
    var ctors = Object.keys(sDef);
    // shortcut for single ctors structs
    if (ctors.length === 1) {
        var ctorName = ctors[0];
        var ctor = sDef[ctorName];
        var fieldsNames = Object.keys(ctor);
        var nFields = fieldsNames.length;
        var letted_fieldsListData = (0, makeMockTerm_1.makeMockTerm)((0, types_1.list)(types_1.data));
        for (var i = 0; i < nFields; i++) {
            var thisFieldName = fieldsNames[i];
            var thisFieldType = ctor[thisFieldName];
            (!(0, obj_utils_1.hasOwn)(struct, thisFieldName)) && Object.defineProperty(struct, thisFieldName, {
                value: (0, makeMockUtilityTerm_1.makeMockUtilityTerm)(thisFieldType),
                writable: false,
                enumerable: true,
                configurable: false
            });
        }
        /**
         * @deprecated
         */
        (0, obj_utils_1.defineReadOnlyProperty)(struct, "extract", function () {
            var fields = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fields[_i] = arguments[_i];
            }
            return {
                in: function (expr) { return expr(struct); }
            };
        });
    }
    (0, obj_utils_1.definePropertyIfNotPresent)(struct, "peq", {
        get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, types_1.lam)(types_1.data, types_1.bool)); },
        set: function () { },
        configurable: false,
        enumerable: true
    });
    (0, obj_utils_1.defineReadOnlyProperty)(struct, "eq", function (other) { return (0, mockPBoolMethods_1.makeMockTermBool)(); });
    // const letted_unconstred = makeMockTerm( pair( int, list( data ) ) );
    var letted_ctorIdx = (0, makeMockTerm_1.makeMockTerm)(types_1.int);
    var letted_rawFields = (0, makeMockTerm_1.makeMockTerm)((0, types_1.list)(types_1.data));
    (0, obj_utils_1.defineReadOnlyProperty)(struct, "raw", Object.freeze({
        index: (0, mockPIntMethods_1.mockPIntMethods)(letted_ctorIdx),
        fields: (0, mockPListMethods_1.mockPListMethods)(letted_rawFields)
    }));
    struct = (0, mockUserMethods_1.mockUserMethods)(struct, t[2]);
    return struct;
}
exports.mockPStructMethods = mockPStructMethods;
