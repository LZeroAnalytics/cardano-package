"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyEd25519Signature = exports.getEd25519Signature = exports.signEd25519 = exports.deriveEd25519PublicKey = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var sha2_512_1 = require("./sha2_512.js");
var types_1 = require("./types.js");
var positiveMod_1 = require("./utils/positiveMod.js");
var assert_1 = require("./utils/assert.js");
var bigintToBuffer_1 = require("./utils/bigintToBuffer.js");
var Q = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"); // ipowi(255) - 19
var Q38 = BigInt("7237005577332262213973186563042994240829374041602535252466099000494570602494"); // (Q + 3)/8
var CURVE_ORDER = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"); // ipow2(252) + 27742317777372353535851937790883648493;
var D = -BigInt("4513249062541557337682894930092624173785641285191125241628941591882900924598840740"); // -121665 * invert(121666);
var I = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); // expMod(BigInt( 2 ), (Q - BigInt( 1 ))/4, Q);
var BASE = Object.freeze([
    BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") // (4*invert(5)) % Q
]);
/**
 *
 * @param {bigint} b
 * @param {bigint} e
 * @param {bigint} m
 * @returns {bigint}
 */
function expMod(b, e, m) {
    if (e == BigInt(0)) {
        return BigInt(1);
    }
    else {
        var t = expMod(b, e / BigInt(2), m);
        t = (t * t) % m;
        if ((e % BigInt(2)) != BigInt(0)) {
            t = (0, positiveMod_1.positiveMod)(t * b, m);
        }
        return t;
    }
}
function invert(n) {
    var a = (0, positiveMod_1.positiveMod)(n, Q);
    var b = Q;
    var x = BigInt(0);
    var y = BigInt(1);
    var u = BigInt(1);
    var v = BigInt(0);
    while (a !== BigInt(0)) {
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n_1 = y - v * q;
        b = a;
        a = r;
        x = u;
        y = v;
        u = m;
        v = n_1;
    }
    return (0, positiveMod_1.positiveMod)(x, Q);
}
/**
 * @param {bigint} y
 * @returns {bigint}
 */
function recoverX(y) {
    var yy = y * y;
    var xx = (yy - BigInt(1)) * invert(D * yy + BigInt(1));
    var x = expMod(xx, Q38, Q);
    if (((x * x - xx) % Q) !== BigInt(0)) {
        x = (x * I) % Q;
    }
    if ((x % BigInt(2)) !== BigInt(0)) {
        x = Q - x;
    }
    return x;
}
/**
 * Curve point 'addition'
 * Note: this is probably the bottleneck of this Ed25519 implementation
 */
function edwards(a, b) {
    var x1 = a[0];
    var y1 = a[1];
    var x2 = b[0];
    var y2 = b[1];
    var dxxyy = D * x1 * x2 * y1 * y2;
    var x3 = (x1 * y2 + x2 * y1) * invert(BigInt(1) + dxxyy);
    var y3 = (y1 * y2 + x1 * x2) * invert(BigInt(1) - dxxyy);
    return [(0, positiveMod_1.positiveMod)(x3, Q), (0, positiveMod_1.positiveMod)(y3, Q)];
}
function scalarMul(point, n) {
    if (n === BigInt(0)) {
        return [BigInt(0), BigInt(1)];
    }
    else {
        var sum = scalarMul(point, n / BigInt(2));
        sum = edwards(sum, sum);
        if ((n % BigInt(2)) !== BigInt(0)) {
            sum = edwards(sum, point);
        }
        return sum;
    }
}
/**
 * Curve point 'multiplication'
 */
function encodeInt(y) {
    var bytes = Array.from((0, bigintToBuffer_1.bigintToBuffer)(y)).reverse();
    while (bytes.length < 32) {
        bytes.push(0);
    }
    return bytes;
}
function decodeInt(s) {
    return BigInt("0x" + (0, types_1.byteArrToHex)(s.reverse()));
}
function encodePoint(point) {
    var _a = __read(point, 2), x = _a[0], y = _a[1];
    var bytes = encodeInt(y);
    // last bit is determined by x
    bytes[31] = ((bytes[31] & 255) | (Number(x & BigInt(1)) * 128));
    return bytes;
}
function getBit(bytes, i) {
    return ((bytes[Math.floor(i / 8)] >> i % 8) & 1);
}
function isOnCurve(point) {
    var x = point[0];
    var y = point[1];
    var xx = x * x;
    var yy = y * y;
    return (-xx + yy - BigInt(1) - D * xx * yy) % Q == BigInt(0);
}
function decodePoint(s) {
    (0, assert_1.assert)(s.length == 32, "point must have length of 32");
    var bytes = s.slice();
    bytes[31] = (bytes[31] & 127);
    var y = decodeInt(bytes);
    var x = recoverX(y);
    if (Number(x & BigInt(1)) != getBit(s, 255)) {
        x = Q - x;
    }
    var point = [x, y];
    if (!isOnCurve(point)) {
        throw new Error("point isn't on curve");
    }
    return point;
}
function getA(h) {
    var a = BigInt("28948022309329048855892746252171976963317496166410141009864396001978282409984"); // ipow2(253)
    var bytes = h.slice(0, 32);
    bytes[0] = (bytes[0] & 248);
    bytes[31] = (bytes[31] & 63);
    return a + BigInt("0x" + (0, types_1.byteArrToHex)(bytes.reverse()));
}
function ihash(m) {
    return decodeInt((0, sha2_512_1.sha2_512)(m));
}
function forceUint8Array(stuff) {
    if (typeof stuff === "string")
        return (0, uint8array_utils_1.fromHex)(stuff);
    return (0, uint8array_utils_1.isUint8Array)(stuff) ? stuff : new Uint8Array(stuff);
}
function deriveEd25519PublicKey(privateKey) {
    var privateKeyHash = (0, sha2_512_1.sha2_512)(privateKey);
    var a = getA(privateKeyHash);
    var A = scalarMul(BASE, a);
    return encodePoint(A);
}
exports.deriveEd25519PublicKey = deriveEd25519PublicKey;
function asBytes(stuff) {
    if (typeof stuff === "string")
        return asBytes((0, uint8array_utils_1.fromHex)(stuff));
    return Array.from(stuff);
}
function signEd25519(message, privateKey) {
    message = forceUint8Array(message);
    privateKey = forceUint8Array(privateKey);
    var privateKeyHash = (0, sha2_512_1.sha2_512)(asBytes(privateKey));
    var a = getA(privateKeyHash);
    // for convenience getulate publicKey here:
    var publicKey = encodePoint(scalarMul(BASE, a));
    var r = ihash(privateKeyHash.slice(32, 64).concat(asBytes(message)));
    var R = scalarMul(BASE, r);
    var S = (0, positiveMod_1.positiveMod)(r + ihash(encodePoint(R).concat(publicKey).concat(asBytes(message))) * a, CURVE_ORDER);
    return [new Uint8Array(publicKey), new Uint8Array(encodePoint(R).concat(encodeInt(S)))];
}
exports.signEd25519 = signEd25519;
function getEd25519Signature(message, privateKey) {
    return signEd25519(message, privateKey)[1];
}
exports.getEd25519Signature = getEd25519Signature;
function verifyEd25519Signature(signature, message, publicKey) {
    if (signature.length !== 64 || publicKey.length != 32) {
        throw new Error("unexpected signature length ".concat(signature.length));
    }
    if ((0, uint8array_utils_1.isUint8Array)(signature)) {
        signature = (0, types_1.buffToByteArr)(signature);
    }
    if ((0, uint8array_utils_1.isUint8Array)(message)) {
        message = (0, types_1.buffToByteArr)(message);
    }
    if ((0, uint8array_utils_1.isUint8Array)(publicKey)) {
        publicKey = (0, types_1.buffToByteArr)(publicKey);
    }
    var R = decodePoint(asBytes(signature).slice(0, 32));
    var A = decodePoint(asBytes(publicKey));
    var S = decodeInt(asBytes(signature).slice(32, 64));
    var h = ihash(asBytes(signature).slice(0, 32).concat(asBytes(publicKey)).concat(asBytes(message)));
    var left = scalarMul(BASE, S);
    var right = edwards(R, scalarMul(A, h));
    return (left[0] == right[0]) && (left[1] == right[1]);
}
exports.verifyEd25519Signature = verifyEd25519Signature;
