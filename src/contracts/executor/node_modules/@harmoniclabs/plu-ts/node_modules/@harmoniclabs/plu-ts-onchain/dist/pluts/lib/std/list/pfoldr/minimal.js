"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._pfoldr = void 0;
var type_system_1 = require("../../../../type_system/index.js");
var pdelay_1 = require("../../../pdelay.js");
var pfn_1 = require("../../../pfn.js");
var phoist_1 = require("../../../phoist.js");
var plam_1 = require("../../../plam.js");
var minimal_common_1 = require("../../data/conversion/minimal_common.js");
var minimal_1 = require("../precursiveList/minimal.js");
function _pfoldr(elemsT, resultT) {
    var a = elemsT;
    var b = resultT;
    var selfType = (0, type_system_1.lam)((0, type_system_1.list)(elemsT), resultT);
    return (0, phoist_1.phoist)((0, pfn_1.pfn)([
        (0, type_system_1.fn)([a, b], b),
        b
    ], (0, type_system_1.lam)((0, type_system_1.list)(a), b))(function (reduceFunc, accumulator) {
        return (0, minimal_common_1._papp)((0, minimal_common_1._papp)((0, minimal_1._precursiveList)(resultT, elemsT), (0, plam_1.plam)(selfType, (0, type_system_1.delayed)(resultT))(function (_foldr) { return (0, pdelay_1.pdelay)(accumulator); })), (0, pfn_1.pfn)([
            selfType,
            elemsT,
            (0, type_system_1.list)(elemsT)
        ], resultT)(function (self, head, tail) {
            // compute new result using the result got
            // AFTER the recursive call on the rest of the list
            // and the first element of the list
            return (0, minimal_common_1._papp)((0, minimal_common_1._papp)(reduceFunc, head), (0, minimal_common_1._papp)(self, tail));
        }));
    }, "_pfoldr"));
}
exports._pfoldr = _pfoldr;
