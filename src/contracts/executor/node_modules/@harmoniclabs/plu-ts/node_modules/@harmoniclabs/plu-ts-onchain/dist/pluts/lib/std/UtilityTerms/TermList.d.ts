import { PType } from "../../../PType/index.js";
import { PDataRepresentable } from "../../../PType/PDataRepresentable.js";
import type { PList, TermFn, PInt, PLam, PBool, PPair } from "../../../PTypes/index.js";
import { Term } from "../../../Term/index.js";
import { ToPType, TermType } from "../../../type_system/index.js";
import { UtilityTermOf } from "./addUtilityForType.js";
import { PappArg } from "../../pappArg.js";
import { type PMaybeT } from "../PMaybe/PMaybe.js";
import { TermBool } from "./TermBool.js";
import { TermInt } from "./TermInt.js";
export type TermList<PElemsT extends PDataRepresentable> = Term<PList<PElemsT>> & {
    /**
     * **O(1)**
     *
     * @returns the first element fo the list
     *
     * > **fails the smart contract with `perror`** if the list is empty
     */
    readonly head: UtilityTermOf<PElemsT>;
    /**
     * **O(1)**
     *
     * @returns a list containing the same elements of the one called on exept for the first
     *
     * js equivalent:
     * ```js
     * list.slice(1)
     * ```
     *
     * > **fails the smart contract with `perror`** if the list is empty
     */
    readonly tail: TermList<PElemsT>;
    /**
     * **O(n)**
     *
     * @returns the length of the list
     *
     * > **suggestion**: use `plet` bindings if you need to access the list length more than once
     * >
     * > example:
     * > ```ts
     * > plet( list.length ).in( length => ... )
     * > ```
     */
    readonly length: TermInt;
    /**
     * **O(n)**
     *
     * @returns a new list with the same elements in the opposite order
     *
     * > **suggestion**: use `plet` bindings if you need to access the list length more than once
     * >
     * > example:
     * > ```ts
     * > plet( list.reversed ).in( reversed => ... )
     * > ```
    **/
    readonly reversed: TermList<PElemsT>;
    readonly pat: TermFn<[PInt], PElemsT>;
    readonly at: (index: PappArg<PInt>) => UtilityTermOf<PElemsT>;
    readonly pfind: TermFn<[PLam<PElemsT, PBool>], PMaybeT<PElemsT>>;
    readonly find: (predicate: PappArg<PLam<PElemsT, PBool>>) => Term<PMaybeT<PElemsT>>;
    readonly pfilter: TermFn<[PLam<PElemsT, PBool>], PList<PElemsT>>;
    readonly filter: (predicate: PappArg<PLam<PElemsT, PBool>>) => TermList<PElemsT>;
    readonly pprepend: TermFn<[PElemsT], PList<PElemsT>>;
    readonly prepend: (elem: PappArg<PElemsT>) => TermList<PElemsT>;
    readonly pmap: <ResultT extends TermType>(resultT: ResultT) => TermFn<[PLam<PElemsT, ToPType<ResultT>>], PList<ToPType<ResultT>>>;
    readonly map: <PResultElemT extends PType>(f: PappArg<PLam<PElemsT, PResultElemT>>) => TermList<PResultElemT>;
    readonly pevery: TermFn<[PLam<PElemsT, PBool>], PBool>;
    readonly every: (predicate: PappArg<PLam<PElemsT, PBool>>) => TermBool;
    readonly psome: TermFn<[PLam<PElemsT, PBool>], PBool>;
    readonly some: (predicate: PappArg<PLam<PElemsT, PBool>>) => TermBool;
    /** @since v0.5.0 */
    readonly pincludes: TermFn<[PElemsT], PBool>;
    /** @since v0.5.0 */
    readonly includes: (elem: PappArg<PElemsT>) => TermBool;
    /** @since v0.5.0 */
    readonly peq: TermFn<[PList<PElemsT>], PBool>;
    /** @since v0.5.0 */
    readonly eq: (other: PappArg<PList<PElemsT>>) => TermBool;
} & (PElemsT extends PPair<infer PK extends PType, infer PV extends PType> ? {
    /** @since v0.5.0 */
    readonly plookup: TermFn<[PK], PMaybeT<PV>>;
    /** @since v0.5.0 */
    readonly lookup: (predicate: PappArg<PK>) => UtilityTermOf<PMaybeT<PV>>;
} : {});
export declare function addPListMethods<PElemsT extends PType>(_lst: Term<PList<PElemsT>>): TermList<PElemsT>;
