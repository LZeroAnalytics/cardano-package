import type { PType } from "../PType/index.js";
import type { PLam, PInt, PBool, PByteString, PString, PUnit, PPair, PAlias } from "../PTypes/index.js";
import { UtilityTermOf } from "./std/UtilityTerms/addUtilityForType.js";
import { Term } from "../Term/index.js";
import { TermType, ToPType, GenericTermType } from "../type_system/index.js";
import { ByteString } from "@harmoniclabs/bytestring";
import { Pair } from "@harmoniclabs/pair";
type _TsFunctionSatisfying<KnownArgs extends Term<PType>[], POut extends PType> = POut extends PLam<infer POutIn extends PType, infer POutOut extends PType> ? (_TsFunctionSatisfying<[...KnownArgs, UtilityTermOf<POutIn>], POutOut>) : (...args: KnownArgs) => Term<POut>;
export type TsFunctionSatisfying<PIn extends PType, POut extends PType> = _TsFunctionSatisfying<[UtilityTermOf<PIn>], POut>;
export type PappArg<PIn extends PType> = (PIn extends PAlias<infer PAliased extends PType, infer _> ? PappArg<PAliased> : PIn extends PInt ? bigint | number : PIn extends PBool ? boolean : PIn extends PByteString ? ByteString | Uint8Array | string : PIn extends PString ? string : PIn extends PUnit ? undefined | null : PIn extends PPair<infer PFst extends PType, infer PSnd extends PType> ? Pair<PappArg<PFst>, PappArg<PSnd>> | {
    fst: PappArg<PFst>;
    snd: PappArg<PSnd>;
} | [PappArg<PFst>, PappArg<PSnd>] : PIn extends PLam<infer PIn extends PType, infer POut extends PType> ? TsFunctionSatisfying<PIn, POut> : Term<PIn>) | Term<PIn> | Term<PAlias<PIn, any>>;
export declare function pappArgToTerm<ArgT extends TermType>(arg: PappArg<ToPType<ArgT>>, mustExtend?: GenericTermType): UtilityTermOf<ToPType<ArgT>>;
export {};
