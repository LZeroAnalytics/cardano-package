"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Term = void 0;
var plutus_machine_1 = require("@harmoniclabs/plutus-machine");
var uplc_1 = require("@harmoniclabs/uplc");
var IRConst_1 = require("../../IR/IRNodes/IRConst.js");
var IRError_1 = require("../../IR/IRNodes/IRError.js");
var IRHoisted_1 = require("../../IR/IRNodes/IRHoisted.js");
var compileIRToUPLC_1 = require("../../IR/toUPLC/compileIRToUPLC.js");
var type_system_1 = require("../type_system/index.js");
var cloneTermType_1 = require("../type_system/cloneTermType.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var Cloneable_1 = require("../../utils/Cloneable.js");
var assert_1 = require("../../utils/assert.js");
var Term = /** @class */ (function () {
    function Term(type, _toIR, isConstant) {
        if (isConstant === void 0) { isConstant = false; }
        var _this = this;
        (0, assert_1.assert)((0, type_system_1.isWellFormedGenericType)(type) ||
            Boolean(void console.log((0, type_system_1.termTypeToString)(type))), "invalid type while constructing Term");
        var _type = (0, cloneTermType_1.cloneTermType)(type);
        Object.defineProperty(this, "type", {
            get: function () { return (0, cloneTermType_1.cloneTermType)(_type); },
            set: function () { },
            enumerable: true,
            configurable: false
        });
        var _toIR_ = _toIR.bind(this);
        var shouldHoist = false;
        var _IR_cache = {};
        Object.defineProperty(this, "toIR", {
            value: function (deBruijnLevel) {
                if (deBruijnLevel === void 0) { deBruijnLevel = 0; }
                var dbnStr = deBruijnLevel.toString();
                var _cacheHit = _IR_cache[shouldHoist ? "hoisted" : dbnStr];
                if (_cacheHit)
                    return _cacheHit.clone();
                if (typeof deBruijnLevel !== "bigint")
                    deBruijnLevel = BigInt(deBruijnLevel);
                var ir = _toIR_(deBruijnLevel);
                if (shouldHoist) {
                    var res = new IRHoisted_1.IRHoisted(ir);
                    _IR_cache["hoisted"] = res.clone();
                    return res;
                }
                if (!(ir instanceof IRHoisted_1.IRHoisted) &&
                    _this.isConstant) {
                    // console.log( showIR( ir ).text );
                    // logJson( ir )
                    // !!! IMPORTANT !!!
                    // `compileIRToUPLC` modifies the `IRTerm` in place !
                    // as for the current implementation we don't care
                    // because we are going to re-assign the variable `ir` anyway
                    // if this ever changes make sure to call `ir.clone()`
                    var uplc = (0, compileIRToUPLC_1.compileIRToUPLC)(ir /*.clone()*/);
                    // console.log( showUPLC( uplc ) )
                    // !!! IMPORTANT !!!
                    // pair creation assumes this evaluation is happening here
                    // if for whatever reason this is removed please adapt the rest of the codebas
                    uplc = plutus_machine_1.Machine.evalSimple(uplc);
                    if (uplc instanceof uplc_1.UPLCConst) {
                        ir = new IRConst_1.IRConst(_this.type, uplc.value);
                    }
                    else {
                        ir = new IRError_1.IRError();
                    }
                }
                _IR_cache[dbnStr] = ir.clone();
                return ir;
            },
            writable: false,
            enumerable: true,
            configurable: false
        });
        var _UPLC_cache = {};
        Object.defineProperty(this, "toUPLC", {
            value: function (deBruijnLevel) {
                if (deBruijnLevel === void 0) { deBruijnLevel = 0; }
                var key = shouldHoist ? "hoisted" : deBruijnLevel.toString();
                var _cacheHit = _UPLC_cache[key];
                if (_cacheHit)
                    return _cacheHit.clone();
                var res = (0, compileIRToUPLC_1.compileIRToUPLC)(_this.toIR(deBruijnLevel));
                _UPLC_cache[key] = res.clone();
                return res;
            },
            writable: false,
            enumerable: true,
            configurable: false
        });
        (0, obj_utils_1.defineReadOnlyHiddenProperty)(this, "hoist", function () {
            shouldHoist = true;
        });
        var _isConstant = false;
        Object.defineProperty(this, "isConstant", {
            get: function () { return _isConstant; },
            set: function (isConst) {
                if (typeof isConst !== "boolean")
                    return;
                _isConstant = isConst;
            },
            enumerable: false,
            configurable: false
        });
        // calls the `set` function of the descriptor above;
        this.isConstant = isConstant;
        Object.defineProperty(this, "clone", {
            value: function () {
                var cloned = new Term(_this.type, _toIR_, Boolean(_this.isConstant) // isConstant
                );
                Object.keys(_this).forEach(function (k) {
                    var _a;
                    if (k === "_type" || k === "toUPLC" || k === "toIR")
                        return;
                    Object.defineProperty(cloned, k, (_a = Object.getOwnPropertyDescriptor(_this, k)) !== null && _a !== void 0 ? _a : {});
                });
                if (shouldHoist) {
                    cloned.hoist();
                }
                return cloned;
            },
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
    Object.defineProperty(Term.prototype, "pInstance", {
        get: function () {
            if (this._pInstance === undefined)
                return undefined;
            return (0, Cloneable_1.isCloneable)(this._pInstance) ?
                this._pInstance.clone() :
                this._pInstance;
        },
        enumerable: false,
        configurable: true
    });
    return Term;
}());
exports.Term = Term;
