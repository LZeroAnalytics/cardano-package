"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterTree = void 0;
var IRApp_1 = require("../../IRNodes/IRApp.js");
var IRDelayed_1 = require("../../IRNodes/IRDelayed.js");
var IRForced_1 = require("../../IRNodes/IRForced.js");
var IRFunc_1 = require("../../IRNodes/IRFunc.js");
var IRHoisted_1 = require("../../IRNodes/IRHoisted.js");
var IRLetted_1 = require("../../IRNodes/IRLetted.js");
function iterTree(_term, fn, 
// necessary for letted hash calculation (exclude hoisted)
shouldSkipNode) {
    var has_shouldSkipNode = typeof shouldSkipNode === "function";
    var stack = [{ term: _term, dbn: 0 }];
    while (stack.length > 0) {
        var _a = stack.pop(), t = _a.term, dbn = _a.dbn;
        if (has_shouldSkipNode && shouldSkipNode(t, dbn))
            continue;
        var termParent = t.parent;
        var negDbn = t instanceof IRFunc_1.IRFunc ? t.arity : 0;
        var modifiedParent = fn(t, dbn) === true;
        if (modifiedParent && termParent !== undefined) {
            if (stack.length > 0 && stack[stack.length - 1].isIRAppArg) {
                // there is an extra node 
                stack.pop();
            }
            stack.push({ term: termParent, dbn: dbn - negDbn });
            continue;
        }
        if (t instanceof IRApp_1.IRApp) {
            stack.push({ term: t.fn, dbn: dbn }, { term: t.arg, dbn: dbn, isIRAppArg: true });
            continue;
        }
        if (t instanceof IRDelayed_1.IRDelayed) {
            stack.push({ term: t.delayed, dbn: dbn });
            continue;
        }
        if (t instanceof IRForced_1.IRForced) {
            stack.push({ term: t.forced, dbn: dbn });
            continue;
        }
        if (t instanceof IRFunc_1.IRFunc) {
            stack.push({ term: t.body, dbn: dbn + t.arity });
            continue;
        }
        if (t instanceof IRHoisted_1.IRHoisted) {
            // 0 because hoisted are closed
            // for hoisted we keep track of the depth inside the term
            stack.push({ term: t.hoisted, dbn: 0 });
            continue;
        }
        if (t instanceof IRLetted_1.IRLetted) {
            // same stuff as the hoisted terms
            // the only difference is that depth is then incremented
            // once the letted term reaches its final position
            stack.push({ term: t.value, dbn: dbn });
            continue;
        }
    }
}
exports.iterTree = iterTree;
