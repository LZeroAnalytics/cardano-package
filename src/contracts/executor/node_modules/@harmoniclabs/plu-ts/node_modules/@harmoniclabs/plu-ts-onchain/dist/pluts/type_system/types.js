"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tyVar = exports.asData = exports.alias = exports.struct = exports.delayed = exports.fn = exports.lam = exports.map = exports._pair = exports.pair = exports.list = exports.data = exports.bool = exports.unit = exports.str = exports.bs = exports.int = exports.cloneStructDef = exports.cloneStructCtorDef = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../../utils/assert.js");
var tyArgs_1 = require("./tyArgs/index.js");
function cloneStructCtorDef(ctorDef) {
    var clone = {};
    for (var fieldName in ctorDef) {
        clone[fieldName] = ctorDef[fieldName];
    }
    return clone;
}
exports.cloneStructCtorDef = cloneStructCtorDef;
function cloneStructDef(def) {
    var clone = {};
    var ctors = Object.keys(def);
    for (var i = 0; i < ctors.length; i++) {
        (0, obj_utils_1.defineReadOnlyProperty)(clone, ctors[i], cloneStructCtorDef(def[ctors[i]]));
    }
    return clone;
}
exports.cloneStructDef = cloneStructDef;
exports.int = Object.freeze(["int" /* PrimType.Int */]);
exports.bs = Object.freeze(["bs" /* PrimType.BS */]);
exports.str = Object.freeze(["str" /* PrimType.Str */]);
exports.unit = Object.freeze(["unit" /* PrimType.Unit */]);
exports.bool = Object.freeze(["bool" /* PrimType.Bool */]);
exports.data = Object.freeze(["data" /* PrimType.Data */]);
var list = function (ofElem) {
    return Object.freeze(["list" /* PrimType.List */, ofElem]);
};
exports.list = list;
var pair = function (fst, snd) {
    // all pairs must be "asData"; breaks uplc otherwhise
    return (Object.freeze(["pair" /* PrimType.Pair */, asData(fst), asData(snd)]));
};
exports.pair = pair;
var _pair = function (fst, snd) {
    // all pairs must be "asData"; breaks uplc otherwhise
    return (Object.freeze(["pair" /* PrimType.Pair */, fst, snd]));
};
exports._pair = _pair;
var map = function (fst, snd) {
    return (0, exports.list)((0, exports.pair)(fst, snd));
};
exports.map = map;
var lam = function (input, output) {
    return Object.freeze(["lam" /* PrimType.Lambda */, input, output]);
};
exports.lam = lam;
var fn = function (inputs, output) {
    (0, assert_1.assert)(inputs.length > 0, "unsupported '(void) => any' type at Pluts level");
    if (inputs.length === 1)
        return Object.freeze((0, exports.lam)(inputs[0], output));
    return Object.freeze((0, exports.lam)(inputs[0], (0, exports.fn)(inputs.slice(1), output)));
};
exports.fn = fn;
var delayed = function (toDelay) {
    return Object.freeze(["delayed" /* PrimType.Delayed */, toDelay]);
};
exports.delayed = delayed;
var struct = function (def, methods) {
    return Object.freeze([
        "struct" /* PrimType.Struct */,
        Object.freeze(cloneStructDef(def)),
        Object.freeze(methods !== null && methods !== void 0 ? methods : {})
    ]);
};
exports.struct = struct;
function alias(toAlias, methods) {
    if (toAlias[0] === "alias" /* PrimType.Alias */)
        return toAlias;
    return Object.freeze(["alias" /* PrimType.Alias */, toAlias, Object.freeze(methods !== null && methods !== void 0 ? methods : {})]);
}
exports.alias = alias;
function asData(someT) {
    // invalid asData type but not worth to rise an error
    if (someT[0] === "lam" /* PrimType.Lambda */ ||
        someT[0] === "delayed" /* PrimType.Delayed */)
        return someT;
    // already data
    if (someT[0] === "struct" /* PrimType.Struct */ ||
        someT[0] === "data" /* PrimType.Data */ ||
        someT[0] === "asData" /* PrimType.AsData */)
        return someT;
    // map `asData` down if the type is structured
    // if the type is an alias temporarely unwrap;
    // this to prevent blocking the mapping of `asData`
    var exAliasMethods = undefined;
    if (someT[0] === "alias" /* PrimType.Alias */) {
        exAliasMethods = someT[2];
        someT = someT[1];
    }
    // here mapping
    if (someT[0] === "list" /* PrimType.List */) {
        var elemsT = (0, tyArgs_1.getElemsT)(someT);
        if (elemsT[0] === "pair" /* PrimType.Pair */) {
            someT = (0, exports.list)((0, exports.pair)(asData(elemsT[1]), asData(elemsT[2])));
        }
        else if (elemsT[0] === "alias" /* PrimType.Alias */ &&
            elemsT[1][0] === "pair" /* PrimType.Pair */) {
            someT = (0, exports.list)((0, exports.pair)(asData(elemsT[1][1]), asData(elemsT[1][2])));
            someT = alias(someT, elemsT[2]);
        }
        else {
            someT = (0, exports.list)(asData(elemsT));
        }
    }
    // re-wrap in alias if it was infact an alias
    // before finally wrapping everything in `asData`
    if (typeof exAliasMethods !== "undefined")
        someT = alias(someT, exAliasMethods);
    return Object.freeze(["asData" /* PrimType.AsData */, someT]);
}
exports.asData = asData;
exports.tyVar = (function (description) { return Object.freeze([Symbol(description)]); });
// | [ PrimType.List, GenericTermType ]
// | [ PrimType.Delayed, GenericTermType ]
// | [ PrimType.Pair , GenericTermType, GenericTermType ]
// | [ PrimType.Lambda , GenericTermType, GenericTermType ]
// | [ PrimType.AsData, GenericTermType ]
