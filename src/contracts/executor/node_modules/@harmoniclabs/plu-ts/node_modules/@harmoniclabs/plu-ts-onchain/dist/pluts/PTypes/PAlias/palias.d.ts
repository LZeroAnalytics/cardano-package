import type { Term } from "../../Term/index.js";
import { AliasT, Methods, TermType } from "../../type_system/types.js";
import { PDataRepresentable } from "../../PType/PDataRepresentable.js";
import { PData } from "../PData/PData.js";
import { FromPType, ToPType } from "../../type_system/ts-pluts-conversion.js";
import { PType } from "../../PType/index.js";
import { PappArg } from "../../lib/pappArg.js";
import { TermAlias } from "../../lib/std/UtilityTerms/TermAlias.js";
/**
 * intermediate class useful to reconize structs form primitives
**/
declare class _PAlias extends PDataRepresentable {
    _isPType: true;
    _PTypeUPLCTerm: any;
    constructor();
}
export type PAlias<PT extends PType, AMethods extends Methods> = {
    new (): _PAlias;
    /**
     * @deprecated
    */
    readonly termType: AliasT<FromPType<PT>, AMethods>;
    readonly type: AliasT<FromPType<PT>, AMethods>;
    readonly fromData: (data: Term<PData>) => Term<PAlias<PT, AMethods>>;
    readonly toData: (data: Term<PAlias<PT, any>>) => Term<PData>;
    readonly from: (toAlias: PappArg<PT>) => TermAlias<PT, AMethods>;
} & PDataRepresentable;
export declare function palias<T extends TermType, AMethods extends Methods>(type: T, getMethods?: (self_t: AliasT<T, any>) => AMethods, fromDataConstraint?: ((term: Term<ToPType<T>>) => Term<ToPType<T>>) | undefined): PAlias<ToPType<T>, AMethods>;
export {};
