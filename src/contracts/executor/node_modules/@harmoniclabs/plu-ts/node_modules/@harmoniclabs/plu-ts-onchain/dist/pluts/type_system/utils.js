"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.termTypeFromJson = exports.termTypeToJson = exports.structDefFromJson = exports.structDefToJson = exports.ctorDefFromJson = exports.ctorDefToJson = exports.termTypeToString = exports.structDefToString = exports.ctorDefToString = exports.getNRequiredArgs = exports.getNRequiredLambdaArgs = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var isTaggedAsAlias_1 = require("./kinds/isTaggedAsAlias.js");
var unwrapAlias_1 = require("./tyArgs/unwrapAlias.js");
var types_1 = require("./types.js");
function getNRequiredLambdaArgs(type) {
    if (type[0] !== "lam" /* PrimType.Lambda */)
        return 0;
    return 1 + getNRequiredLambdaArgs(type[2]);
}
exports.getNRequiredLambdaArgs = getNRequiredLambdaArgs;
/**
 * @deprecated use ```getNRequiredLambdaArgs```
 */
exports.getNRequiredArgs = getNRequiredLambdaArgs;
function ctorDefToString(ctorDef, limit) {
    var e_1, _a;
    if (limit === void 0) { limit = Infinity; }
    if (limit <= 0)
        return "{ ... }";
    var fields = Object.keys(ctorDef);
    if (fields.length === 0)
        return "{}";
    var str = "{";
    try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
            var fieldName = fields_1_1.value;
            str += ' ' + fieldName + ": " + termTypeToString(ctorDef[fieldName], limit - 1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    str += " }";
    return str;
}
exports.ctorDefToString = ctorDefToString;
function structDefToString(def, limit) {
    var e_2, _a;
    if (limit === void 0) { limit = Infinity; }
    var ctors = Object.keys(def);
    var str = "{";
    try {
        for (var ctors_1 = __values(ctors), ctors_1_1 = ctors_1.next(); !ctors_1_1.done; ctors_1_1 = ctors_1.next()) {
            var ctor = ctors_1_1.value;
            str += ' ' + ctor + ": " + ctorDefToString(def[ctor], limit) + " },";
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (ctors_1_1 && !ctors_1_1.done && (_a = ctors_1.return)) _a.call(ctors_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    str = str.slice(0, str.length - 1) + " }";
    return str;
}
exports.structDefToString = structDefToString;
function termTypeToString(t, limit) {
    var _a;
    if (limit === void 0) { limit = Infinity; }
    if (limit <= 0)
        return "...";
    var tag = t[0];
    if (tag === "struct" /* PrimType.Struct */) {
        return "struct(" + (structDefToString(t[1], limit - 1)) + ")";
    }
    if ((0, isTaggedAsAlias_1.isTaggedAsAlias)(t)) {
        var aliased = termTypeToString((0, unwrapAlias_1.unwrapAlias)(t), limit - 1);
        return "alias(" + aliased + ")";
    }
    if (tag === "asData" /* PrimType.AsData */) {
        return "asData(" + (termTypeToString(t[1], limit - 1)) + ")";
    }
    if (tag === "list" /* PrimType.List */) {
        return "list(" + (termTypeToString(t[1], limit - 1)) + ")";
    }
    if (tag === "delayed" /* PrimType.Delayed */) {
        return "delayed(" + (termTypeToString(t[1], limit - 1)) + ")";
    }
    if (tag === "pair" /* PrimType.Pair */) {
        return "pair(" + (termTypeToString(t[1], limit - 1)) + "," + (termTypeToString(t[2], limit - 1)) + ")";
    }
    if (tag === "lam" /* PrimType.Lambda */) {
        return termTypeToString(t[1], limit - 1) + " -> " + termTypeToString(t[2], limit - 1);
    }
    if (typeof t[0] === "symbol")
        return "tyParam(" + ((_a = (t[0]).description) !== null && _a !== void 0 ? _a : "") + ")";
    if (!t.slice) {
        console.log(t);
        // return "";
    }
    var tyArgs = t.slice(1);
    return (t[0] + (tyArgs.length > 0 ? ',' : "") + tyArgs.map(function (t) { return termTypeToString(t, limit - 1); }).toString());
}
exports.termTypeToString = termTypeToString;
function ctorDefToJson(ctorDef) {
    var e_3, _a;
    var fields = Object.keys(ctorDef);
    var res = {};
    try {
        for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
            var fieldName = fields_2_1.value;
            res[fieldName] = termTypeToJson(ctorDef[fieldName]);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (fields_2_1 && !fields_2_1.done && (_a = fields_2.return)) _a.call(fields_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return res;
}
exports.ctorDefToJson = ctorDefToJson;
function ctorDefFromJson(j) {
    var e_4, _a;
    var fields = Object.keys(j);
    var res = {};
    try {
        for (var fields_3 = __values(fields), fields_3_1 = fields_3.next(); !fields_3_1.done; fields_3_1 = fields_3.next()) {
            var fieldName = fields_3_1.value;
            res[fieldName] = termTypeFromJson(j[fieldName]);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (fields_3_1 && !fields_3_1.done && (_a = fields_3.return)) _a.call(fields_3);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return res;
}
exports.ctorDefFromJson = ctorDefFromJson;
function structDefToJson(def) {
    var e_5, _a;
    var ctors = Object.keys(def);
    var res = {};
    try {
        for (var ctors_2 = __values(ctors), ctors_2_1 = ctors_2.next(); !ctors_2_1.done; ctors_2_1 = ctors_2.next()) {
            var ctor = ctors_2_1.value;
            res[ctor] = ctorDefToJson(def[ctor]);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (ctors_2_1 && !ctors_2_1.done && (_a = ctors_2.return)) _a.call(ctors_2);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return res;
}
exports.structDefToJson = structDefToJson;
function structDefFromJson(j) {
    var e_6, _a;
    var ctors = Object.keys(j);
    var res = {};
    try {
        for (var ctors_3 = __values(ctors), ctors_3_1 = ctors_3.next(); !ctors_3_1.done; ctors_3_1 = ctors_3.next()) {
            var ctor = ctors_3_1.value;
            res[ctor] = ctorDefFromJson(j[ctor]);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (ctors_3_1 && !ctors_3_1.done && (_a = ctors_3.return)) _a.call(ctors_3);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return res;
}
exports.structDefFromJson = structDefFromJson;
function termTypeToJson(t) {
    var tag = t[0];
    if (typeof tag === "symbol")
        return { tyParam: null };
    if (tag === "alias" /* PrimType.Alias */ || (0, isTaggedAsAlias_1.isTaggedAsAlias)(t)) {
        return {
            alias: termTypeToJson((0, unwrapAlias_1.unwrapAlias)(t))
        };
    }
    if (tag === "struct" /* PrimType.Struct */) {
        return {
            struct: structDefToJson(t[1])
        };
    }
    if (tag === "asData" /* PrimType.AsData */) {
        return {
            asData: termTypeToJson(t[1])
        };
    }
    if (tag === "list" /* PrimType.List */) {
        return {
            list: termTypeToJson(t[1])
        };
    }
    if (tag === "pair" /* PrimType.Pair */) {
        return {
            pair: {
                fst: termTypeToJson(t[1]),
                snd: termTypeToJson(t[2])
            }
        };
    }
    if (tag === "delayed" /* PrimType.Delayed */) {
        return {
            delayed: termTypeToJson(t[1])
        };
    }
    if (tag === "lam" /* PrimType.Lambda */) {
        return {
            lambda: {
                input: termTypeToJson(t[1]),
                output: termTypeToJson(t[2])
            }
        };
    }
    return tag;
}
exports.termTypeToJson = termTypeToJson;
function termTypeFromJson(json) {
    if (typeof json === "string")
        return [json];
    if (!(0, obj_utils_1.isObject)(json))
        throw new Error("unexpected json format for 'TermTypeJson'; not an object");
    var keys = Object.keys(json);
    if (keys.length !== 1)
        throw new Error("unexpected json format for 'TermTypeJson'; too many keys");
    var tag = keys[0];
    var j = json;
    if (tag === "alias")
        return (0, types_1.alias)(termTypeFromJson(j[tag]));
    if (tag === "asData")
        return (0, types_1.asData)(termTypeFromJson(j[tag]));
    if (tag === "list")
        return (0, types_1.list)(termTypeFromJson(j[tag]));
    if (tag === "delayed")
        return (0, types_1.delayed)(termTypeFromJson(j[tag]));
    if (tag === "pair")
        return (0, types_1.pair)(termTypeFromJson(j["pair"]["fst"]), termTypeFromJson(j["pair"]["snd"]));
    if (tag === "lambda")
        return (0, types_1.lam)(termTypeFromJson(j["lambda"]["input"]), termTypeFromJson(j["lambda"]["output"]));
    if (tag === "struct")
        return (0, types_1.struct)(structDefFromJson(j[tag]));
    if (tag === "tyParam")
        return (0, types_1.tyVar)();
    throw new Error("unexpected json format for 'TermTypeJson'; unknonw key: " + tag);
}
exports.termTypeFromJson = termTypeFromJson;
