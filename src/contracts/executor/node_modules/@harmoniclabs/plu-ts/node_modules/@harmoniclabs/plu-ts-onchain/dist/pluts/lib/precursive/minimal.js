"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._precursive = void 0;
var IRApp_1 = require("../../../IR/IRNodes/IRApp.js");
var IRNative_1 = require("../../../IR/IRNodes/IRNative/index.js");
var assert_1 = require("../../../utils/assert.js");
var Term_1 = require("../../Term/index.js");
var type_system_1 = require("../../type_system/index.js");
/**
 * for reference the "Z combinator in js": https://medium.com/swlh/y-and-z-combinators-in-javascript-lambda-calculus-with-real-code-31f25be934ec
 *
 * ```js
 *  const Zcombinator = (
 *  	Z => (
 *  		toMakeRecursive => Z( value => toMakeRecursive(toMakeRecursive)(value) )
 *  	)( toMakeRecursive => Z( value => toMakeRecursive(toMakeRecursive)(value)) )
 *  );
 * ```
 * of type
 * ```js
 * Z => toMakeRecursive => value => result
 * ```
 * and ```toMakeRecursive``` has to be of type
 * ```js
 * self => value => result
 * ```
 */
function _precursive(fnBody) {
    var a = (0, type_system_1.tyVar)("recursive_fn_a");
    var b = (0, type_system_1.tyVar)("recursive_fn_b");
    (0, assert_1.assert)((0, type_system_1.typeExtends)(fnBody.type, (0, type_system_1.lam)((0, type_system_1.lam)(a, b), (0, type_system_1.lam)(a, b))), "passed function body cannot be recursive; " +
        "the first argument is not a lambda or it doesn't take any input");
    var recursiveFn = new Term_1.Term(fnBody.type[2], function (dbn) { return new IRApp_1.IRApp(IRNative_1.IRNative.z_comb, fnBody.toIR(dbn)); });
    return (recursiveFn);
}
exports._precursive = _precursive;
