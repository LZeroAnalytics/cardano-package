"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plet = void 0;
var IRApp_1 = require("../../../IR/IRNodes/IRApp.js");
var IRFunc_1 = require("../../../IR/IRNodes/IRFunc.js");
var IRLetted_1 = require("../../../IR/IRNodes/IRLetted.js");
var IRVar_1 = require("../../../IR/IRNodes/IRVar.js");
var Term_1 = require("../../Term/index.js");
var fromData_minimal_1 = require("../std/data/conversion/fromData_minimal.js");
var IRHoisted_1 = require("../../../IR/IRNodes/IRHoisted.js");
var isClosedIRTerm_1 = require("../../../IR/utils/isClosedIRTerm.js");
var addUtilityForType_1 = require("../std/UtilityTerms/addUtilityForType.js");
var makeMockUtilityTerm_1 = require("../std/UtilityTerms/mockUtilityTerms/makeMockUtilityTerm.js");
var getCallStackAt_1 = require("../../../utils/getCallStackAt/index.js");
function plet(varValue, value_name) {
    // unwrap 'asData' if is the case
    varValue = (varValue.type[0] === "asData" /* PrimType.AsData */ ? (0, fromData_minimal_1._fromData)(varValue.type[1])(varValue) : varValue);
    var type = varValue.type;
    var valueNameIsPresent = typeof value_name === "string";
    value_name = valueNameIsPresent ? value_name : undefined;
    var callStackSite = (0, getCallStackAt_1.getCallStackAt)(3, {
        tryGetNameAsync: valueNameIsPresent,
        onNameInferred: valueNameIsPresent ? void 0 : function (inferred) { return value_name = inferred; }
    });
    var __src__ = callStackSite === null || callStackSite === void 0 ? void 0 : callStackSite.__line__;
    value_name = value_name !== null && value_name !== void 0 ? value_name : callStackSite === null || callStackSite === void 0 ? void 0 : callStackSite.inferredName;
    var letted = new Term_1.Term(type, function (dbn) {
        var ir = varValue.toIR(dbn);
        // `compileIRToUPLC` can handle it even if this check is not present
        // but why spend useful tree iterations if we can avoid them here?
        if (ir instanceof IRLetted_1.IRLetted ||
            ir instanceof IRHoisted_1.IRHoisted ||
            ir instanceof IRVar_1.IRVar) {
            return ir;
        }
        if ((0, isClosedIRTerm_1.isClosedIRTerm)(ir)) {
            return new IRHoisted_1.IRHoisted(ir);
        }
        var res = new IRLetted_1.IRLetted(Number(dbn), ir, { __src__: __src__, name: value_name });
        return res;
    });
    var continuation = function (expr) {
        // only to extracts the type; never compiled
        var outType = expr((0, makeMockUtilityTerm_1.makeMockUtilityTerm)(varValue.type)).type;
        // return papp( plam( varValue.type, outType )( expr as any ), varValue as any ) as any;
        var term = new Term_1.Term(outType, function (dbn) {
            var withUtility = (0, addUtilityForType_1.addUtilityForType)(varValue.type);
            var arg = varValue.toIR(dbn);
            if (
            // inline variables; no need to add an application since already in scope
            arg instanceof IRVar_1.IRVar) {
                return expr(withUtility(varValue)).toIR(dbn);
            }
            // if(
            //     // inline letted terms; no need to add an application since already letted
            //     arg instanceof IRLetted
            // )
            // {
            //     return expr( withUtility( varValue as any ) as any ).toIR( dbn );
            // }
            return new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, expr(withUtility(new Term_1.Term(varValue.type, function (varAccessDbn) { return new IRVar_1.IRVar(varAccessDbn - (dbn + BigInt(1))); } // point to the lambda generated here
            ))).toIR((dbn + BigInt(1)))), arg, { __src__: __src__ });
        });
        return term;
    };
    var lettedUtility = (0, addUtilityForType_1.addUtilityForType)(type)(letted);
    Object.defineProperty(lettedUtility, "in", {
        value: continuation,
        writable: false,
        enumerable: false,
        configurable: false
    });
    return lettedUtility;
}
exports.plet = plet;
