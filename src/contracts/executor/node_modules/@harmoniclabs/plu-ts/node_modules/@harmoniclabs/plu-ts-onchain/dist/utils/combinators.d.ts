import { Head, Tail } from "./types.js";
export type CurriedFn<Args extends any[], Output> = Args extends [] ? () => Output : Args extends [infer Arg] ? (arg: Arg) => Output : Args extends [infer Arg1, infer Arg2, ...infer RestArgs] ? (arg: Arg1) => CurriedFn<[Arg2, ...RestArgs], Output> : Args extends [...infer Tys] ? (...args: Tys) => Output : never;
/**
 * parametrized functions will have TypeParameters automatically substituted with ```any```
 *
 * > example:
 * > ```ts
 * > function ifThenElse<T>( cond: boolean, a: T, b: T ): T
 * > {
 * >      return cond ? a : b;
 * > }
 * >
 * > const cuffiedIf = curry( ifThenElse );
 * > // type:
 * > // ( arg: boolean ) => ( arg: any ) => ( arg: any ) => any
 * > ```
 *
 * a workaround is to define a wrapper function ( ofthe translating to identity at runtime )
 * with the fixed types:
 * > ```ts
 * > const ifNum = ( cond: boolean, a: number, b: number ) => ifThenElse( cond, a, b );
 * >
 * > const cuffiedIfNum = curry( ifNum );
 * > // type:
 * > // ( arg: boolean ) => ( arg: number ) => ( arg: number ) => number
 * > ```
 *
 * but at this point it would be probably faster and easier to directly vrite the curried version:
 * > ```ts
 * > const curriedIfNumFaster = ( cond: boolean ) => ( a: number ) => ( b: number ) => ifThenElse( cond, a, b );
 * > // type:
 * > // ( arg: boolean ) => ( arg: number ) => ( arg: number ) => number
 * > ```
 *
*/
export declare function curry<Args extends any[], Output>(fn: (...args: Args) => Output): CurriedFn<Args, Output>;
export declare function curryFirst<Args extends [any, ...any[]], Output>(fn: (arg1: Head<Args>, ...args: Tail<Args>) => Output): (arg1: Head<Args>) => (...args: Tail<Args>) => Output;
