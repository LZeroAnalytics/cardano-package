"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Address = exports.isAddressStr = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var crypto_1 = require("@harmoniclabs/crypto");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var credentials_1 = require("../credentials/index.js");
var hashes_1 = require("../hashes/index.js");
var ints_1 = require("../utils/ints.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../utils/assert.js");
var maybeData_1 = require("../utils/maybeData.js");
var UPLCFlatUtils_1 = __importDefault(require("../utils/UPLCFlatUtils/index.js"));
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
function isAddressStr(stuff) {
    if (typeof stuff !== "string")
        return false;
    try {
        Address.fromString(stuff);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isAddressStr = isAddressStr;
/**
 * shelley specification in cardano-ledger; page 113
 */
var Address = /** @class */ (function () {
    function Address(network, paymentCreds, stakeCreds, type) {
        type = type === undefined ?
            (stakeCreds === undefined ? "enterprise" : "base")
            : type;
        (0, assert_1.assert)(type === "base" ||
            type === "enterprise" ||
            type === "bootstrap" ||
            type === "pointer", "invalid address type");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "type", type);
        (0, assert_1.assert)(network === "mainnet" || network === "testnet", "invalid network");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "network", network);
        (0, assert_1.assert)(paymentCreds instanceof credentials_1.PaymentCredentials, "invalid payment credentials");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "paymentCreds", paymentCreds.clone());
        (0, assert_1.assert)(stakeCreds === undefined || stakeCreds instanceof credentials_1.StakeCredentials, "invalid stake credentials");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "stakeCreds", stakeCreds === null || stakeCreds === void 0 ? void 0 : stakeCreds.clone());
    }
    Address.mainnet = function (paymentCreds, stakeCreds, type) {
        return new Address("mainnet", paymentCreds, stakeCreds, type);
    };
    Address.testnet = function (paymentCreds, stakeCreds, type) {
        return new Address("testnet", paymentCreds, stakeCreds, type);
    };
    Address.prototype.clone = function () {
        return new Address(this.network, this.paymentCreds, // cloned in constructor
        this.stakeCreds, // cloned in constructor
        this.type);
    };
    Object.defineProperty(Address, "fake", {
        get: function () {
            return new Address("mainnet", credentials_1.PaymentCredentials.fake);
        },
        enumerable: false,
        configurable: true
    });
    Address.prototype.toData = function () {
        return new plutus_data_1.DataConstr(0, // export has only 1 constructor,
        [
            this.paymentCreds.toData(),
            this.stakeCreds === undefined ?
                (0, maybeData_1.nothingData)() :
                (0, maybeData_1.justData)(this.stakeCreds.toData())
        ]);
    };
    Address.prototype.toBytes = function () {
        var _a, _b, _c;
        return [(
            // header byte
            // second nubble = network
            (this.network === "mainnet" ? 1 : 0) |
                // first nibble infos  
                (this.type === "base" ? 0 :
                    this.type === "pointer" ? 64 :
                        this.type === "enterprise" ? 96 :
                            8 // bootstrap
                ) |
                (((_a = this.stakeCreds) === null || _a === void 0 ? void 0 : _a.type) === "script" ? 32 : 0) |
                (this.paymentCreds.type === "script" ? 16 : 0))]
            .concat(Array.from(this.paymentCreds.hash.asBytes))
            .concat(this.stakeCreds === (void 0) ? [] : // add nothing
            Array.isArray(this.stakeCreds.hash) ? // pointer 
                this.stakeCreds.hash
                    .reduce(function (acc, n) {
                    return acc.concat(Array.from(UPLCFlatUtils_1.default.encodeBigIntAsVariableLengthBitStream((0, ints_1.forceBigUInt)(n)).toBuffer().buffer));
                }, []) :
                // hash (script or key)
                Array.from((_c = (_b = this.stakeCreds) === null || _b === void 0 ? void 0 : _b.hash.asBytes) !== null && _c !== void 0 ? _c : []));
    };
    Address.fromBytes = function (bs) {
        bs = typeof bs === "string" ? Array.from((0, uint8array_utils_1.fromHex)(bs)) : bs;
        var _a = __read(bs), header = _a[0], payload = _a.slice(1);
        var addrType = (header & 240) >> 4;
        var network = ((header & 15)) === 1 ? "mainnet" : "testnet";
        var type = addrType <= 3 ? "base" :
            addrType <= 5 ? "pointer" :
                addrType <= 7 ? "enterprise" :
                    addrType === 8 ? "bootstrap" :
                        // addrType === 0b1110 || addrType === 0b1111 ? "stake" :
                        "unknown";
        var payment;
        var stake;
        var paymentType = (addrType & 1) === 1 ? "script" : "pubKey";
        var stakeType = (addrType & 2) === 1 ? "script" : "stakeKey";
        switch (type) {
            case "base":
                if (payload.length !== (28 * 2))
                    throw new Error("address' header specifies a base adress but the payload is incorrect");
                payment = payload.slice(0, 28),
                    stake = payload.slice(28);
                break;
            case "bootstrap":
            case "enterprise":
            case "pointer":
                if (payload.length < 28) {
                    console.log((0, uint8array_utils_1.toHex)(new Uint8Array(payload)));
                    throw new Error("address' payload is incorrect; payload.length: " + payload.length.toString());
                }
                payment = payload.slice(0, 28),
                    stake = []; // ignore pointer; might change in future version
                break;
            default:
                throw new Error("unknown addres type; can't extract payload");
        }
        if (payment.length !== 28) {
            throw new Error("missing payment credentials");
        }
        return new Address(network, new credentials_1.PaymentCredentials(paymentType, new hashes_1.Hash28(new Uint8Array(payment))), stake.length === 28 ?
            new credentials_1.StakeCredentials(stakeType, new hashes_1.Hash28(new Uint8Array(stake))) :
            undefined, type);
    };
    ;
    Address.prototype.toBuffer = function () {
        return new Uint8Array(this.toBytes());
    };
    Address.fromBuffer = function (buff) {
        return Address.fromBytes(typeof buff === "string" ?
            buff :
            Array.from(buff));
    };
    Address.prototype.toCborObj = function () {
        return new cbor_1.CborBytes(this.toBuffer());
    };
    Address.fromCborObj = function (buff) {
        if (!(buff instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR format for \"Address\"");
        return Address.fromBuffer(buff.buffer);
    };
    Address.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    Address.fromCbor = function (cbor) {
        return Address.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cbor)));
    };
    Address.prototype.toString = function () {
        return (0, crypto_1.encodeBech32)(this.network === "mainnet" ? "addr" : "addr_test", this.toBytes());
    };
    Address.fromString = function (addr) {
        var _a = __read((0, crypto_1.decodeBech32)(addr), 2), hrp = _a[0], bytes = _a[1];
        var hrpNetwork;
        switch (hrp) {
            case "addr_test":
                hrpNetwork = "testnet";
                break;
            case "addr":
                hrpNetwork = "mainnet";
                break;
            default:
                throw new Error("string passed is not a Cardano address");
        }
        var _addr = Address.fromBytes(bytes);
        if (hrpNetwork !== _addr.network)
            throw new Error("ill formed address; human readable part netwok missmatches header byte network");
        return _addr;
    };
    Address.prototype.toJson = function () {
        return this.toString();
    };
    return Address;
}());
exports.Address = Address;
