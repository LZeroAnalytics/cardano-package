import { GenesisInfos, NormalizedGenesisInfos } from "./GenesisInfos.js";
import { CostModelsToLanguageViewCborOpts } from "@harmoniclabs/cardano-costmodels-ts";
import { Tx, Value, ValueUnits, TxOut, TxRedeemerTag, ScriptType, UTxO, TxRedeemer, TxWitnessSet, ScriptDataHash, ITxOut } from "@harmoniclabs/cardano-ledger-ts";
import { CborString, CanBeCborString } from "@harmoniclabs/cbor";
import { Data } from "@harmoniclabs/plutus-data";
import { ITxBuildArgs, ITxBuildOptions, ITxBuildInput, ITxBuildSyncOptions } from "../txBuild/index.js";
import { CanBeUInteger } from "../utils/ints.js";
import { TxBuilderRunner } from "./TxBuilderRunner/TxBuilderRunner.js";
import { ITxRunnerProvider } from "./IProvider/index.js";
import { TxBuilderProtocolParams, ValidatedTxBuilderProtocolParams } from "./TxBuilderProtocolParams.js";
import { ChangeInfos } from "../txBuild/ChangeInfos/ChangeInfos.js";
export declare class TxBuilder {
    readonly protocolParamters: ValidatedTxBuilderProtocolParams;
    readonly genesisInfos?: NormalizedGenesisInfos;
    setGenesisInfos: (geneisInfos: GenesisInfos) => void;
    runWithProvider(provider: Partial<ITxRunnerProvider>): TxBuilderRunner;
    constructor(protocolParamters?: Readonly<TxBuilderProtocolParams>, genesisInfos?: GenesisInfos);
    keepRelevant(requestedOutputSet: Value | ValueUnits, initialUTxOSet: ITxBuildInput[], minimumLovelaceRequired?: CanBeUInteger): ITxBuildInput[];
    calcLinearFee(tx: Tx | CborString): bigint;
    calcMinFee(tx: Tx): bigint;
    getMinimumOutputLovelaces(tx_out: TxOut | CanBeCborString): bigint;
    minimizeLovelaces(out: ITxOut): TxOut;
    /**
     *
     * @param slotN number of the slot
     * @returns POSIX time in **milliseconds**
     */
    slotToPOSIX(slot: CanBeUInteger, genesisInfos?: GenesisInfos): number;
    /**
     *
     * @param POSIX POSIX time in milliseconds
     */
    posixToSlot(POSIX: CanBeUInteger, genesisInfos?: GenesisInfos): number;
    /**
     * here mainly for forward compability
     *
     * internally calls `buildSync` so really what `build` is doing is wrapping it in a `Promise`
     *
     * In future this method might implement multi-threading using `Worker`s
     */
    build(buildArgs: ITxBuildArgs, buildOpts?: ITxBuildOptions): Promise<Tx>;
    /**
     * replaces the redeemers and clears vkeyWitnesses in the witness set
     * and re-computes the `scriptDataHash` in the body
     *
     * the input transaction is readonly and is not modified
     *
     * **A NEW TRANSACTION IS CREATED** with vkey witness set empty
     * (the new transaction is unsigned)
     *
     * to summarize, the new transaction differs in:
     * 1) `tx.body.scriptDataHash`
     * 2) `tx.witnesses.redeemers`
     * 3) `tx.witnesses.vkeyWitnesses` (empty)
     */
    overrideTxRedeemers(tx: Tx, newRedeemers: TxRedeemer[], opts?: CostModelsToLanguageViewCborOpts): Tx;
    buildSync(buildArgs: ITxBuildArgs, { onScriptInvalid, onScriptResult }?: ITxBuildSyncOptions): Tx;
    assertMinOutLovelaces(txOuts: TxOut[]): void;
    /**
     * extracts the important data from the input
     * and returns it in an easier way to opearte with
     *
     * if the transaction is simple enough (aka. it doesn't include plutus scripts)
     * this is all that either `build` or `buildSync` needs to do
    **/
    protected initTxBuild(buildArgs: ITxBuildArgs): {
        tx: Tx;
        scriptsToExec: ScriptToExecEntry[];
        minFee: bigint;
        datumsScriptData: number[];
        languageViews: Uint8Array;
        totInputValue: Value;
        requiredOutputValue: Value;
        outs: TxOut[];
        change: ChangeInfos;
    };
    assertCorrectChangeOutput(changeOutput: TxOut): void;
    findCollaterals(utxos: UTxO[], targetCollateralLovelaces?: number | bigint): UTxO[];
}
type ScriptToExecEntry = {
    rdmrTag: TxRedeemerTag;
    index: number;
    script: {
        type: ScriptType;
        bytes: Uint8Array;
        hash: string;
    };
    datum?: Data;
};
export declare function getScriptDataHash(witnesses: TxWitnessSet, languageViews: Uint8Array): ScriptDataHash | undefined;
/**
 * Claude prompt (yes I'm lazy):
 *
 * write a typescript function that given a string and a number,
 * returns an array of strings whose length IN BYTES is at most the second parameter,
 * if a utf 8 char is present at the intersection
 * of the two chunks IT MUST STAY INTACT and it will be part of the following chunk.
 *
 * @example
 * const exampleString = "Hello, üåç! This is a test.";
 * const maxChunkBytes = 10;
 * const result = splitStringByByteLength(exampleString, maxChunkBytes);
 * console.log(result); // ["Hello, ", "üåç! This", " is a test", "."]
 */
export declare function splitStringByByteLength(input: string, maxByteLength?: number): string[];
export {};
