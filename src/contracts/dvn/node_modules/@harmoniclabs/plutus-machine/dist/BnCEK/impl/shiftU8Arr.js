"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shiftU8Arr = void 0;
function shiftU8Arr(bytes, k) {
    // Create a copy of the input array to avoid modifying the original
    var result = Uint8Array.prototype.slice.call(bytes);
    k = Math.round(k);
    // No shift needed
    if (k === 0)
        return result;
    // Calculate absolute shift value and direction
    var absShift = Math.abs(k);
    var isLeftShift = k > 0;
    // If shift amount exceeds array length in bits, return all zeros
    if (absShift >= result.length * 8)
        return new Uint8Array(result.length); // result.fill( 0 );
    // Calculate full byte shifts and remaining bits
    var byteShifts = Math.floor(absShift / 8);
    var bitShifts = absShift % 8;
    if (isLeftShift) {
        // Left shift
        // First handle byte-wise shifts
        for (var i = 0; i < result.length - byteShifts; i++) {
            result[i] = result[i + byteShifts];
        }
        // Then handle remaining bits
        if (bitShifts > 0) {
            for (var i = 0; i < result.length - byteShifts - 1; i++) {
                result[i] = ((result[i] << bitShifts) & 0xFF) |
                    (result[i + 1] >> (8 - bitShifts));
            }
            // Handle the last byte that needs shifting
            if (result.length - byteShifts > 0) {
                result[result.length - byteShifts - 1] =
                    (result[result.length - byteShifts - 1] << bitShifts) & 0xFF;
            }
        }
        // Zero out the trailing bytes
        for (var i = result.length - byteShifts; i < result.length; i++) {
            result[i] = 0;
        }
    }
    else {
        // Right shift
        // First handle byte-wise shifts
        for (var i = result.length - 1; i >= byteShifts; i--) {
            result[i] = result[i - byteShifts];
        }
        // Then handle remaining bits
        if (bitShifts > 0) {
            for (var i = result.length - 1; i > byteShifts; i--) {
                result[i] = (result[i] >> bitShifts) |
                    ((result[i - 1] & ((1 << bitShifts) - 1)) << (8 - bitShifts));
            }
            // Handle the first byte that needs shifting
            if (byteShifts < result.length) {
                result[byteShifts] = result[byteShifts] >> bitShifts;
            }
        }
        // Zero out the leading bytes
        for (var i = 0; i < byteShifts; i++) {
            result[i] = 0;
        }
    }
    return result;
}
exports.shiftU8Arr = shiftU8Arr;
