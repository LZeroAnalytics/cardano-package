"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Machine = exports.machineVersionV2 = exports.machineVersionV1 = void 0;
var uplc_1 = require("@harmoniclabs/uplc");
var BnCEK_1 = require("../BnCEK/BnCEK.js");
var PartialBuiltin_1 = require("../BnCEK/PartialBuiltin.js");
var CEKEnv_1 = require("../CEKEnv.js");
var CEKFrames_1 = require("../CEKFrames/CEKFrames.js");
var ForceFrame_1 = require("../CEKFrames/ForceFrame.js");
var LApp_1 = require("../CEKFrames/LApp.js");
var RApp_1 = require("../CEKFrames/RApp.js");
var CEKHeap_1 = require("../CEKHeap/index.js");
var CEKSteps_1 = require("../CEKSteps/index.js");
var DelayCEK_1 = require("../DelayCEK/index.js");
var LambdaCEK_1 = require("../LambdaCEK/index.js");
var ScriptType_1 = require("../utils/ScriptType.js");
var BuiltinCosts_1 = require("./BuiltinCosts/BuiltinCosts.js");
var ExBudget_1 = require("./ExBudget.js");
var MachineCosts_1 = require("./MachineCosts.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var cardano_costmodels_ts_1 = require("@harmoniclabs/cardano-costmodels-ts");
exports.machineVersionV1 = ScriptType_1.ScriptType.PlutusV1;
exports.machineVersionV2 = ScriptType_1.ScriptType.PlutusV2;
function isMachineVersion(something) {
    return something === ScriptType_1.ScriptType.PlutusV1 || something === ScriptType_1.ScriptType.PlutusV2;
}
var Machine = /** @class */ (function () {
    function Machine(version, costmodel) {
        if (!isMachineVersion(version))
            throw new Error("invalid MachineVersion");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "version", version);
        var isV1 = (0, cardano_costmodels_ts_1.isCostModelsV1)(costmodel);
        if (!isV1 && !(0, cardano_costmodels_ts_1.isCostModelsV2)(costmodel))
            throw new Error("invalid machine costs");
        var costs = isV1 ? (0, cardano_costmodels_ts_1.costModelV1ToFakeV2)(costmodel) : (0, cardano_costmodels_ts_1.toCostModelV2)(costmodel);
        (0, obj_utils_1.defineReadOnlyHiddenProperty)(this, "getBuiltinCostFuction", (0, BuiltinCosts_1.costModelV2ToBuiltinCosts)(costs));
        (0, obj_utils_1.defineReadOnlyHiddenProperty)(this, "machineCosts", (0, MachineCosts_1.costModelV2ToMachineCosts)(costs));
    }
    Machine.evalSimple = function (_term, srcmap) {
        if (srcmap === void 0) { srcmap = undefined; }
        return (new Machine(ScriptType_1.ScriptType.PlutusV2, cardano_costmodels_ts_1.defaultV2Costs)).eval(_term, srcmap).result;
    };
    Machine.eval = function (_term, srcmap) {
        if (srcmap === void 0) { srcmap = undefined; }
        return (new Machine(ScriptType_1.ScriptType.PlutusV2, cardano_costmodels_ts_1.defaultV2Costs)).eval(_term, srcmap);
    };
    Machine.prototype.eval = function (_term, srcmap) {
        var _a, _b;
        if (srcmap === void 0) { srcmap = undefined; }
        var has_src = typeof srcmap === "object" && srcmap !== null;
        // new budget for each call
        var budget = new ExBudget_1.ExBudget({ mem: 0, cpu: 0 });
        var spend = budget.add;
        var logs = [];
        var machineCosts = this.machineCosts;
        var getBuiltinCostFuction = this.getBuiltinCostFuction;
        function spendBuiltin(bn) {
            var nForces = BigInt((0, uplc_1.getNRequiredForces)(bn.tag));
            if (nForces === BigInt(0)) {
                budget.add(machineCosts.builtinNode);
                return;
            }
            budget.add({
                mem: machineCosts.builtinNode.mem + (machineCosts.force.mem * nForces),
                cpu: machineCosts.builtinNode.cpu + (machineCosts.force.cpu * nForces)
            });
        }
        var bnCEK = new BnCEK_1.BnCEK(getBuiltinCostFuction, budget, logs);
        var frames = new CEKFrames_1.CEKFrames();
        var steps = new CEKSteps_1.CEKSteps();
        var heap = new CEKHeap_1.CEKHeap();
        var _poppedFrame = undefined;
        function popTopFrame() {
            return _poppedFrame = frames.pop();
        }
        function defineCallStack(thing) {
            if (!Array.isArray(thing.__call_stack__)) {
                var hasPoppedFrame = (0, CEKFrames_1.isFrame)(_poppedFrame);
                // re insert top frame for call stack to include it.
                if (hasPoppedFrame)
                    frames.push(_poppedFrame);
                Object.defineProperty(thing, "__call_stack__", {
                    value: Object.freeze(frames.callStack()),
                    enumerable: true,
                    writable: false,
                    configurable: false
                });
                // re-remove the top frame
                if (hasPoppedFrame)
                    frames.pop();
            }
        }
        var uplc = (0, uplc_1.isUPLCTerm)(_term) ? _term : _term.toUPLC(0);
        if (has_src) {
            indexNodes(uplc);
        }
        spend(machineCosts.startup);
        compute(uplc, new CEKEnv_1.CEKEnv(heap));
        while (!frames.isEmpty || steps.topIsCompute) {
            var nextStep = steps.pop();
            if (nextStep === undefined) {
                throw new Error("step stack was empty; don't know how to proceed");
            }
            if (nextStep instanceof CEKSteps_1.ComputeStep) {
                compute(nextStep.term, nextStep.env);
            }
            else if (nextStep instanceof CEKSteps_1.ReturnStep) {
                returnCEK(nextStep.value);
            }
            else
                throw new Error("unknown step");
        }
        function compute(term, env) {
            // n_compute++;
            if (term instanceof uplc_1.ErrorUPLC) {
                defineCallStack(term);
                steps.push(new CEKSteps_1.ReturnStep(term));
                return;
            }
            if (term instanceof uplc_1.UPLCVar) {
                var varValue = env.get(term.deBruijn);
                if (varValue === undefined)
                    throw new Error();
                budget.add(machineCosts.var);
                steps.push(new CEKSteps_1.ReturnStep(varValue));
                return;
            }
            if (term instanceof uplc_1.UPLCConst) {
                budget.add(machineCosts.constant);
                steps.push(new CEKSteps_1.ReturnStep(term));
                return;
            }
            if (term instanceof uplc_1.Lambda) {
                budget.add(machineCosts.lam);
                steps.push(new CEKSteps_1.ReturnStep(new LambdaCEK_1.LambdaCEK(term.body, env.clone())));
                return;
            }
            if (term instanceof uplc_1.Delay) {
                budget.add(machineCosts.delay);
                steps.push(new CEKSteps_1.ReturnStep(new DelayCEK_1.DelayCEK(term.delayedTerm, env)));
                return;
            }
            if (term instanceof uplc_1.Force) {
                budget.add(machineCosts.force);
                frames.push(new ForceFrame_1.ForceFrame());
                steps.push(new CEKSteps_1.ComputeStep(term.termToForce, env));
                return;
            }
            if (term instanceof uplc_1.Application) {
                budget.add(machineCosts.apply);
                var rapp = new RApp_1.RApp(term.argTerm, env);
                if (has_src && typeof (term.__node_index__) === "number") {
                    rapp.src = srcmap[term.__node_index__];
                }
                frames.push(rapp);
                steps.push(new CEKSteps_1.ComputeStep(term.funcTerm, env));
                return;
            }
            if (term instanceof uplc_1.Builtin ||
                term instanceof PartialBuiltin_1.PartialBuiltin) {
                if (term instanceof uplc_1.Builtin) {
                    spendBuiltin(term);
                }
                steps.push(new CEKSteps_1.ReturnStep(term instanceof PartialBuiltin_1.PartialBuiltin ? term : new PartialBuiltin_1.PartialBuiltin(term.tag)));
                return;
            }
            var err = new uplc_1.ErrorUPLC("ComputeStep/no match", { term: term });
            defineCallStack(err);
            steps.push(new CEKSteps_1.ReturnStep(err));
            return;
        }
        function returnCEK(v) {
            // n_returns++;
            if (v instanceof uplc_1.ErrorUPLC && (!Array.isArray(v.__call_stack__) ||
                v.__call_stack__.length === 0)) {
                defineCallStack(v);
            }
            if (v instanceof PartialBuiltin_1.PartialBuiltin) {
                if (v.nMissingArgs === 0) {
                    var evalResult = bnCEK.eval(v);
                    if (evalResult instanceof uplc_1.ErrorUPLC) {
                        defineCallStack(evalResult);
                    }
                    steps.push(new CEKSteps_1.ReturnStep(evalResult));
                    return;
                }
                if (frames.isEmpty) {
                    var err_1 = new uplc_1.ErrorUPLC("ReturnStep/PartialBuiltin/empty frames");
                    defineCallStack(err_1);
                    steps.push(new CEKSteps_1.ReturnStep(err_1));
                    return;
                }
            }
            if (frames.isEmpty) {
                // ends while loop
                steps.push(new CEKSteps_1.ReturnStep(v));
                return;
            }
            var topFrame = popTopFrame();
            if (v instanceof uplc_1.ErrorUPLC) {
                defineCallStack(v);
                steps.push(new CEKSteps_1.ReturnStep(v));
                return;
            }
            if (topFrame instanceof ForceFrame_1.ForceFrame) {
                if (v instanceof uplc_1.Delay ||
                    v instanceof DelayCEK_1.DelayCEK) {
                    steps.push(new CEKSteps_1.ComputeStep(v.delayedTerm, v instanceof DelayCEK_1.DelayCEK ? v.env : new CEKEnv_1.CEKEnv(heap)));
                    return;
                }
                // not sure about the env...
                steps.push(new CEKSteps_1.ComputeStep(v, new CEKEnv_1.CEKEnv(heap)));
                return;
            }
            // builtin forces are added only at compile time
            // ence not present in plu-ts UPLCTerm
            if (topFrame instanceof RApp_1.RApp) {
                frames.push(new LApp_1.LApp(v, topFrame.src));
                steps.push(new CEKSteps_1.ComputeStep(topFrame.arg, topFrame.env));
                return;
            }
            if (topFrame instanceof LApp_1.LApp) {
                if (topFrame.func instanceof uplc_1.Lambda ||
                    topFrame.func instanceof LambdaCEK_1.LambdaCEK) {
                    var _env = topFrame.func instanceof LambdaCEK_1.LambdaCEK ?
                        topFrame.func.env :
                        new CEKEnv_1.CEKEnv(heap);
                    _env.push(v);
                    steps.push(new CEKSteps_1.ComputeStep(topFrame.func.body, _env));
                    return;
                }
                if (topFrame.func instanceof uplc_1.Builtin ||
                    topFrame.func instanceof PartialBuiltin_1.PartialBuiltin) {
                    var bn = topFrame.func.clone();
                    if (bn instanceof uplc_1.Builtin) {
                        spendBuiltin(bn);
                        bn = new PartialBuiltin_1.PartialBuiltin(bn.tag);
                    }
                    if (bn.nMissingArgs === 0) {
                        var evalResult = bnCEK.eval(bn);
                        if (evalResult instanceof uplc_1.ErrorUPLC) {
                            defineCallStack(evalResult);
                        }
                        return returnCEK(evalResult);
                    }
                    bn.apply(v);
                    // choose what to do based on the frames
                    return returnCEK(bn);
                }
            }
            var err = new uplc_1.ErrorUPLC("ReturnStep/LApp", { topFrame: topFrame });
            defineCallStack(err);
            steps.push(new CEKSteps_1.ReturnStep(err));
            return;
        }
        // Debug.timeEnd(timeTag);
        return {
            result: (_b = (_a = steps.pop()) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : new uplc_1.ErrorUPLC("steps.pop() was not a ReturnStep"),
            budgetSpent: budget,
            logs: logs
        };
    };
    return Machine;
}());
exports.Machine = Machine;
// export interface EvalDebugOptions {
//     onComputeStep: () => void
//     onReturnStep: () => void
// }
function indexNodes(uplc, idx) {
    if (idx === void 0) { idx = 0; }
    Object.defineProperty(uplc, "__node_index__", {
        value: Number(idx),
        writable: false,
        enumerable: true,
        configurable: false
    });
    if (uplc instanceof uplc_1.Application) {
        var max_fn = indexNodes(uplc.funcTerm, idx + 1);
        return indexNodes(uplc.argTerm, max_fn + 1);
    }
    if (uplc instanceof uplc_1.Force)
        return indexNodes(uplc.termToForce, idx);
    if (uplc instanceof uplc_1.Delay)
        return indexNodes(uplc.delayedTerm, idx);
    if (uplc instanceof uplc_1.Lambda)
        return indexNodes(uplc.body, idx);
    // UPLCVar | UPLCConst | ErrorUPLC | Builtin
    // have no childs
    return idx;
}
