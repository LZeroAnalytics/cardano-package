"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockPPairMethods = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var type_system_1 = require("../../../../type_system/index.js");
var makeMockUtilityTerm_1 = require("./makeMockUtilityTerm.js");
var unwrapAsData_1 = require("../../../../type_system/tyArgs/unwrapAsData.js");
var makeMockTerm_1 = require("./makeMockTerm.js");
var mockPBoolMethods_1 = require("./mockPBoolMethods.js");
var getterOnly = {
    set: function () { },
    configurable: false,
    enumerable: true
};
function mockPPairMethods(_pair) {
    var pairT = (0, type_system_1.unwrapAlias)(_pair.type);
    if (!(0, type_system_1.typeExtends)(pairT, (0, type_system_1.pair)((0, type_system_1.tyVar)(), (0, type_system_1.tyVar)()))) {
        throw new Error("can't add pair methods to a term that is not a pair");
    }
    ;
    // MUST NOT unwrap `asData`
    // (needed by pfst and psnd to understand if the result should be transformed)
    var fstT = pairT[1];
    while (fstT[0] === "alias" /* PrimType.Alias */)
        fstT = fstT[1];
    // MUST NOT unwrap `asData`
    // (needed by pfst and psnd to understand if the result should be transformed) 
    var sndT = pairT[2];
    while (sndT[0] === "alias" /* PrimType.Alias */)
        sndT = sndT[1];
    if ((0, type_system_1.isWellFormedType)(fstT))
        (0, obj_utils_1.definePropertyIfNotPresent)(_pair, "fst", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)(
            // pfst automatically unwraps data
            fstT[0] === "asData" /* PrimType.AsData */ ?
                (0, unwrapAsData_1.unwrapAsData)(fstT) :
                fstT); } }, getterOnly));
    if ((0, type_system_1.isWellFormedType)(sndT))
        (0, obj_utils_1.definePropertyIfNotPresent)(_pair, "snd", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)(
            // psnd automatically unwraps data
            sndT[0] === "asData" /* PrimType.AsData */ ?
                (0, unwrapAsData_1.unwrapAsData)(sndT) :
                sndT); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(_pair, "peq", {
        get: function () { return (0, makeMockTerm_1.makeMockTerm)((0, type_system_1.lam)(pairT, type_system_1.bool)); },
        set: function () { },
        enumerable: true,
        configurable: false
    });
    (0, obj_utils_1.defineReadOnlyProperty)(_pair, "eq", function (other) { return (0, mockPBoolMethods_1.makeMockTermBool)(); });
    return _pair;
}
exports.mockPPairMethods = mockPPairMethods;
