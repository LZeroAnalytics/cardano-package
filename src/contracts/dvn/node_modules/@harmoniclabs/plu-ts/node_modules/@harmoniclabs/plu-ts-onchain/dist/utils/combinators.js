"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.curryFirst = exports.curry = void 0;
/**
 * parametrized functions will have TypeParameters automatically substituted with ```any```
 *
 * > example:
 * > ```ts
 * > function ifThenElse<T>( cond: boolean, a: T, b: T ): T
 * > {
 * >      return cond ? a : b;
 * > }
 * >
 * > const cuffiedIf = curry( ifThenElse );
 * > // type:
 * > // ( arg: boolean ) => ( arg: any ) => ( arg: any ) => any
 * > ```
 *
 * a workaround is to define a wrapper function ( ofthe translating to identity at runtime )
 * with the fixed types:
 * > ```ts
 * > const ifNum = ( cond: boolean, a: number, b: number ) => ifThenElse( cond, a, b );
 * >
 * > const cuffiedIfNum = curry( ifNum );
 * > // type:
 * > // ( arg: boolean ) => ( arg: number ) => ( arg: number ) => number
 * > ```
 *
 * but at this point it would be probably faster and easier to directly vrite the curried version:
 * > ```ts
 * > const curriedIfNumFaster = ( cond: boolean ) => ( a: number ) => ( b: number ) => ifThenElse( cond, a, b );
 * > // type:
 * > // ( arg: boolean ) => ( arg: number ) => ( arg: number ) => number
 * > ```
 *
*/
function curry(fn) {
    if (fn.length === 0)
        return (function () {
            var restArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                restArgs[_i] = arguments[_i];
            }
            return fn.apply(void 0, __spreadArray([], __read(restArgs), false));
        });
    function curryMem(uncurried, argsMem, lastCallRest) {
        if (argsMem.length === uncurried.length) {
            return uncurried.apply(void 0, __spreadArray(__spreadArray([], __read(argsMem), false), __read(lastCallRest), false));
        }
        return function (arg) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            return curryMem(uncurried, __spreadArray(__spreadArray([], __read(argsMem), false), [arg], false), rest);
        };
    }
    return curryMem(fn, [], []);
}
exports.curry = curry;
function curryFirst(fn) {
    if (fn.length === 0)
        return (function () { return fn(); });
    if (fn.length === 1)
        return (function (arg) { return fn(arg); });
    /*
    !!!  IMPORTANT !!!

    return ( arg: Head<Args> ) => ( ...args: Tail<Args> ) => fn( arg, ...args )
    
    doesn't work because  ```( ...args: Tail<Args> ) => ...``` has ```length``` of  ```0```
    */
    if (fn.length === 2)
        return function (arg) {
            return (function (args_0) { return fn.apply(void 0, __spreadArray([arg], __read([args_0]), false)); });
        };
    if (fn.length === 3)
        return function (arg) {
            return (function (args_0, args_1) { return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1]), false)); });
        };
    if (fn.length === 4)
        return function (arg) {
            return (function (args_0, args_1, args_2) { return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2]), false)); });
        };
    if (fn.length === 5)
        return function (arg) {
            return (function (args_0, args_1, args_2, args_3) { return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2, args_3]), false)); });
        };
    if (fn.length === 6)
        return function (arg) {
            return (function (args_0, args_1, args_2, args_3, args_4) {
                return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2, args_3, args_4]), false));
            });
        };
    if (fn.length === 7)
        return function (arg) {
            return (function (args_0, args_1, args_2, args_3, args_4, args_5) {
                return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2, args_3, args_4, args_5]), false));
            });
        };
    if (fn.length === 8)
        return function (arg) {
            return (function (args_0, args_1, args_2, args_3, args_4, args_5, args_6) {
                return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2, args_3, args_4, args_5, args_6]), false));
            });
        };
    if (fn.length === 9)
        return function (arg) {
            return (function (args_0, args_1, args_2, args_3, args_4, args_5, args_6, args_7) {
                return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2, args_3, args_4, args_5, args_6, args_7]), false));
            });
        };
    if (fn.length === 10)
        return function (arg) {
            return (function (args_0, args_1, args_2, args_3, args_4, args_5, args_6, args_7, args_8) {
                return fn.apply(void 0, __spreadArray([arg], __read([args_0, args_1, args_2, args_3, args_4, args_5, args_6, args_7, args_8]), false));
            });
        };
    throw new Error("functions with more thatn 10 parameters not supported for conversion; try gruping paramters in structured types");
}
exports.curryFirst = curryFirst;
