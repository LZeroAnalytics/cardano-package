"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIRConstValue = exports.IRConst = void 0;
var bytestring_1 = require("@harmoniclabs/bytestring");
var crypto_1 = require("@harmoniclabs/crypto");
var pair_1 = require("@harmoniclabs/pair");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var uplc_1 = require("@harmoniclabs/uplc");
var cloneTermType_1 = require("../../pluts/type_system/cloneTermType.js");
var termTyToConstTy_1 = require("../../pluts/type_system/termTyToConstTy.js");
var BasePlutsError_1 = require("../../utils/BasePlutsError.js");
var UPLCFlatUtils_1 = __importDefault(require("../../utils/UPLCFlatUtils/index.js"));
var ints_1 = require("../../utils/ints.js");
var concatUint8Arr_1 = require("../utils/concatUint8Arr.js");
var positiveIntAsBytes_1 = require("../utils/positiveIntAsBytes.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var isWellFormedType_1 = require("../../pluts/type_system/kinds/isWellFormedType.js");
var typeExtends_1 = require("../../pluts/type_system/typeExtends.js");
var types_1 = require("../../pluts/type_system/types.js");
var utils_1 = require("../../pluts/type_system/utils.js");
var isIRParentTerm_1 = require("../utils/isIRParentTerm.js");
var _modifyChildFromTo_1 = require("../toUPLC/_internal/_modifyChildFromTo.js");
var IRConst = /** @class */ (function () {
    function IRConst(t, v) {
        var _this = this;
        if (!(0, isWellFormedType_1.isWellFormedType)(t) ||
            (0, typeExtends_1.typeExtends)(t, (0, types_1.lam)((0, types_1.tyVar)(), (0, types_1.tyVar)())) &&
                (0, typeExtends_1.typeExtends)(t, (0, types_1.delayed)((0, types_1.tyVar)()))) {
            throw new BasePlutsError_1.BasePlutsError("invalid type for IR constant");
        }
        Object.defineProperty(this, "meta", {
            value: {},
            writable: false,
            enumerable: true,
            configurable: false
        });
        (0, obj_utils_1.defineReadOnlyProperty)(this, "type", (0, cloneTermType_1.cloneTermType)(t));
        if (!(isIRConstValueAssignableToType(v, t))) {
            console.log(v);
            throw new BasePlutsError_1.BasePlutsError("invalid IR constant value for type " + (0, utils_1.termTypeToString)(t));
        }
        (0, obj_utils_1.defineReadOnlyProperty)(this, "value", v);
        var _parent = undefined;
        Object.defineProperty(this, "parent", {
            get: function () { return _parent; },
            set: function (newParent) {
                if (!( // assert
                // new parent value is different than current
                _parent !== newParent && (
                // and the new parent value is valid
                newParent === undefined ||
                    (0, isIRParentTerm_1.isIRParentTerm)(newParent))))
                    return;
                // keep reference
                var oldParent = _parent;
                // change parent
                _parent = newParent;
                // if has old parent
                if (oldParent !== undefined && (0, isIRParentTerm_1.isIRParentTerm)(oldParent)) {
                    // change reference to a clone for safety
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(oldParent, _this, _this.clone());
                }
            },
            enumerable: true,
            configurable: false
        });
        var hash = undefined;
        Object.defineProperty(this, "hash", {
            get: function () {
                if (!(hash instanceof Uint8Array)) {
                    hash = (0, crypto_1.blake2b_128)((0, concatUint8Arr_1.concatUint8Arr)(IRConst.tag, new Uint8Array((0, termTyToConstTy_1.termTyToConstTy)(_this.type)), serializeIRConstValue(_this.value, _this.type)));
                }
                return hash.slice();
            },
            set: function () { },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "markHashAsInvalid", {
            value: function () { throw new Error("IRConst `markHashAsInvalid` was called; but a constant doesn't have childs"); },
            writable: false,
            enumerable: true,
            configurable: false
        });
    }
    Object.defineProperty(IRConst, "tag", {
        get: function () { return new Uint8Array([3]); },
        enumerable: false,
        configurable: true
    });
    IRConst.prototype.clone = function () {
        return new IRConst(this.type, this.value);
    };
    IRConst.prototype.toJson = function () {
        return {
            type: "IRConst",
            constType: (0, utils_1.termTypeToString)(this.type),
            value: constValueToJson(this.value)
        };
    };
    Object.defineProperty(IRConst, "unit", {
        get: function () {
            return new IRConst(types_1.unit, undefined);
        },
        enumerable: false,
        configurable: true
    });
    IRConst.bool = function (b) {
        return new IRConst(types_1.bool, b);
    };
    IRConst.byteString = function (b) {
        return new IRConst(types_1.bs, b);
    };
    IRConst.int = function (n) {
        return new IRConst(types_1.int, n);
    };
    IRConst.str = function (string) {
        return new IRConst(types_1.str, string);
    };
    IRConst.data = function (d) {
        return new IRConst(types_1.data, d);
    };
    IRConst.listOf = function (t) {
        return function (vals) { return new IRConst((0, types_1.list)(t), vals); };
    };
    IRConst.pairOf = function (a, b) {
        return function (fst, snd) { return new IRConst((0, types_1.pair)(a, b), new pair_1.Pair(fst, snd)); };
    };
    return IRConst;
}());
exports.IRConst = IRConst;
function inferConstValueT(value) {
    if (typeof value === "undefined" || value === null)
        return types_1.unit;
    if ((0, uplc_1.isConstValueInt)(value) || (0, ints_1.canBeUInteger)(value))
        return types_1.int;
    if (value instanceof Uint8Array ||
        value instanceof bytestring_1.ByteString)
        return types_1.bs;
    if (typeof value === "string")
        return types_1.str;
    if (typeof value === "boolean")
        return types_1.bool;
    if (isIRConstValueList(value)) {
        if (value.length === 0)
            return (0, types_1.list)((0, types_1.tyVar)());
        return (0, types_1.list)(inferConstValueT(value[0]));
    }
    if (value instanceof pair_1.Pair) {
        return (0, types_1.pair)(inferConstValueT(value.fst), inferConstValueT(value.snd));
    }
    if ((0, plutus_data_1.isData)(value))
        return types_1.data;
    throw new BasePlutsError_1.BasePlutsError("invalid IRConstValue passed to inferConstValueT");
}
function isIRConstValueList(value) {
    if (!Array.isArray(value))
        return false;
    if (value.length === 0)
        return true;
    var elemsT = inferConstValueT(value[0]);
    return value.every(function (elem) { return isIRConstValueAssignableToType(elem, elemsT); });
}
function isIRConstValueAssignableToType(value, t) {
    if (t[0] === "alias" /* PrimType.Alias */)
        return isIRConstValueAssignableToType(value, t[1]);
    if (t[0] === "asData" /* PrimType.AsData */ ||
        t[0] === "struct" /* PrimType.Struct */ ||
        t[0] === "data" /* PrimType.Data */)
        return (0, plutus_data_1.isData)(value);
    if (t[0] === "list" /* PrimType.List */) {
        return (Array.isArray(value) &&
            value.every(function (v) { return isIRConstValueAssignableToType(v, t[1]); }));
    }
    if (t[0] === "pair" /* PrimType.Pair */) {
        return (value instanceof pair_1.Pair &&
            isIRConstValueAssignableToType(value.fst, t[1]) &&
            isIRConstValueAssignableToType(value.snd, t[2]));
    }
    return (0, typeExtends_1.typeExtends)(inferConstValueT(value), t);
}
function isIRConstValue(value) {
    return (typeof value === "undefined" ||
        (0, ints_1.canBeUInteger)(value) ||
        value instanceof Uint8Array ||
        value instanceof bytestring_1.ByteString ||
        typeof value === "string" ||
        typeof value === "boolean" ||
        isIRConstValueList(value) ||
        (value instanceof pair_1.Pair &&
            isIRConstValue(value.fst) &&
            isIRConstValue(value.snd)) ||
        (0, plutus_data_1.isData)(value));
}
exports.isIRConstValue = isIRConstValue;
function constValueToJson(value) {
    if ((0, ints_1.canBeUInteger)(value))
        return (0, ints_1.forceBigUInt)(value).toString();
    if (value instanceof Uint8Array)
        return (0, uint8array_utils_1.toHex)(value);
    if (value instanceof bytestring_1.ByteString)
        return value.toString();
    if (isIRConstValueList(value))
        return value.map(constValueToJson);
    if (value instanceof pair_1.Pair)
        return { fst: constValueToJson(value.fst), snd: constValueToJson(value.snd) };
    if ((0, plutus_data_1.isData)(value))
        return value.toJson();
    return value;
}
function serializeIRConstValue(value, t) {
    if (t[0] === "alias" /* PrimType.Alias */)
        return serializeIRConstValue(value, t[1]);
    if (value === undefined || t[0] === "unit" /* PrimType.Unit */)
        return new Uint8Array(0);
    if (t[0] === "int" /* PrimType.Int */) {
        return (0, positiveIntAsBytes_1.positiveBigIntAsBytes)(
        // forceBigUInt(
        UPLCFlatUtils_1.default.zigzagBigint(BigInt(value))
        // )
        );
    }
    if (t[0] === "bs" /* PrimType.BS */) {
        if (value instanceof Uint8Array)
            return value.slice();
        if (value instanceof bytestring_1.ByteString)
            return value.toBuffer();
    }
    if (t[0] === "str" /* PrimType.Str */)
        return (0, uint8array_utils_1.fromUtf8)(value);
    if (t[0] === "bool" /* PrimType.Bool */)
        return new Uint8Array([value ? 1 : 0]);
    if (t[0] === "list" /* PrimType.List */)
        return concatUint8Arr_1.concatUint8Arr.apply(void 0, __spreadArray([], __read(value.map(function (stuff) {
            return serializeIRConstValue(stuff, t[1]);
        })), false));
    if (t[0] === "pair" /* PrimType.Pair */) {
        return (0, concatUint8Arr_1.concatUint8Arr)(serializeIRConstValue(value.fst, t[1]), serializeIRConstValue(value.snd, t[2]));
    }
    if ((0, typeExtends_1.typeExtends)(t, types_1.data)) // include structs or `asData`
     {
        return (0, plutus_data_1.dataToCbor)(value).toBuffer();
    }
    console.log("unexpected value calling 'serializeIRConstValue'", value);
    console.log((0, utils_1.termTypeToString)(t));
    console.log(value);
    console.log(value instanceof bytestring_1.ByteString);
    console.log(value instanceof Uint8Array);
    throw "hello";
    throw new BasePlutsError_1.BasePlutsError("unexpected value calling 'serializeIRConstValue'");
}
