"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPListMethods = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var Term_1 = require("../../../Term/index.js");
var type_system_1 = require("../../../type_system/index.js");
var tyArgs_1 = require("../../../type_system/tyArgs/index.js");
var utils_1 = require("../../../type_system/utils.js");
var list_1 = require("../../builtins/list/index.js");
var pprepend_1 = require("../../builtins/pprepend/index.js");
var pappArg_1 = require("../../pappArg.js");
var phoist_1 = require("../../phoist.js");
var plet_1 = require("../../plet/index.js");
var PMaybe_1 = require("../PMaybe/PMaybe.js");
var combinators_1 = require("../combinators/index.js");
var pevery_1 = require("../list/pevery.js");
var pfilter_1 = require("../list/pfilter.js");
var pfind_1 = require("../list/pfind.js");
var pindexList_1 = require("../list/pindexList.js");
var plength_1 = require("../list/plength.js");
var pmap_1 = require("../list/pmap/index.js");
var preverse_1 = require("../list/preverse.js");
var psome_1 = require("../list/psome.js");
var list_2 = require("../list/index.js");
var flippedPrepend = function (t) { return (0, phoist_1.phoist)((0, combinators_1.pflip)((0, type_system_1.list)(t), t, (0, type_system_1.list)(t)).$((0, pprepend_1.pprepend)(t))); };
var flippedFind = function (t) { return (0, phoist_1.phoist)((0, combinators_1.pflip)((0, type_system_1.list)(t), (0, type_system_1.lam)(t, type_system_1.bool), (0, type_system_1.struct)({
    Just: { val: t },
    Nothing: {}
})).$((0, pfind_1.pfind)(t))); };
var flippedFilter = function (t) { return (0, phoist_1.phoist)((0, combinators_1.pflip)((0, type_system_1.list)(t), (0, type_system_1.lam)(t, type_system_1.bool), (0, type_system_1.list)(t)).$((0, pfilter_1.pfilter)(t))); };
var flippedEvery = function (t) { return (0, phoist_1.phoist)((0, combinators_1.pflip)((0, type_system_1.list)(t), (0, type_system_1.lam)(t, type_system_1.bool), type_system_1.bool).$((0, pevery_1.pevery)(t))); };
var flippedSome = function (t) { return (0, phoist_1.phoist)((0, combinators_1.pflip)((0, type_system_1.list)(t), (0, type_system_1.lam)(t, type_system_1.bool), type_system_1.bool).$((0, psome_1.psome)(t))); };
var getterOnly = {
    set: function () { },
    configurable: false,
    enumerable: true
};
function addPListMethods(_lst) {
    var elemsT = (0, tyArgs_1.getElemsT)(_lst.type);
    var lst = new Term_1.Term((0, type_system_1.list)(elemsT), 
    // needs to be wrapped to prevent the garbage collector to collect garbage (lst)
    function (dbn) { return _lst.toIR(dbn); }, _lst.isConstant);
    if (!(0, type_system_1.isWellFormedGenericType)(elemsT)) {
        throw new Error("`addPListMethods` can only be used on lists with concrete types; the type of the lst was: " + (0, utils_1.termTypeToString)(lst.type));
    }
    _definePListMethods(lst, elemsT);
    _definePListMethods(_lst, elemsT);
    return lst;
}
exports.addPListMethods = addPListMethods;
function _definePListMethods(lst, elemsT) {
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "head", __assign({ get: function () {
            return (0, plet_1.plet)((0, list_1.phead)(elemsT).$(lst), "list::head");
        } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "tail", __assign({ get: function () { return (0, plet_1.plet)((0, list_1.ptail)(elemsT).$(lst), "list::tail"); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "length", __assign({ get: function () { return (0, plet_1.plet)((0, plength_1.plength)(elemsT).$(lst), "list::length"); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "reversed", __assign({ get: function () { return (0, plet_1.plet)((0, preverse_1.preverse)(elemsT).$(lst), "list::reversed"); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "pat", __assign({ get: function () { return (0, pindexList_1.pindexList)(elemsT).$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "at", function (index) { return (0, pindexList_1.pindexList)(elemsT).$(lst).$(index); });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "pfind", __assign({ get: function () { return flippedFind(elemsT).$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "find", function (predicate) {
        return (0, pfind_1.pfind)(elemsT).$(predicate).$(lst);
    });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "pfilter", __assign({ get: function () { return flippedFilter(elemsT).$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "filter", function (predicate) {
        return (0, pfilter_1.pfilter)(elemsT).$(predicate).$(lst);
    });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "pprepend", __assign({ get: function () { return flippedPrepend(elemsT).$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "prepend", function (elem) { return (0, pprepend_1.pprepend)(elemsT).$(elem).$(lst); });
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "pmap", function (toType) {
        return (0, phoist_1.phoist)((0, combinators_1.pflip)((0, type_system_1.list)(elemsT), (0, type_system_1.lam)(elemsT, toType), (0, type_system_1.list)(toType)).$((0, pmap_1.pmap)(elemsT, toType)))
            .$(lst);
    });
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "map", function (f) {
        f = (0, pappArg_1.pappArgToTerm)(f, (0, type_system_1.lam)(elemsT, (0, type_system_1.tyVar)()));
        var predicateTy = f.type;
        if (!(predicateTy[0] === "lam" /* PrimType.Lambda */ &&
            (0, type_system_1.isWellFormedGenericType)(predicateTy[2])))
            throw new Error("can't map plu-ts fuction of type \"".concat(predicateTy, "\" over a lst of type \"lst(").concat((0, utils_1.termTypeToString)(elemsT), ")\""));
        return (0, pmap_1.pmap)(elemsT, predicateTy[2]).$(f).$(lst);
    });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "pevery", __assign({ get: function () { return flippedEvery(elemsT)
            .$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "every", function (predicate) { return (0, pevery_1.pevery)(elemsT).$(predicate).$(lst); });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "psome", __assign({ get: function () { return flippedSome(elemsT)
            .$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "some", function (predicate) { return (0, psome_1.psome)(elemsT).$(predicate).$(lst); });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "pincludes", __assign({ get: function () { return (0, list_2.pincludes)(elemsT).$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "includes", function (elem) { return (0, list_2.pincludes)(elemsT).$(lst).$(elem); });
    (0, obj_utils_1.definePropertyIfNotPresent)(lst, "peq", __assign({ get: function () { return (0, list_2.peqList)(elemsT).$(lst); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(lst, "eq", function (other) { return (0, list_2.peqList)(elemsT).$(lst).$(other); });
    if ((0, type_system_1.typeExtends)(elemsT, (0, type_system_1.pair)((0, type_system_1.tyVar)(), (0, type_system_1.tyVar)()))) {
        var kT_1 = (0, tyArgs_1.getFstT)(elemsT);
        var vT_1 = (0, tyArgs_1.getSndT)(elemsT);
        var PMaybeVal_1 = (0, PMaybe_1.PMaybe)(vT_1);
        (0, obj_utils_1.definePropertyIfNotPresent)(lst, "plookup", __assign({ get: function () { return (0, combinators_1.pflip)((0, type_system_1.list)(elemsT), kT_1, PMaybeVal_1.type).$((0, list_2.plookup)(kT_1, vT_1)).$(lst); } }, getterOnly));
        (0, obj_utils_1.defineReadOnlyProperty)(lst, "lookup", function (key) { return (0, list_2.plookup)(kT_1, vT_1).$(key).$(lst); });
    }
    return lst;
}
