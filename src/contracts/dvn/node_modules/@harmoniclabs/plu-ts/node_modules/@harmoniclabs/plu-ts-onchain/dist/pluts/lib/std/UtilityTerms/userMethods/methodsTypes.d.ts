import type { PType } from "../../../../PType/index.js";
import { PAlias, PStruct } from "../../../../PTypes/index.js";
import type { PLam } from "../../../../PTypes/PFn/PLam.js";
import type { Term } from "../../../../Term/index.js";
import type { Methods, StructDefinition } from "../../../../type_system/types.js";
import { PappArg } from "../../../pappArg.js";
import type { UtilityTermOf } from "../addUtilityForType.js";
export type LiftPMethod<PT extends PType, PrevPIns extends Term<PType>[] = []> = PT extends PLam<infer PIn extends PType, infer POut extends PType> ? (POut extends PLam<PType, PType> ? LiftPMethod<POut, [...PrevPIns, PappArg<PIn>]> : (...args: [...PrevPIns, PappArg<PIn>]) => UtilityTermOf<POut>) : UtilityTermOf<PT>;
export type LiftTermMethod<TFn extends Term<PLam<PType, PType>>> = TFn extends Term<PLam<PType, infer POut extends PType>> ? LiftPMethod<POut> : never;
export type LiftMethods<SMethods extends Methods> = {
    readonly [Method in keyof SMethods]: LiftTermMethod<SMethods[Method]>;
};
type TermToMethod<T extends Term<PLam<PType, PType>>> = T extends Term<PLam<PType, infer POut extends PType>> ? (POut extends PLam<any, any> ? UtilityTermOf<POut> : never) : never;
/**
 * @requires - typescript@^4.1
 */
export type MethodsAsTerms<SMethods extends Methods> = {
    readonly [Method in keyof SMethods as `p${Method & string}`]: TermToMethod<SMethods[Method]>;
};
/**
 * keeps only the methods that take the specified `InputFilter` as first input
 */
export type FilterMethodsByInput<Ms extends Methods, InputFilter extends PType> = {
    [M in keyof Ms]: Ms[M] extends Term<PLam<infer MethodIn, PType>> ? (InputFilter extends PAlias<infer PAliased extends PType, infer _> ? (MethodIn extends PAliased ? Ms[M] : MethodIn extends PAlias<PAliased, infer _> ? Ms[M] : never) : (InputFilter extends PStruct<infer SDef extends StructDefinition, infer _> ? (MethodIn extends PStruct<SDef, infer _> ? Ms[M] : never) : (MethodIn extends PAlias<infer PAliased extends PType, infer _> ? (InputFilter extends PAliased ? Ms[M] : InputFilter extends PAlias<PAliased, infer _> ? Ms[M] : never) : (MethodIn extends PStruct<infer SDef extends StructDefinition, infer _> ? (InputFilter extends PStruct<SDef, infer _> ? Ms[M] : never) : (MethodIn extends InputFilter ? Ms[M] : never))))) : never;
} & Methods;
/**
 * keeps only the methods that are a `PLam` AND take AT LEAST 2 INPUTS
 */
export type FilterOutSingleInputMethods<Ms extends Methods> = {
    [M in keyof Ms]: Ms[M] extends Term<PLam<PType, PLam<PType, PType>>> ? Ms[M] : never;
} & Methods;
export {};
