import type { TermFn } from "../PFn/index.js";
import { PAsData, PData } from "../PData/PData.js";
import { PDataRepresentable } from "../../PType/PDataRepresentable.js";
import { UtilityTermOf } from "../../lib/std/UtilityTerms/addUtilityForType.js";
import { GenericStructDefinition, Methods, PrimType, StructCtorDef, StructDefinition, StructT, TermType } from "../../type_system/types.js";
import { ToPType } from "../../type_system/ts-pluts-conversion.js";
import { Term } from "../../Term/index.js";
import { TermStruct } from "../../lib/std/UtilityTerms/TermStruct.js";
import { PType } from "../../PType/index.js";
/**
 * intermediate class useful to reconize structs form primitives
 */
declare class _PStruct extends PData {
    protected constructor();
}
export type StructInstance<SCtorDef extends StructCtorDef> = {
    readonly [Field in keyof SCtorDef]: UtilityTermOf<ToPType<SCtorDef[Field]>>;
};
export type StructInstanceAsData<SCtorDef extends StructCtorDef> = {
    [Field in keyof SCtorDef]: Term<PAsData<PType>> | Term<PStruct<StructDefinition, Methods>> | Term<PData>;
};
export type PStruct<SDef extends StructDefinition, SMethods extends Methods> = {
    new (): _PStruct;
    /**
     * @deprecated
     */
    readonly termType: StructT<SDef, SMethods>;
    readonly type: StructT<SDef, SMethods>;
    readonly fromDataTerm: TermFn<[PData], PStruct<SDef, SMethods>>;
    fromData: (data: Term<PData>) => Term<PStruct<SDef, SMethods>>;
    readonly toDataTerm: TermFn<[PStruct<SDef, {}>], PData>;
    toData: (data: Term<PStruct<SDef, {}>>) => Term<PData>;
    [prop: string]: any;
} & PDataRepresentable & {
    [Ctor in keyof SDef]: (ctorFields: StructInstanceAsData<SDef[Ctor]>) => TermStruct<SDef, SMethods>;
};
type Includes<As extends any[], Elem extends any> = As extends [] ? false : As extends [infer A extends any, ...infer RestAs extends any[]] ? (Elem extends A ? true : Includes<RestAs, Elem>) : false;
export type RestrictedStructInstance<SCtorDef extends StructCtorDef, Fields extends (keyof SCtorDef)[]> = {
    [Field in keyof SCtorDef]: Includes<Fields, Field> extends true ? UtilityTermOf<ToPType<SCtorDef[Field]>> : never;
};
export declare function structDefEq(a: StructDefinition, b: StructDefinition): boolean;
/**
 *
 * @param {StructDef} def data-type definition of the struct
 *
 *  each property of the object is a possible constructor for the struct;
 *
 *  each constructor is defined by specifiying the fields that constructor expects and relative types
 *
 * @example
 * ```ts
 * const Shape = pstruct({
 *      Circle: {
 *          radius: int
 *      },
 *      Rectangle: {
 *          fstSide: int,
 *          sndSide: int
 *      }
 * });
 * ```
 *
 * @param {( self_t: StructT<StructDef,{}> ) => Methods} getMethods (optional) function to implement arbitrary methods on a given struct.
 *
 * the function takes as first argument the type of this same struct and expects an object with various methods to be implemented on a struct instance
 *
 * @example
 * ```ts
 * const Shape = pstruct({
 *      Circle: {
 *          radius: int
 *      },
 *      Rectangle: {
 *          fstSide: int,
 *          sndSide: int
 *      }
 * }, ( self_t ) => {
 *
 *      return {
 *          largestSide: pfn([ self_t ], int )
 *              ( self =>
 *                  pmatch( self )
 *                  .onCircle(({ radius }) => radius )
 *                  .onRectangle({ fstSide, sndSide } =>
 *                      pif( int ).$( fstSide.gt( sndSide ) )
 *                      .then( fstSide )
 *                      .else( sndSide )
 *                  )
 *              )
 *      };
 * });
 *
 * const isLargeShape = pfn([ Shape.type ], int )
 * ( shape => shape.largestSide.gtEq( 100 ) )
 * ```
 */
export declare function pstruct<StructDef extends StructDefinition, SMethods extends Methods>(def: StructDef, getMethods?: (self_t: StructT<StructDef, {}>) => SMethods): PStruct<StructDef, SMethods>;
export declare function typeofGenericStruct(genStruct: (...tyArgs: TermType[]) => PStruct<StructDefinition, Methods>): StructT<GenericStructDefinition, Methods>;
/**
 * @param getDescriptor
 * @returns
 *
 * @deprecated
 *
 * use a function that reutrns a struct based on the specfied types instead
 */
export declare function pgenericStruct<ConstStructDef extends StructDefinition, TypeArgs extends [TermType, ...TermType[]]>(getDescriptor: (...tyArgs: TypeArgs) => PStruct<ConstStructDef, Methods>): ((<TyArgs extends TypeArgs>(...tyArgs: TyArgs) => PStruct<ConstStructDef, Methods>) & {
    type: [PrimType.Struct, GenericStructDefinition];
});
export {};
