import { ToUPLC, UPLCTerm } from "@harmoniclabs/uplc";
import { IRTerm } from "../../IR/IRTerm.js";
import { ToIR } from "../../IR/interfaces/ToIR.js";
import { PType } from "../PType/index.js";
import { FromPType, TermType, ToPType } from "../type_system/index.js";
import { Cloneable } from "../../utils/Cloneable.js";
export type UnTerm<T extends Term<PType>> = T extends Term<infer PT extends PType> ? PT : never;
export declare class Term<A extends PType> implements ToUPLC, ToIR, Cloneable<Term<A>> {
    /**
     * in most cases it will never be used
     *
     * it's solely purpose is to allow typescript to rise errors (at type level)
     * when the type arguments don't match
     */
    _pInstance?: A;
    get pInstance(): A | undefined;
    readonly type: FromPType<A> | TermType;
    readonly toUPLC: (deBruijnLevel?: bigint | number) => UPLCTerm;
    readonly toIR: (deBruijnLevel?: bigint | number) => IRTerm;
    readonly clone: () => Term<A>;
    constructor(type: FromPType<A> | FromPType<ToPType<TermType>>, _toIR: (dbn: bigint) => IRTerm, isConstant?: boolean);
}
export type ToTermArr<Ts extends TermType[]> = Ts extends [] ? [] & Term<PType>[] : Ts extends [infer T extends TermType] ? [Term<ToPType<T>>] & [Term<PType>] : Ts extends [infer T extends TermType, ...infer RestTs extends [TermType, ...TermType[]]] ? [Term<ToPType<T>>, ...ToTermArr<RestTs>] & [Term<PType>, ...Term<PType>[]] : never;
export type ToTermArrNonEmpty<Ts extends [TermType, ...TermType[]]> = Ts extends [] ? never & Term<PType>[] : Ts extends [infer T extends TermType] ? [Term<ToPType<T>>] & [Term<PType>] : Ts extends [infer T extends TermType, ...infer RestTs extends [TermType, ...TermType[]]] ? [Term<ToPType<T>>, ...ToTermArr<RestTs>] & [Term<PType>, ...Term<PType>[]] : never;
