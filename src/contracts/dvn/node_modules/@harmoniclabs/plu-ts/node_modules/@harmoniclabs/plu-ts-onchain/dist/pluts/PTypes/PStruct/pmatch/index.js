"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pmatch = exports.matchNCtorsIdxs = exports.getElemAtTerm = void 0;
var Term_1 = require("../../../Term/index.js");
var matchSingleCtorStruct_1 = require("../matchSingleCtorStruct.js");
var papp_1 = require("../../../lib/papp.js");
var addUtilityForType_1 = require("../../../lib/std/UtilityTerms/addUtilityForType.js");
var plam_1 = require("../../../lib/plam.js");
var types_1 = require("../../../type_system/types.js");
var type_system_1 = require("../../../type_system/index.js");
var list_1 = require("../../../lib/builtins/list/index.js");
var fromData_minimal_1 = require("../../../lib/std/data/conversion/fromData_minimal.js");
var old_1 = require("../../../lib/plet/old.js");
var minimal_1 = require("../../../lib/plet/minimal.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var IRVar_1 = require("../../../../IR/IRNodes/IRVar.js");
var IRNative_1 = require("../../../../IR/IRNodes/IRNative/index.js");
var IRApp_1 = require("../../../../IR/IRNodes/IRApp.js");
var IRHoisted_1 = require("../../../../IR/IRNodes/IRHoisted.js");
var IRFunc_1 = require("../../../../IR/IRNodes/IRFunc.js");
var IRConst_1 = require("../../../../IR/IRNodes/IRConst.js");
var IRForced_1 = require("../../../../IR/IRNodes/IRForced.js");
var IRError_1 = require("../../../../IR/IRNodes/IRError.js");
var IRDelayed_1 = require("../../../../IR/IRNodes/IRDelayed.js");
var minimal_2 = require("../../../lib/punsafeConvertType/minimal.js");
var elemAtCache = {};
function getElemAtTerm(n) {
    if (n < 0 || n !== Math.round(n))
        throw new Error("unexpected index in pmatch field extraction");
    if (elemAtCache[n] !== undefined)
        return elemAtCache[n];
    if (n === 0)
        return (0, list_1.phead)(types_1.data);
    var funcName = "elem_at_" + n.toString();
    var uplc = new IRVar_1.IRVar(0);
    var initialN = n;
    while (n > 0) {
        uplc = new IRApp_1.IRApp(IRNative_1.IRNative.tailList, uplc);
        n--;
    }
    uplc = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, new IRApp_1.IRApp(IRNative_1.IRNative.headList, uplc), funcName));
    var term = new Term_1.Term((0, types_1.lam)((0, types_1.list)(types_1.data), types_1.data), function (_dbn) { return uplc; });
    (0, obj_utils_1.defineReadOnlyProperty)(term, "$", function (lst) {
        return new Term_1.Term(types_1.data, function (dbn) { return new IRApp_1.IRApp(uplc.clone(), lst.toIR(dbn)); });
    });
    elemAtCache[initialN] = term;
    return term;
}
exports.getElemAtTerm = getElemAtTerm;
function getStructInstance(fieldsList, ctorDef) {
    var instance = {};
    var fieldNames = Object.keys(ctorDef);
    for (var i = 0; i < fieldNames.length; i++) {
        var fieldName = fieldNames[i];
        var fieldType = ctorDef[fieldName];
        Object.defineProperty(instance, fieldName, {
            value: (0, addUtilityForType_1.addUtilityForType)(fieldType)((0, minimal_2._punsafeConvertType)((0, minimal_1._plet)((0, fromData_minimal_1._fromData)(fieldType)(getElemAtTerm(i).$(fieldsList))), fieldType)),
            writable: false,
            enumerable: true,
            configurable: false
        });
    }
    /**
     * to remove in 1.0.0
     * @deprecated
     */
    Object.defineProperty(instance, "extract", {
        value: function () {
            var _fields = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _fields[_i] = arguments[_i];
            }
            return {
                in: function (cb) { return cb(instance); }
            };
        },
        writable: false,
        enumerable: true,
        configurable: false
    });
    return instance;
}
function capitalize(s) {
    if (s.length === 0)
        return s;
    return (s[0].toUpperCase() + s.slice(1));
}
var matchNCtorsIdxsCache = {};
function matchNCtorsIdxs(_n, returnT) {
    if (_n <= 1)
        throw new Error("mathcing ill formed struct data");
    var n = Math.round(_n);
    if (_n !== n)
        throw new Error("number of ctors to match must be an integer");
    if (matchNCtorsIdxsCache[n] !== undefined)
        return matchNCtorsIdxsCache[n];
    var continuationT = (0, types_1.lam)((0, types_1.list)(types_1.data), returnT);
    // built immediately; not at compilation
    // all this mess just to allow hoisting
    // you have got to reason backwards to understand the process
    var body = new IRError_1.IRError("matchNCtorsIdxs; unmatched");
    for (var i = n - 1; i >= 0; i--) {
        // pif( continuationT ).$( isCtorIdx.$( pInt( i ) ) )
        // .then( continuation_i )
        // .else( ... )
        body = new IRForced_1.IRForced(new IRApp_1.IRApp(new IRApp_1.IRApp(new IRApp_1.IRApp(IRNative_1.IRNative.strictIfThenElse, new IRApp_1.IRApp(new IRVar_1.IRVar(0), // isCtorIdx // last variable introduced (see below)
        IRConst_1.IRConst.int(i) // .$( pInt( i ) )
        )), new IRDelayed_1.IRDelayed(new IRVar_1.IRVar(2 + // isCtorIdx and structConstrPair are in scope
            i // continuation_i
        )) // then matching continuation
        ), new IRDelayed_1.IRDelayed(body) // else go check the next index; or error if it was last possible index
        ));
    }
    // plet( peqInt.$( pfstPir(...).$( structConstrPair ) ) ).in( isCtorIdx => ... )
    body = new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, // isCtorIdx
    body), 
    // peqInt.$( pfstPir(...).$( structConstrPair ) )
    new IRApp_1.IRApp(IRNative_1.IRNative.equalsInteger, new IRApp_1.IRApp(IRNative_1.IRNative.fstPair, new IRVar_1.IRVar(0) // structConstrPair // last variable introduced (see below)
    )));
    // <whatever continuation was matched>.$( psndPair(...).$( structConstrPair ) )
    // aka passing the fields to the continuation
    body = new IRApp_1.IRApp(body, new IRApp_1.IRApp(IRNative_1.IRNative.sndPair, new IRVar_1.IRVar(0)));
    // plet( punConstrData.$( structData ) )  ).in( structConstrPair => ... )
    body = new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, // structConstrPair
    body), new IRApp_1.IRApp(IRNative_1.IRNative.unConstrData, new IRVar_1.IRVar(n) // structData
    ));
    for (var i = n - 1; i >= 0; i--) {
        body = new IRFunc_1.IRFunc(1, // continuation n - 1 - i
        body);
    }
    // seriously, all this mess for this IRHoisted
    body = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // structData
    body), { name: "match_" + n + "_ctors" });
    return new Term_1.Term((0, types_1.fn)(__spreadArray([
        types_1.data
    ], __read((new Array(n).fill(continuationT))), false), returnT), function (_dbn) { return body; });
}
exports.matchNCtorsIdxs = matchNCtorsIdxs;
function getReturnTypeFromContinuation(cont, ctorDef) {
    return cont(
    // mock the fields
    // we are not really interested in the result here; only in the type
    new Term_1.Term((0, types_1.list)(types_1.data), function (_dbn) {
        return IRConst_1.IRConst.listOf(types_1.data)((new Array(Object.keys(ctorDef).length))
            .fill(new plutus_data_1.DataI(0)));
    })).type;
}
/**
 *
 * @param structData
 * @param sDef
 * @param ctorCbs
 *
 * @returns the term that matches the ctor
 */
function hoistedMatchCtors(structData, sDef, ctorCbs) {
    var _a;
    var length = ctorCbs.length;
    if (length <= 0)
        throw new Error("trying to match ill formed struct");
    // const returnT = tyVar("single_ctor_match_return_type");
    var ctors = Object.keys(sDef);
    if (length === 1) {
        var cont_1 = ctorCbs[0];
        if (cont_1 instanceof Term_1.Term) {
            if (cont_1.type[0] !== "lam" /* PrimType.Lambda */) {
                // todo: add proper error
                throw new Error("pmatch continuation was not a lambda");
            }
            return (0, papp_1.papp)(cont_1, (0, papp_1.papp)(matchSingleCtorStruct_1.getFields, structData));
        }
        var thisCtorDef_1 = sDef[ctors[0]];
        var returnT_1 = getReturnTypeFromContinuation(cont_1, thisCtorDef_1);
        return (0, papp_1.papp)((0, plam_1.plam)((0, types_1.list)(types_1.data), returnT_1)(cont_1), (0, papp_1.papp)(matchSingleCtorStruct_1.getFields, structData));
    }
    // multiple ctors struct case
    var ctorIdx = 0;
    var cont = (_a = ctorCbs.find(function (cb, i) {
        if (typeof cb === "function") {
            ctorIdx = i;
            return true;
        }
        return false;
    })) !== null && _a !== void 0 ? _a : ctorCbs[0];
    var thisCtorDef = sDef[Object.keys(sDef)[ctorIdx]];
    var returnT = cont instanceof Term_1.Term ?
        cont.type[2] :
        getReturnTypeFromContinuation(cont, thisCtorDef);
    var result = (0, papp_1.papp)(matchNCtorsIdxs(ctors.length, returnT), structData);
    for (var i = ctors.length - 1; i >= 0; i--) {
        var thisCont = ctorCbs[i];
        var thisCtorDef_2 = sDef[ctors[i]];
        result = (0, papp_1.papp)(result, thisCont instanceof Term_1.Term ? thisCont :
            (0, plam_1.plam)((0, types_1.list)(types_1.data), returnT !== null && returnT !== void 0 ? returnT : getReturnTypeFromContinuation(thisCont, thisCtorDef_2))(thisCont));
    }
    return result;
}
function pmatch(struct) {
    var sDef = struct.type[1];
    if (!(0, type_system_1.isStructDefinition)(sDef)) {
        /**
         * @todo add proper error
         */
        throw new Error("unexpected struct type while running 'pmatch'; " +
            "\ntype expected to be a 'ConstantableStructDefiniton' was: " + (0, type_system_1.termTypeToString)(struct.type));
    }
    var ctors = Object.keys(sDef);
    var ctorCbs = ctors.map(function (_) { return undefined; });
    function indexOfCtor(ctor) {
        var res = ctors.indexOf(ctor);
        if (res < 0) {
            throw new Error("internal function 'indexOfCtor' in 'definePMatchPermutations' couldn't find the constructor \"" + ctor +
                "\" between [" + ctors.map(function (c) { return c.toString(); }).join(',') + ']');
        }
        return res;
    }
    function permutations(missingCtors) {
        if (missingCtors.length <= 0)
            return {};
        // last permutation
        // returns the final expression
        if (missingCtors.length === 1) {
            var ctor_1 = missingCtors[0];
            var idx_1 = indexOfCtor(ctor_1);
            var matcher = "on" + capitalize(ctor_1);
            var result = {};
            (0, obj_utils_1.defineReadOnlyProperty)(result, matcher, function (cb) {
                // build the `StructInstance` input from the struct fields
                var callback = function (mathcedCtorsFields) {
                    return cb(getStructInstance(mathcedCtorsFields, sDef[ctor_1]));
                };
                // same stuff of previous ctors
                ctorCbs[idx_1] = callback;
                return hoistedMatchCtors(struct, sDef, ctorCbs);
            });
            return (0, obj_utils_1.defineReadOnlyProperty)(result, "_", result[matcher]);
        }
        var remainingCtorsObj = {};
        // here add all the missing ctors contiunuations
        missingCtors.forEach(function (ctor) {
            var idx = indexOfCtor(ctor);
            (0, obj_utils_1.defineReadOnlyProperty)(remainingCtorsObj, "on" + capitalize(ctor), function (cb) {
                ctorCbs[idx] = function (fieldsList) { return cb(getStructInstance(fieldsList, sDef[ctor])); };
                return permutations(missingCtors.filter(function (c) { return c !== ctor; }));
            });
        });
        return (0, obj_utils_1.defineReadOnlyProperty)(remainingCtorsObj, "_", function (cb) {
            var maxLengthFound = ctors
                .map(function (ctor) { return Object.keys(sDef[ctor]).length; })
                .reduce(function (prev, curr, i) { return Math.max(prev, curr); }, 0);
            var returnT = getReturnTypeFromContinuation(cb, sDef[ctors[ctors.findIndex(function (ctor) { return Object.keys(sDef[ctor]).length === maxLengthFound; })]]);
            return (0, old_1._old_plet)((0, plam_1.plam)((0, types_1.list)(types_1.data), returnT)(cb)).in(function (othCtorsContinuation) {
                for (var i = 0; i < ctorCbs.length; i++) {
                    if (typeof ctorCbs[i] !== "function") {
                        ctorCbs[i] = othCtorsContinuation;
                    }
                }
                var res = hoistedMatchCtors(
                /*
                 Argument of type 'Term<PStruct<SDef>>' is not assignable to parameter of type 'Term<PStruct<StructDefinition>>'.
                    Type 'PStruct<SDef>' is not assignable to type 'PStruct<StructDefinition>'.
                */
                struct, sDef, ctorCbs);
                return res;
            });
        });
    }
    return permutations(ctors);
}
exports.pmatch = pmatch;
