"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pfoldl = void 0;
var type_system_1 = require("../../../type_system/index.js");
var papp_1 = require("../../papp.js");
var pdelay_1 = require("../../pdelay.js");
var pfn_1 = require("../../pfn.js");
var phoist_1 = require("../../phoist.js");
var plam_1 = require("../../plam.js");
var precursive_1 = require("../../precursive/index.js");
var pmatchList_1 = require("./pmatchList/index.js");
function pfoldl(elemsT, resultT) {
    var a = elemsT;
    var b = resultT;
    var recursivePartType = (0, type_system_1.fn)([
        b,
        (0, type_system_1.list)(a)
    ], b);
    return (0, phoist_1.phoist)((0, plam_1.plam)((0, type_system_1.fn)([b, a], b), recursivePartType)(function (reduceFunc) {
        return (0, precursive_1.precursive)((0, pfn_1.pfn)([
            recursivePartType,
            b
        ], (0, type_system_1.lam)((0, type_system_1.list)(a), b))(function (self, accum) {
            return (0, pmatchList_1.pmatchList)(b, a)
                .$((0, pdelay_1.pdelay)(accum))
                .$((0, pfn_1.pfn)([a, (0, type_system_1.list)(a)], b)(function (head, tail) {
                return (0, papp_1.papp)((0, papp_1.papp)(self, 
                // compute new accumulator
                // BEFORE the rest of the list
                (0, papp_1.papp)(reduceFunc, accum).$(head)), tail);
            }));
        }
        // .$( lst )
        ));
    }, "pfoldl"));
}
exports.pfoldl = pfoldl;
