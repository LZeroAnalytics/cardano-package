import { PType } from "../../../PType/index.js";
import type { PBool, PByteString, PInt, PList, PPair, PString, PStruct, PLam, PAlias } from "../../../PTypes/index.js";
import { Term } from "../../../Term/index.js";
import { ToPType } from "../../../type_system/ts-pluts-conversion.js";
import { Methods, StructDefinition, TermType } from "../../../type_system/types.js";
import type { PappArg } from "../../pappArg.js";
import { type TermAlias, type TermBool, type TermBS, type TermInt, type TermList, type TermPair, type TermStr, type TermStruct } from "./index.js";
type PrevNum = [never, 0, 1, 2, 3, 4, 5, 6];
type FiniteTermAlias<PT extends PType, AMethods extends Methods, MaxDepth extends PrevNum[number] = 6> = MaxDepth extends never ? never : PT extends PAlias<infer ActualPT extends PType, infer ActualAMethods extends Methods> ? FiniteTermAlias<ActualPT, ActualAMethods & AMethods, PrevNum[MaxDepth]> : TermAlias<PT, AMethods>;
export type UtilityTermOf<PElem extends PType> = (PElem extends PBool ? TermBool : PElem extends PByteString ? TermBS : PElem extends PInt ? TermInt : PElem extends PList<infer PListElem extends PType> ? TermList<PListElem> : PElem extends PPair<infer PFst extends PType, infer PSnd extends PType> ? TermPair<PFst, PSnd> : PElem extends PString ? TermStr : PElem extends PStruct<infer SDef extends StructDefinition, infer SMethods extends Methods> ? TermStruct<SDef, SMethods> : PElem extends PLam<infer PInput extends PType, infer POutput extends PType> ? Term<PElem> & {
    $: (input: PappArg<PInput>) => UtilityTermOf<POutput>;
} : PElem extends PAlias<infer PT extends PType, infer AMethods extends Methods> ? FiniteTermAlias<PT, AMethods> : Term<PElem>) & Term<PElem>;
export declare function addUtilityForType<T extends TermType>(t: T): (term: Term<ToPType<T>>) => UtilityTermOf<ToPType<T>>;
export declare function addPAliasMethods<PAliased extends PType, AMethods extends Methods>(aliasTerm: Term<PAlias<PAliased, AMethods>>): TermAlias<PAliased, AMethods>;
export {};
