"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMinVarDbn = exports.getNormalizedLettedArgs = exports.getLettedTerms = exports.default_getLettedTermsOptions = exports.getSortedLettedSet = exports.IRLetted = exports.expandedJsonLettedSetEntry = exports.jsonLettedSetEntry = void 0;
var iterTree_1 = require("../toUPLC/_internal/iterTree.js");
var IRVar_1 = require("./IRVar.js");
var positiveIntAsBytes_1 = require("../utils/positiveIntAsBytes.js");
var crypto_1 = require("@harmoniclabs/crypto");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var BasePlutsError_1 = require("../../utils/BasePlutsError.js");
var concatUint8Arr_1 = require("../utils/concatUint8Arr.js");
var isIRTerm_1 = require("../utils/isIRTerm.js");
var IRApp_1 = require("./IRApp.js");
var IRDelayed_1 = require("./IRDelayed.js");
var IRForced_1 = require("./IRForced.js");
var IRFunc_1 = require("./IRFunc.js");
var IRHoisted_1 = require("./IRHoisted.js");
var utils_1 = require("../utils/index.js");
var isIRParentTerm_1 = require("../utils/isIRParentTerm.js");
var _modifyChildFromTo_1 = require("../toUPLC/_internal/_modifyChildFromTo.js");
var groupByScope_1 = require("../toUPLC/subRoutines/handleLetted/groupByScope.js");
function jsonLettedSetEntry(entry) {
    return {
        letted: (0, uint8array_utils_1.toHex)(entry.letted.hash),
        nReferences: entry.nReferences
    };
}
exports.jsonLettedSetEntry = jsonLettedSetEntry;
function expandedJsonLettedSetEntry(entry) {
    return {
        letted: (0, uint8array_utils_1.toHex)(entry.letted.hash),
        letted_value: (0, utils_1.prettyIR)(entry.letted.value).text.split("\n"),
        nReferences: entry.nReferences
    };
}
exports.expandedJsonLettedSetEntry = expandedJsonLettedSetEntry;
var defaultLettedMeta = (0, obj_utils_1.freezeAll)({
    forceHoist: false
});
var IRLetted = /** @class */ (function () {
    function IRLetted(DeBruijn, toLet, metadata, unsafe_hash) {
        if (metadata === void 0) { metadata = {}; }
        if (unsafe_hash === void 0) { unsafe_hash = undefined; }
        var _this = this;
        DeBruijn = typeof DeBruijn === "bigint" ? Number(DeBruijn) : DeBruijn;
        if (!(Number.isSafeInteger(DeBruijn) && DeBruijn >= 0))
            throw new BasePlutsError_1.BasePlutsError("invalid index for an `IRLetted` instance");
        var _dbn = DeBruijn;
        Object.defineProperty(this, "dbn", {
            get: function () { return _dbn; },
            set: function (newDbn) {
                if (!(Number.isSafeInteger(newDbn) && newDbn >= 0))
                    throw new BasePlutsError_1.BasePlutsError("invalid index for an `IRLetted` instance");
                if (newDbn === _dbn) {
                    // everything ok
                    // avoid calling `markHashAsInvalid` 
                    return;
                }
                _this.markHashAsInvalid();
                _dbn = newDbn;
            },
            enumerable: true,
            configurable: false
        });
        if (!(0, isIRTerm_1.isIRTerm)(toLet))
            throw new BasePlutsError_1.BasePlutsError("letted value was not an IRTerm");
        // initialize without calling "set"
        // cloning here otherwhise breaks the tree
        // TODO: find what is breaking the tree
        // when solved add `this.value.clone()` to the `IRLetted.clone` method below 
        var _value = toLet.clone();
        _value.parent = this;
        // we need the has before setting dependecies
        var hash = unsafe_hash instanceof Uint8Array ? new Uint8Array(unsafe_hash) : undefined;
        Object.defineProperty(this, "hash", {
            get: function () {
                if (!(hash instanceof Uint8Array)) {
                    var normalized = getNormalizedLettedArgs(_this.dbn, _value);
                    if (normalized === undefined) {
                        // `_value` doesn't includes any `IRVar`
                        // aka. there is nothing to normalize
                        // just use the value regardless of the
                        // `IRLetted` dbn instantiation
                        hash = (0, crypto_1.blake2b_128)((0, concatUint8Arr_1.concatUint8Arr)(IRLetted.tag, _value.hash));
                    }
                    else {
                        hash = (0, crypto_1.blake2b_128)((0, concatUint8Arr_1.concatUint8Arr)(IRLetted.tag, (0, positiveIntAsBytes_1.positiveIntAsBytes)(normalized[0]), normalized[1].hash));
                        // const [ normalized_dbn, normalized_value] = normalized;
                        // if( toHex( hash ) === "ee84fb036ed2726e01b0415109246927" )
                        // {
                        //     const original_value = _value.clone();
                        //     const minDbn = getMinVarDbn( original_value );
                        //     const minUnb = _getMinUnboundDbn( original_value );
                        //     console.log(
                        //         "_ee84fb036ed2726e01b0415109246927_",
                        //         "\noriginal value:", prettyIRJsonStr( original_value, 2, { hoisted: false } ),
                        //         "\nmin dbn:", minDbn,
                        //         "\nmin unbound:", minUnb,
                        //         "\nnormalized dbn:", normalized_dbn,
                        //     );
                        // }
                    }
                }
                return hash.slice();
            },
            set: function () { },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "markHashAsInvalid", {
            value: function () {
                var _a;
                hash = undefined;
                // tree changed; possibly dependencies too
                _deps = undefined;
                (_a = _this.parent) === null || _a === void 0 ? void 0 : _a.markHashAsInvalid();
            },
            writable: false,
            enumerable: false,
            configurable: false
        });
        // make sure to use the cloned `_value` and NOT `toLet`
        // since we need the same root ( setted trough `parent` )
        var _deps = undefined;
        function _getDeps() {
            if (_deps === undefined)
                _deps = getSortedLettedSet(getLettedTerms(_value));
            return _deps;
        }
        Object.defineProperty(this, "value", {
            get: function () { return _value; },
            set: function (newVal) {
                if (!(0, isIRTerm_1.isIRTerm)(newVal))
                    throw new BasePlutsError_1.BasePlutsError("letted term was not IRTerm");
                _this.markHashAsInvalid();
                _deps = undefined;
                _value = newVal;
                _value.parent = _this;
            },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "isClosedAtDbn", {
            value: function (dbn) {
                if (!Number.isSafeInteger(dbn))
                    throw new Error("unexpected unsafe dbn integer");
                var minUnbound = (0, groupByScope_1._getMinUnboundDbn)(_value);
                if (minUnbound === undefined)
                    return true;
                return minUnbound < dbn;
            },
            writable: false,
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "dependencies", {
            get: function () { return _getDeps(); }
            /*
            .map( dep => {

                // const clone = dep.letted.clone();
                // clone.parent = dep.letted.parent;
                return {
                    letted: dep.letted,
                    nReferences: dep.nReferences
                }
            }
            ), // MUST return clones
            //*/
            ,
            set: function () { },
            enumerable: true,
            configurable: false
        });
        var _parent = undefined;
        Object.defineProperty(this, "parent", {
            get: function () { return _parent; },
            set: function (newParent) {
                if (!( // assert
                // new parent value is different than current
                _parent !== newParent && (
                // and the new parent value is valid
                newParent === undefined ||
                    (0, isIRParentTerm_1.isIRParentTerm)(newParent))))
                    return;
                // keep reference
                var oldParent = _parent;
                // change parent
                _parent = newParent;
                // if has old parent
                if (oldParent !== undefined && (0, isIRParentTerm_1.isIRParentTerm)(oldParent)) {
                    // change reference to a clone for safety
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(oldParent, _this, _this.clone());
                }
            },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "meta", {
            value: __assign(__assign({}, defaultLettedMeta), metadata),
            writable: false,
            enumerable: true,
            configurable: false
        });
        (0, obj_utils_1.defineReadOnlyProperty)(this, "clone", function () {
            return new IRLetted(_this.dbn, _this.value, __assign({}, _this.meta), hash instanceof Uint8Array ? Uint8Array.prototype.slice.call(hash) : undefined);
        });
    }
    Object.defineProperty(IRLetted, "tag", {
        get: function () { return new Uint8Array([5]); },
        enumerable: false,
        configurable: true
    });
    IRLetted.prototype.toJson = function () {
        return {
            type: "IRLetted",
            hash: (0, uint8array_utils_1.toHex)(this.hash),
            value: this.value.toJson()
        };
    };
    return IRLetted;
}());
exports.IRLetted = IRLetted;
/**
 * basically an insertion sort;
 *
 * @param {LettedSetEntry[]} lettedTerms
 * @returns {LettedSetEntry[]} a **new** array with ```IRLetted```s with no dependencies first, followed by the dependents
 */
function getSortedLettedSet(lettedTerms) {
    var set = [];
    var hashesSet = [];
    /**
     * **O((n * m) * d)**
     *
     * where
     *
     *      n = length of set
     *      m = number of terms passed
     *      d = number of unique dependencies among the passed terms
     */
    function addToSet(_terms) {
        var _loop_1 = function (i) {
            var thisLettedEntry = _terms[i];
            var thisHash = thisLettedEntry.letted.hash;
            var idxInSet = hashesSet.findIndex(function (hash) { return (0, uint8array_utils_1.uint8ArrayEq)(hash, thisHash); });
            // if( !hashesSet.includes( hash ) )
            // "includes" uses standard equality (===)
            if (idxInSet < 0) // not present
             {
                // add dependencies first
                // dependencies don't have references to the current letted
                // (of course, wouldn't be much of a dependecy otherwhise)
                //
                // don't add dependecies of dependecies since `dependecies` proerty
                // already calls `getSortedLettedSet( getLettedTerms( _value ) )`
                // so repeating it here would count deps twice (exponentially for deps of deps)
                addToSet(getLettedTerms(thisLettedEntry.letted.value));
                hashesSet.push(thisHash);
                set.push({
                    letted: thisLettedEntry.letted,
                    nReferences: thisLettedEntry.nReferences
                });
            }
            else {
                var entry = set[idxInSet];
                entry.nReferences += thisLettedEntry.nReferences;
                entry.letted.meta.forceHoist =
                    entry.letted.meta.forceHoist ||
                        thisLettedEntry.letted.meta.forceHoist;
            }
        };
        for (var i = 0; i < _terms.length; i++) {
            _loop_1(i);
        }
    }
    addToSet(lettedTerms);
    return set;
}
exports.getSortedLettedSet = getSortedLettedSet;
exports.default_getLettedTermsOptions = {
    all: false,
    includeHoisted: false
};
/**
 *
 * @param {IRTerm} irTerm term to search in
 * @returns direct letted terms (no possible dependencies)
 */
function getLettedTerms(irTerm, options) {
    var _a = __assign(__assign({}, exports.default_getLettedTermsOptions), options), all = _a.all, includeHoisted = _a.includeHoisted;
    var lettedTerms = [];
    var stack = [irTerm];
    while (stack.length > 0) {
        var t = stack.pop();
        if (t instanceof IRLetted) {
            lettedTerms.push({ letted: t, nReferences: 1 });
            if (all) {
                stack.push(t.value);
            }
            continue;
        }
        if (t instanceof IRApp_1.IRApp) {
            stack.push(t.fn, t.arg);
            continue;
        }
        if (t instanceof IRFunc_1.IRFunc) {
            stack.push(t.body);
            continue;
        }
        if (t instanceof IRForced_1.IRForced) {
            stack.push(t.forced);
            continue;
        }
        if (t instanceof IRDelayed_1.IRDelayed) {
            stack.push(t.delayed);
            continue;
        }
        if (includeHoisted) {
            if (t instanceof IRHoisted_1.IRHoisted) {
                stack.push(t.hoisted);
                continue;
            }
        }
    }
    return lettedTerms;
}
exports.getLettedTerms = getLettedTerms;
function getNormalizedLettedArgs(lettedDbn, value) {
    var _a;
    var normalized_value = value.clone();
    var minDbn = getMinVarDbn(normalized_value);
    if (minDbn === undefined)
        return undefined;
    (0, iterTree_1.iterTree)(normalized_value, function (node, relativeDbn) {
        if (node instanceof IRVar_1.IRVar) {
            node.dbn -= minDbn;
        }
        else if (node instanceof IRLetted) {
            var max = getMaxVarDbn(node.value);
            if (
            // no vars
            typeof max !== "number" ||
                // defined outside of letted
                max >= relativeDbn) {
                node.dbn -= minDbn;
            }
            else // if depends on vars in this letted
             {
                // TODO: fix double checking already inlined values
                //
                // this is currently a workaround
                //
                // the real problem is that sometimes (when?)
                // `iterTree` goes back checking some value that was already modified
                // in the case of `IRApp` as parent, throwing an error
                // because we don't know which value we should modify
                if (node.parent instanceof IRApp_1.IRApp) {
                    var parent_1 = node.parent;
                    var currentChild = node;
                    if ( // parent is actually pointing to child
                    currentChild === parent_1.arg ||
                        currentChild === parent_1.fn ||
                        (0, uint8array_utils_1.uint8ArrayEq)(parent_1.arg.hash, currentChild.hash) ||
                        (0, uint8array_utils_1.uint8ArrayEq)(parent_1.fn.hash, currentChild.hash)) {
                        // inline
                        (0, _modifyChildFromTo_1._modifyChildFromTo)(node.parent, node, node.value);
                        return true; // modified parent
                    }
                    else
                        return false; // modified parent
                }
                else {
                    // inline
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(node.parent, node, node.value);
                    return true; // modified parent
                }
            }
        }
    }, 
    // shouldSkipNode ?
    // hoisted terms are not really here
    // will be substituted to variables when the time comes
    // however now are here and we need to skip them
    //
    // !!! WARNING !! removing this causes strange uplc compilation BUGS
    function (node, dbn) { return node instanceof IRHoisted_1.IRHoisted; });
    // !!! IMPORTANT !!! _getMinUnboundDbn( value ) MUST be called on the original value; NOT the **modified** `normalized_value`
    return [lettedDbn - ((_a = (0, groupByScope_1._getMinUnboundDbn)(value)) !== null && _a !== void 0 ? _a : minDbn), normalized_value];
}
exports.getNormalizedLettedArgs = getNormalizedLettedArgs;
/**
 *
 * @param term the ir term to iter to search for vars
 * @returns {number | undefined}
 *
 * @example
 * ```ts
 * let minDbn = getMinVarDbn( new IRVar(0) ); // 0
 * minDbn = getMinVarDbn( IRConst.unit ); // undefined
 * minDbn = getMinVarDbn( new IRFunc( 1, new IRVar( 0 ) ) ); // 0
 * ```
 */
function getMinVarDbn(term) {
    var min = undefined;
    var foundAny = false;
    (0, iterTree_1.iterTree)(term, function (node) {
        if (node instanceof IRVar_1.IRVar) {
            if (foundAny) {
                min = Math.min(min, node.dbn);
            }
            else {
                foundAny = true;
                min = node.dbn;
            }
        }
    }, 
    // shouldSkipNode ?
    // hoisted terms are not really here
    // will be substituted to variables when the time comes
    // however now are here and we need to skip them
    function (node) { return node instanceof IRHoisted_1.IRHoisted; } // skip if hoisted
    );
    return min;
}
exports.getMinVarDbn = getMinVarDbn;
/**
 *
 * @param term the ir term to iter to search for vars
 * @returns {number | undefined}
 */
function getMaxVarDbn(term) {
    var max = undefined;
    var foundAny = false;
    (0, iterTree_1.iterTree)(term, function (node) {
        if (node instanceof IRVar_1.IRVar) {
            if (foundAny) {
                max = Math.max(max, node.dbn);
            }
            else {
                foundAny = true;
                max = node.dbn;
            }
        }
    }, 
    // shouldSkipNode ?
    // hoisted terms are not really here
    // will be substituted to variables when the time comes
    // however now are here and we need to skip them
    function (node) { return node instanceof IRHoisted_1.IRHoisted; } // skip if hoisted
    );
    return max;
}
