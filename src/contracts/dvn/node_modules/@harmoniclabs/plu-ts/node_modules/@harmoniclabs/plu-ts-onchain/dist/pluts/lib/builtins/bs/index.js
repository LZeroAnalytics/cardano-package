"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pverifySecp256k1Schnorr = exports.pverifySecp256k1ECDSA = exports.pverifyEd25519 = exports.pblake2b_256 = exports.psha3_256 = exports.psha2_256 = exports.pgreaterEqBS = exports.pgreaterBS = exports.plessEqBs = exports.plessBs = exports.peqBs = exports.pindexBs = exports.plengthBs = exports.psliceBs = exports.flippedCons = exports.pconsBs = exports.pappendBs = void 0;
var Term_1 = require("../../../Term/index.js");
var type_system_1 = require("../../../type_system/index.js");
var papp_1 = require("../../papp.js");
var phoist_1 = require("../../phoist.js");
var TermBS_1 = require("../../std/UtilityTerms/TermBS.js");
var TermBool_1 = require("../../std/UtilityTerms/TermBool.js");
var TermInt_1 = require("../../std/UtilityTerms/TermInt.js");
var addApplications_1 = require("../addApplications.js");
var pfn_1 = require("../../pfn.js");
var _pflipIR_1 = require("../_pflipIR.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var IRNative_1 = require("../../../../IR/IRNodes/IRNative/index.js");
var IRHoisted_1 = require("../../../../IR/IRNodes/IRHoisted.js");
var IRApp_1 = require("../../../../IR/IRNodes/IRApp.js");
function byteStrBinOpToBS(builtin) {
    var op = new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.bs], type_system_1.bs), function (_dbn) { return builtin; });
    return (0, obj_utils_1.defineReadOnlyProperty)(op, "$", function (fstIn) {
        var oneIn = (0, papp_1.papp)(op, fstIn);
        return (0, obj_utils_1.defineReadOnlyProperty)(oneIn, "$", function (sndIn) {
            return (0, TermBS_1.addPByteStringMethods)((0, papp_1.papp)(oneIn, sndIn));
        });
    });
}
function byteStrBinOpToBool(builtin) {
    var op = new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.bs], type_system_1.bool), function (_dbn) { return builtin; });
    return (0, obj_utils_1.defineReadOnlyProperty)(op, "$", function (fstIn) {
        var oneIn = 
        // @ts-ignore Type instantiation is excessively deep and possibly infinite
        (0, papp_1.papp)(op, fstIn);
        return (0, obj_utils_1.defineReadOnlyProperty)(oneIn, "$", function (sndIn) {
            return (0, TermBool_1.addPBoolMethods)((0, papp_1.papp)(oneIn, sndIn));
        });
    });
}
exports.pappendBs = byteStrBinOpToBS(IRNative_1.IRNative.appendByteString);
exports.pconsBs = (function () {
    var consByteString = new Term_1.Term((0, type_system_1.fn)([type_system_1.int, type_system_1.bs], type_system_1.bs), function (_dbn) { return IRNative_1.IRNative.consByteString; });
    return (0, obj_utils_1.defineReadOnlyProperty)(consByteString, "$", function (byte) {
        var consByteStringFixedByte = (0, papp_1.papp)(consByteString, byte);
        return (0, obj_utils_1.defineReadOnlyProperty)(consByteStringFixedByte, "$", function (toByteString) {
            return (0, TermBS_1.addPByteStringMethods)((0, papp_1.papp)(consByteStringFixedByte, toByteString));
        });
    });
})();
exports.flippedCons = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.int], type_system_1.bs), function (_dbn) { return new IRHoisted_1.IRHoisted(new IRApp_1.IRApp(_pflipIR_1._pflipIR.clone(), IRNative_1.IRNative.consByteString)); }));
exports.psliceBs = (function () {
    var sliceBs = new Term_1.Term((0, type_system_1.fn)([type_system_1.int, type_system_1.int, type_system_1.bs], type_system_1.bs), function (_dbn) { return IRNative_1.IRNative.sliceByteString; });
    return (0, obj_utils_1.defineReadOnlyProperty)(sliceBs, "$", function (fromIndex) {
        var sliceBsFromIdx = (0, papp_1.papp)(sliceBs, fromIndex);
        return (0, obj_utils_1.defineReadOnlyProperty)(sliceBsFromIdx, "$", function (ofLength) {
            var sliceBsFromIdxOfLength = (0, papp_1.papp)(sliceBsFromIdx, ofLength);
            return (0, obj_utils_1.defineReadOnlyProperty)(sliceBsFromIdxOfLength, "$", function (onByteString) {
                return (0, TermBS_1.addPByteStringMethods)((0, papp_1.papp)(sliceBsFromIdxOfLength, onByteString));
            });
        });
    });
})();
exports.plengthBs = (function () {
    var lenBS = new Term_1.Term((0, type_system_1.lam)(type_system_1.bs, type_system_1.int), function (_dbn) { return IRNative_1.IRNative.lengthOfByteString; });
    return (0, obj_utils_1.defineReadOnlyProperty)(lenBS, "$", function (ofByteString) {
        return (0, TermInt_1.addPIntMethods)((0, papp_1.papp)(lenBS, ofByteString));
    });
})();
exports.pindexBs = (function () {
    var idxBS = new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.int], type_system_1.int), function (_dbn) { return IRNative_1.IRNative.indexByteString; });
    return (0, obj_utils_1.defineReadOnlyProperty)(idxBS, "$", function (ofByteString) {
        var idxOfBS = (0, papp_1.papp)(idxBS, ofByteString);
        return (0, obj_utils_1.defineReadOnlyProperty)(idxOfBS, "$", function (index) {
            return (0, TermInt_1.addPIntMethods)((0, papp_1.papp)(idxOfBS, index));
        });
    });
})();
exports.peqBs = byteStrBinOpToBool(IRNative_1.IRNative.equalsByteString);
exports.plessBs = byteStrBinOpToBool(IRNative_1.IRNative.lessThanByteString);
exports.plessEqBs = byteStrBinOpToBool(IRNative_1.IRNative.lessThanEqualsByteString);
exports.pgreaterBS = (0, phoist_1.phoist)((0, pfn_1.pfn)([type_system_1.bs, type_system_1.bs], type_system_1.bool)(function (a, b) { return exports.plessBs.$(b).$(a); }));
exports.pgreaterEqBS = (0, phoist_1.phoist)((0, pfn_1.pfn)([type_system_1.bs, type_system_1.bs], type_system_1.bool)(function (a, b) { return exports.plessEqBs.$(b).$(a); }));
exports.psha2_256 = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.lam)(type_system_1.bs, type_system_1.bs), function (_dbn) { return IRNative_1.IRNative.sha2_256; }));
exports.psha3_256 = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.lam)(type_system_1.bs, type_system_1.bs), function (_dbn) { return IRNative_1.IRNative.sha3_256; }));
exports.pblake2b_256 = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.lam)(type_system_1.bs, type_system_1.bs), function (_dbn) { return IRNative_1.IRNative.blake2b_256; }));
/**
 * performs cryptographic signature verification using the Ed25519 scheme
 *
 * @param {PByteString} key ```PByteString``` of length 32 ( ```PubKeyHash``` )
 * @param {PByteString} message abitrary length ```PByteString```
 * @param {PByteString} signature ```PByteString``` of length 64
 * @returns {PBool}
 *
 * @throws
 * @fails
 */
exports.pverifyEd25519 = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.bs, type_system_1.bs], type_system_1.bool), function (_dbn) { return IRNative_1.IRNative.verifyEd25519Signature; }));
// --------------------------------------------------------------------------------------------------------------------- //
// ----------------------------------------------- [ VASIL (Plutus V2) ] ----------------------------------------------- //
// --------------------------------------------------------------------------------------------------------------------- //
/**
 * performs elliptic curve digital signature verification (ANSI [2005, 2020], Johnson and Menezes)
 * over the secp256k1 curve (see Certicom Research [2010], ¬ß2.4.1) and conforms to the interface described in
 * Note 5 of Section A.2. The arguments must have the following sizes:
 * ‚Ä¢ ùëò: 64 bytes
 * ‚Ä¢ ùëö: 32 bytes
 * ‚Ä¢ ùë†: 64 bytes.
 * The ECDSA scheme admits two distinct valid signatures for a given message and private key. We follow
 * the restriction imposed by Bitcoin (see Lau and Wuilie [2016], LOW_S) and only accept the smaller
 * signature: verifyEcdsaSecp256k1Signature will return false if the larger one is supplied.
 *
 * @param {PByteString} key ```PByteString``` of length 32 ( ```PubKeyHash``` )
 * @param {PByteString} message ```PByteString``` of length 32
 * @param {PByteString} signature ```PByteString``` of length 64
 * @returns {PBool}
 *
 * @throws
 * @fails
 */
exports.pverifySecp256k1ECDSA = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.bs, type_system_1.bs], type_system_1.bool), function (_dbn) { return IRNative_1.IRNative.verifyEcdsaSecp256k1Signature; }));
/**
* performs verification of Schnorr signatures ( Schnorr [1989], Lau et al. [2020]) over the secp256k1 curve
*
* @param {PByteString} key ```PByteString``` of length 64
* @param {PByteString} message abitrary length ```PByteString```
* @param {PByteString} signature ```PByteString``` of length 64
* @returns {PBool}
*
* @throws
* @fails
*/
exports.pverifySecp256k1Schnorr = (0, addApplications_1.addApplications)(new Term_1.Term((0, type_system_1.fn)([type_system_1.bs, type_system_1.bs, type_system_1.bs], type_system_1.bool), function (_dbn) { return IRNative_1.IRNative.verifySchnorrSecp256k1Signature; }));
