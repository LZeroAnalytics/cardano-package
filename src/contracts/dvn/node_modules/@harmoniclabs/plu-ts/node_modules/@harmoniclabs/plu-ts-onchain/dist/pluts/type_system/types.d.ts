import { PLam } from "../PTypes/index.js";
import { PType } from "../PType/index.js";
import { Term } from "../Term/index.js";
export declare const enum PrimType {
    Int = "int",
    BS = "bs",
    Str = "str",
    Unit = "unit",
    Bool = "bool",
    Data = "data",
    List = "list",
    Pair = "pair",
    Delayed = "delayed",
    Lambda = "lam",
    Struct = "struct",
    Alias = "alias",
    AsData = "asData"
}
export type Methods = {
    [method: string]: Term<PLam<PType, PType>>;
};
export type ListT<T extends GenericTermType> = [PrimType.List, T];
export type DelayedT<T extends GenericTermType> = [PrimType.Delayed, T];
export type PairT<FstT extends GenericTermType, SndT extends GenericTermType> = [PrimType.Pair, FstT, SndT];
export type StructT<GSDef extends GenericStructDefinition, SMethods extends Methods = {}> = [PrimType.Struct, GSDef, SMethods];
export type AliasT<T extends GenericTermType, AMethods extends Methods = {}> = T[0] extends PrimType.Alias ? T : [PrimType.Alias, T, AMethods];
export type AsDataT<T extends GenericTermType> = T[0] extends PrimType.AsData ? T : [PrimType.AsData, T];
export type LamT<InT extends GenericTermType, OutT extends GenericTermType> = [PrimType.Lambda, InT, OutT];
export type FnT<Ins extends [GenericTermType, ...GenericTermType[]], OutT extends GenericTermType> = Ins extends [] ? OutT : Ins extends [infer In extends GenericTermType] ? LamT<In, OutT> : Ins extends [infer In extends GenericTermType, ...infer RestIns extends [GenericTermType, ...GenericTermType[]]] ? LamT<In, FnT<RestIns, OutT>> : GenericTermType;
type NonStructTag = PrimType.Int | PrimType.BS | PrimType.Str | PrimType.Unit | PrimType.Bool | PrimType.Data | PrimType.List | PrimType.Pair | PrimType.Delayed | PrimType.Lambda | PrimType.AsData;
export type TermType = [NonStructTag, ...TermType[]] | [PrimType.Struct, StructDefinition, Methods] | [PrimType.Alias, TermType, Methods];
export type NonAliasTermType = [NonStructTag, ...TermType[]] | [PrimType.Struct, StructDefinition, Methods];
export type StructCtorDef = {
    [field: string | number]: TermType;
};
export type StructDefinition = {
    [constructor: string]: StructCtorDef;
};
export declare function cloneStructCtorDef<CtorDef extends StructCtorDef>(ctorDef: Readonly<CtorDef>): CtorDef;
export declare function cloneStructDef<SDef extends StructDefinition>(def: Readonly<SDef>): SDef;
export declare const int: [PrimType.Int];
export declare const bs: [PrimType.BS];
export declare const str: [PrimType.Str];
export declare const unit: [PrimType.Unit];
export declare const bool: [PrimType.Bool];
export declare const data: [PrimType.Data];
export declare const list: <T extends GenericTermType>(ofElem: T) => [PrimType.List, T];
export declare const pair: <FstT extends GenericTermType, SndT extends GenericTermType>(fst: FstT, snd: SndT) => [PrimType.Pair, FstT, SndT];
export declare const _pair: <FstT extends GenericTermType, SndT extends GenericTermType>(fst: FstT, snd: SndT) => [PrimType.Pair, FstT, SndT];
export declare const map: <FstT extends GenericTermType, SndT extends GenericTermType>(fst: FstT, snd: SndT) => [PrimType.List, [PrimType.Pair, FstT, SndT]];
export declare const lam: <InT extends GenericTermType, OutT extends GenericTermType>(input: InT, output: OutT) => LamT<InT, OutT>;
export declare const fn: <InsTs extends [GenericTermType, ...GenericTermType[]], OutT extends GenericTermType>(inputs: InsTs, output: OutT) => FnT<InsTs, OutT>;
export declare const delayed: <T extends GenericTermType>(toDelay: T) => [PrimType.Delayed, T];
export declare const struct: <GSDef extends GenericStructDefinition, SMethods extends Methods>(def: GSDef, methods?: SMethods | undefined) => StructT<GSDef, SMethods>;
export declare function alias<T extends AliasT<TermType>>(toAlias: T): T;
export declare function alias<T extends GenericTermType, AMethods extends Methods>(toAlias: T): [PrimType.Alias, T, {}];
export declare function alias<T extends GenericTermType, AMethods extends Methods>(toAlias: T, methods: AMethods): [PrimType.Alias, T, AMethods];
export declare function asData(someT: [PrimType.Data]): [PrimType.Data];
export declare function asData<T extends StructT<GenericStructDefinition>>(someT: T): T;
export declare function asData<T extends GenericTermType>(someT: T): [PrimType.AsData, T];
export type TermTypeParameter = symbol;
export type TyParam = TermTypeParameter;
export type GenericStructCtorDef = {
    [field: string | number]: GenericTermType;
};
export type GenericStructDefinition = {
    [constructor: string]: StructCtorDef;
};
export declare const tyVar: (description?: any) => [TyParam];
export type GenericTermType = TermType | [TyParam] | [NonStructTag, ...GenericTermType[]] | [PrimType.Struct, GenericStructDefinition, Methods] | [PrimType.Alias, GenericTermType, Methods];
export {};
