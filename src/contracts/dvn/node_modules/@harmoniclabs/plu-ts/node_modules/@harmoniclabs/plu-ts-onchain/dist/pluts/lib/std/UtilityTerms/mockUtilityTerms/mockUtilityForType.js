"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockPAliasMethods = exports.mockUtilityForType = void 0;
var isTaggedAsAlias_1 = require("../../../../type_system/kinds/isTaggedAsAlias.js");
var isWellFormedType_1 = require("../../../../type_system/kinds/isWellFormedType.js");
var typeExtends_1 = require("../../../../type_system/typeExtends.js");
var types_1 = require("../../../../type_system/types.js");
var unwrapAlias_1 = require("../../../../type_system/tyArgs/unwrapAlias.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var minimal_1 = require("../../../punsafeConvertType/minimal.js");
var utils_1 = require("../../../../type_system/utils.js");
var mockUserMethods_1 = require("./mockUserMethods.js");
var mockPBoolMethods_1 = require("./mockPBoolMethods.js");
var mockPapp_1 = require("./mockPapp.js");
var mockPByteStringMethods_1 = require("./mockPByteStringMethods.js");
var mockPIntMethods_1 = require("./mockPIntMethods.js");
var mockPListMethods_1 = require("./mockPListMethods.js");
var mockPPairMethods_1 = require("./mockPPairMethods.js");
var mockPStringMethods_1 = require("./mockPStringMethods.js");
var mockPStructMethods_1 = require("./mockPStructMethods.js");
/**
 * like `addUtilityForType` but it doesn't add real terms;
 *
 * the generated terms are not intended to end in the compilation result
 * rather are useful to add the expected properties to the terms and their types
 *
 * `mockUtilityForType` is requires less work and less dependecies than `addUtilityForType`
 */
function mockUtilityForType(t) {
    if ((0, isTaggedAsAlias_1.isTaggedAsAlias)(t)) {
        return mockPAliasMethods;
    }
    ;
    if ((0, typeExtends_1.typeExtends)(t, types_1.bool))
        return mockPBoolMethods_1.mockPBoolMethods;
    if ((0, typeExtends_1.typeExtends)(t, types_1.bs))
        return mockPByteStringMethods_1.mockPByteStringMethods;
    if ((0, typeExtends_1.typeExtends)(t, types_1.int))
        return mockPIntMethods_1.mockPIntMethods;
    if ((0, typeExtends_1.typeExtends)(t, (0, types_1.list)((0, types_1.tyVar)())))
        return mockPListMethods_1.mockPListMethods;
    if ((0, typeExtends_1.typeExtends)(t, (0, types_1.pair)((0, types_1.tyVar)(), (0, types_1.tyVar)())))
        return mockPPairMethods_1.mockPPairMethods;
    if ((0, typeExtends_1.typeExtends)(t, types_1.str))
        return mockPStringMethods_1.mockPStringMethods;
    if ((0, typeExtends_1.typeExtends)(t, (0, types_1.lam)((0, types_1.tyVar)(), (0, types_1.tyVar)()))) {
        return (function (term) { return (0, obj_utils_1.defineNonDeletableNormalProperty)(term, "$", function (input) {
            return (0, mockPapp_1.mockPapp)(term, input);
        }); });
    }
    if ((0, isWellFormedType_1.isStructType)(t)) {
        return mockPStructMethods_1.mockPStructMethods;
    }
    // no utility
    return (function (x) { return x; });
}
exports.mockUtilityForType = mockUtilityForType;
// `mockPAliasMethod` is (necessarily) mutually recursive with `mockUtilityForType`
// so it is defined in this file instead of "./UtilityTerms/TermAlias.ts"
function mockPAliasMethods(aliasTerm) {
    var originalType = aliasTerm.type;
    if (originalType[0] !== "alias" /* PrimType.Alias */) {
        console.error(originalType);
        try {
            console.error((0, utils_1.termTypeToString)(originalType));
        }
        catch (_a) { }
        throw new Error("mockPAliasMethods used on non-alias type");
    }
    var aliasedType = (0, unwrapAlias_1.unwrapAlias)(originalType);
    aliasTerm = mockUtilityForType(aliasedType)(aliasTerm);
    aliasTerm = (0, minimal_1._punsafeConvertType)(aliasTerm, originalType);
    aliasTerm = (0, mockUserMethods_1.mockUserMethods)(aliasTerm, aliasTerm.type[2]);
    return aliasTerm;
}
exports.mockPAliasMethods = mockPAliasMethods;
