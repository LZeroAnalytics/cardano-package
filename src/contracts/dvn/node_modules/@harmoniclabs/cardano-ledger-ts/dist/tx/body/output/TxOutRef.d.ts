import { ToCbor, CborString, CborObj, CanBeCborString, SubCborRef } from "@harmoniclabs/cbor";
import { ToData, DataConstr } from "@harmoniclabs/plutus-data";
import { Hash32 } from "../../../hashes/index.js";
import { ToJson } from "../../../utils/ToJson.js";
import { ToDataVersion } from "../../../toData/defaultToDataVersion.js";
export type TxOutRefStr = `${string}#${number}`;
export interface ITxOutRef {
    id: string | Hash32;
    index: number;
}
export declare function isITxOutRef(stuff: any): stuff is ITxOutRef;
export declare function eqITxOutRef(a: ITxOutRef, b: ITxOutRef): boolean;
export declare function ITxOutRefToStr(iRef: ITxOutRef): TxOutRefStr;
export type UTxORefJson = {
    id: string;
    index: number;
};
export declare class TxOutRef implements ITxOutRef, ToData, ToCbor, ToJson {
    readonly subCborRef?: SubCborRef | undefined;
    readonly id: Hash32;
    readonly index: number;
    constructor({ id, index }: ITxOutRef, subCborRef?: SubCborRef | undefined);
    toString(): TxOutRefStr;
    static fromString(str: string): TxOutRef;
    toData(version?: ToDataVersion): DataConstr;
    toCbor(): CborString;
    toCborObj(): CborObj;
    static fromCbor(cStr: CanBeCborString): TxOutRef;
    static fromCborObj(cObj: CborObj): TxOutRef;
    toJSON(): UTxORefJson;
    toJson(): UTxORefJson;
    static get fake(): TxOutRef;
    static eq(a: ITxOutRef, b: ITxOutRef): boolean;
    eq(other: ITxOutRef): boolean;
    static sort(a: ITxOutRef, b: ITxOutRef): number;
}
