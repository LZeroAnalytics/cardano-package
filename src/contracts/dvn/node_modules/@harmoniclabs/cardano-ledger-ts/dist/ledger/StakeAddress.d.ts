import { NetworkT } from "../ledger/Network.js";
import { StakeCredentials, StakeValidatorHash } from "../credentials/StakeCredentials.js";
import { StakeKeyHash } from "../credentials/StakeKeyHash.js";
import { Hash28 } from "../hashes/Hash28/Hash28.js";
import { CredentialType } from "../credentials/index.js";
import { byte } from "@harmoniclabs/crypto";
import { Credential } from "../credentials/index.js";
import { CanBeCborString, CborObj, SubCborRef } from "@harmoniclabs/cbor";
export type StakeAddressBech32 = `stake1${string}` | `stake_test1${string}`;
export type StakeAddressType = "stakeKey" | "script";
export type StakeAddressCredentials<T extends StakeAddressType> = T extends "stakeKey" ? StakeKeyHash : StakeValidatorHash;
export declare class StakeAddress<T extends StakeAddressType = StakeAddressType> {
    readonly subCborRef?: SubCborRef | undefined;
    readonly network: NetworkT;
    readonly type: T;
    readonly credentials: StakeAddressCredentials<T>;
    constructor(network: NetworkT, credentials: Hash28, type?: T, subCborRef?: SubCborRef | undefined);
    clone(): StakeAddress<T>;
    toString(): StakeAddressBech32;
    static fromString(str: string): StakeAddress;
    static fromString<T extends StakeAddressType = StakeAddressType>(str: string, type: T): StakeAddress<T>;
    toBytes(): Uint8Array;
    static fromBytes(bs: byte[] | string | Uint8Array, subCborRef?: SubCborRef, netwok?: NetworkT, type?: StakeAddressType): StakeAddress;
    toCborObj(): CborObj;
    static fromCbor(cStr: CanBeCborString): StakeAddress;
    static fromCborObj(cObj: CborObj): StakeAddress;
    toCredential(): Credential<CredentialType>;
    toStakeCredentials(): StakeCredentials;
}
