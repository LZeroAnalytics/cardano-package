"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakeAddress = void 0;
var StakeCredentials_1 = require("../credentials/StakeCredentials.js");
var StakeKeyHash_1 = require("../credentials/StakeKeyHash.js");
var Hash28_1 = require("../hashes/Hash28/Hash28.js");
var credentials_1 = require("../credentials/index.js");
var crypto_1 = require("@harmoniclabs/crypto");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../utils/assert.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var credentials_2 = require("../credentials/index.js");
var cbor_1 = require("@harmoniclabs/cbor");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
var StakeAddress = /** @class */ (function () {
    function StakeAddress(network, credentials, type, subCborRef) {
        this.subCborRef = subCborRef;
        var t = type === undefined ?
            (credentials instanceof StakeCredentials_1.StakeValidatorHash ? "script" : "stakeKey")
            : type;
        (0, assert_1.assert)(t === "script" || t === "stakeKey", "invalid address type");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "type", type);
        (0, assert_1.assert)(network === "mainnet" || network === "testnet", "invalid network");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "network", network);
        (0, assert_1.assert)(credentials instanceof Hash28_1.Hash28 &&
            ((t === "stakeKey" && !(credentials instanceof StakeCredentials_1.StakeValidatorHash)) ||
                (t === "script" && !(credentials instanceof StakeKeyHash_1.StakeKeyHash))), "invalid stake credentials");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "credentials", t === "stakeKey" ? new StakeKeyHash_1.StakeKeyHash(credentials) : new StakeCredentials_1.StakeValidatorHash(credentials));
    }
    StakeAddress.prototype.clone = function () {
        return new StakeAddress(this.network, this.credentials, this.type);
    };
    StakeAddress.prototype.toString = function () {
        return (0, crypto_1.encodeBech32)(this.network === "mainnet" ? "stake" : "stake_test", this.credentials.toBuffer());
    };
    StakeAddress.fromString = function (str, type) {
        if (type === void 0) { type = "stakeKey"; }
        var _a = __read((0, crypto_1.decodeBech32)(str), 2), hrp = _a[0], creds = _a[1];
        if (hrp !== "stake" && hrp !== "stake_test")
            throw new Error("invalid stake address string");
        return StakeAddress.fromBytes(creds, undefined, hrp === "stake" ? "mainnet" : "testnet", type);
    };
    StakeAddress.prototype.toBytes = function () {
        return this.credentials.toBuffer();
    };
    StakeAddress.fromBytes = function (bs, subCborRef, netwok, type) {
        if (netwok === void 0) { netwok = "mainnet"; }
        if (type === void 0) { type = "stakeKey"; }
        bs = Uint8Array.from(typeof bs === "string" ? (0, uint8array_utils_1.fromHex)(bs) : bs);
        if (bs.length === 29) {
            var header = bs[0];
            bs = bs.slice(1);
            type = Boolean(header && 16) ? "script" : "stakeKey";
            netwok = Boolean(header & 15) ? "mainnet" : "testnet";
        }
        return new StakeAddress(netwok, bs.length === 28 ? new Hash28_1.Hash28(bs) : new credentials_1.PublicKey(bs).hash, type, subCborRef);
    };
    StakeAddress.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        return new cbor_1.CborBytes(this.toBytes());
    };
    StakeAddress.fromCbor = function (cStr) {
        return StakeAddress.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr), { keepRef: true }));
    };
    StakeAddress.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR format for \"Hash\"");
        return StakeAddress.fromBytes(cObj.bytes, (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    StakeAddress.prototype.toCredential = function () {
        return new credentials_2.Credential(this.type === "script" ? credentials_1.CredentialType.Script : credentials_1.CredentialType.KeyHash, new Hash28_1.Hash28(this.credentials));
    };
    StakeAddress.prototype.toStakeCredentials = function () {
        return new StakeCredentials_1.StakeCredentials(this.type === "script" ? StakeCredentials_1.StakeCredentialsType.Script : StakeCredentials_1.StakeCredentialsType.KeyHash, new Hash28_1.Hash28(this.credentials), undefined);
    };
    return StakeAddress;
}());
exports.StakeAddress = StakeAddress;
