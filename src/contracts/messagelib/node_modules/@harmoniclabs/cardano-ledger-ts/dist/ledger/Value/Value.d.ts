import { ToCbor, CborString, CborObj, CanBeCborString, SubCborRef } from "@harmoniclabs/cbor";
import { ToData, DataMap, DataB, DataI } from "@harmoniclabs/plutus-data";
import { Hash28 } from "../../hashes/index.js";
import { CanBeUInteger } from "../../utils/ints.js";
import { IValue, IValueAsset, ValueJson, NormalizedIValuePolicyEntry, IValueAssetBI, NormalizedIValueAdaEntry, NormalizedIValue } from "./IValue.js";
import { ToDataVersion } from "../../toData/defaultToDataVersion.js";
export type ValueUnitEntry = {
    unit: string;
    quantity: bigint | number | string;
};
export type ValueUnits = ValueUnitEntry[];
export type ValueUnitEntryBI = {
    unit: string;
    quantity: bigint;
};
export type ValueUnitsBI = ValueUnitEntryBI[];
export declare class Value implements ToCbor, ToData {
    readonly subCborRef?: SubCborRef | undefined;
    readonly map: NormalizedIValue;
    [Symbol.iterator](): Generator<{
        policy: string;
        assets: IValueAssetBI[];
    }, void, unknown>;
    constructor(map: IValue, subCborRef?: SubCborRef | undefined);
    readonly lovelaces: bigint;
    get(policy: Hash28 | Uint8Array | string, assetName: Uint8Array): bigint;
    toUnits(): ValueUnitsBI;
    static fromUnits(units: ValueUnits): Value;
    static get zero(): Value;
    static isZero(v: Value): boolean;
    static isPositive(v: Value): boolean;
    static isAdaOnly(v: Value): boolean;
    static lovelaceEntry(n: CanBeUInteger): NormalizedIValueAdaEntry;
    static lovelaces(n: number | bigint): Value;
    static assetEntry(name: Uint8Array, qty: number | bigint): IValueAssetBI;
    static singleAssetEntry(policy: Hash28, name: Uint8Array, qty: number | bigint): NormalizedIValuePolicyEntry;
    static singleAsset(policy: Hash28, name: Uint8Array, qty: number | bigint): Value;
    static entry(policy: Hash28, assets: IValueAsset[]): NormalizedIValuePolicyEntry;
    static add(a: Value, b: Value): Value;
    static sub(a: Value, b: Value): Value;
    clone(): Value;
    toData(version?: ToDataVersion): DataMap<DataB, DataMap<DataB, DataI>>;
    toCbor(): CborString;
    toCborObj(): CborObj;
    static fromCbor(cStr: CanBeCborString): Value;
    static fromCborObj(cObj: CborObj): Value;
    toJSON(): ValueJson;
    toJson(): ValueJson;
    /**
     * cardano-cli format
     */
    toString(includeLovelaces?: boolean): string;
}
