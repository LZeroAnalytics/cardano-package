"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Credential = exports.CredentialType = exports.ValidatorHash = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var Hash28_1 = require("../hashes/Hash28/Hash28.js");
var PubKeyHash_1 = require("./PubKeyHash.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../utils/assert.js");
var getSubCborRef_1 = require("../utils/getSubCborRef.js");
var ValidatorHash = /** @class */ (function (_super) {
    __extends(ValidatorHash, _super);
    function ValidatorHash() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ValidatorHash;
}(Hash28_1.Hash28));
exports.ValidatorHash = ValidatorHash;
var CredentialType;
(function (CredentialType) {
    CredentialType[CredentialType["KeyHash"] = 0] = "KeyHash";
    CredentialType[CredentialType["Script"] = 1] = "Script";
})(CredentialType = exports.CredentialType || (exports.CredentialType = {}));
;
Object.freeze(CredentialType);
var Credential = /** @class */ (function () {
    function Credential(type, hash, subCborRef) {
        this.subCborRef = subCborRef;
        (0, assert_1.assert)((0, Hash28_1.canBeHash28)(hash), "can't construct 'Credential'; hash must be instance of an 'Hash28'");
        (0, assert_1.assert)(type === CredentialType.KeyHash || type === CredentialType.Script, "can't construct 'Credential'; specified type is nor 'key hash' nor 'script'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "type", type);
        (0, obj_utils_1.defineReadOnlyProperty)(this, "hash", type === CredentialType.KeyHash ?
            (hash instanceof PubKeyHash_1.PubKeyHash ? hash : new PubKeyHash_1.PubKeyHash(new Hash28_1.Hash28(hash).toBuffer())) :
            (hash instanceof ValidatorHash ? hash : new ValidatorHash(new Hash28_1.Hash28(hash).toBuffer())));
    }
    Credential.prototype.clone = function () {
        return new Credential(this.type, this.hash.clone());
    };
    Object.defineProperty(Credential, "fake", {
        get: function () {
            return new Credential(CredentialType.KeyHash, new Hash28_1.Hash28("ff".repeat(28)));
        },
        enumerable: false,
        configurable: true
    });
    Credential.prototype.toData = function (_v) {
        return new plutus_data_1.DataConstr(// PCredential
        this.type, [new plutus_data_1.DataB(this.hash.toBuffer())]);
    };
    Credential.fromData = function (data) {
        if (!(data instanceof plutus_data_1.DataConstr))
            throw new Error("invalid data for credential");
        var tag = data.constr;
        var hash = data.fields[0];
        if (!(hash instanceof plutus_data_1.DataB))
            throw new Error("invalid data for credential");
        return new Credential(tag <= 0 ? CredentialType.KeyHash : CredentialType.Script, new Hash28_1.Hash28(hash.bytes.toBuffer()));
    };
    /** @deprecated use `keyHash` instead */
    Credential.pubKey = function (hash) {
        return Credential.keyHash(hash);
    };
    Credential.keyHash = function (hash) {
        return new Credential(CredentialType.KeyHash, hash instanceof PubKeyHash_1.PubKeyHash ?
            hash :
            new PubKeyHash_1.PubKeyHash(hash));
    };
    Credential.script = function (hash) {
        return new Credential(CredentialType.Script, hash instanceof ValidatorHash ?
            hash :
            new ValidatorHash(hash));
    };
    Credential.prototype.toCbor = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return new cbor_1.CborString(this.subCborRef.toBuffer());
        }
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    Credential.prototype.toCborObj = function () {
        if (this.subCborRef instanceof cbor_1.SubCborRef) {
            // TODO: validate cbor structure
            // we assume correctness here
            return cbor_1.Cbor.parse(this.subCborRef.toBuffer());
        }
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.type),
            this.hash.toCborObj()
        ]);
    };
    Credential.fromCbor = function (cStr) {
        return Credential.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cStr), { keepRef: true }));
    };
    Credential.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray &&
            cObj.array[0] instanceof cbor_1.CborUInt &&
            (cObj.array[0].num === BigInt(0) || cObj.array[0].num === BigInt(1))))
            throw new Error("Invalid CBOR format for \"Credential\"");
        return new Credential(Number(cObj.array[0].num), Hash28_1.Hash28.fromCborObj(cObj.array[1]), (0, getSubCborRef_1.getSubCborRef)(cObj));
    };
    Credential.prototype.toJSON = function () { return this.toJson(); };
    Credential.prototype.toJson = function () {
        return {
            credentialType: this.type === CredentialType.Script ? "Script" : "KeyHash",
            hash: this.hash.toString()
        };
    };
    return Credential;
}());
exports.Credential = Credential;
