"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxBuilderRunner = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var txBuild_1 = require("../../txBuild/index.js");
var cardano_ledger_ts_1 = require("@harmoniclabs/cardano-ledger-ts");
var ints_1 = require("../../utils/ints.js");
var CanResolveToUTxO_1 = require("../CanResolveToUTxO/CanResolveToUTxO.js");
var jsonToMetadata_1 = require("./jsonToMetadata.js");
var GenesisInfos_1 = require("../GenesisInfos.js");
var crypto_1 = require("@harmoniclabs/crypto");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var bytestring_1 = require("@harmoniclabs/bytestring");
var CanBeData_1 = require("../../utils/CanBeData.js");
var CanBePoolKeyHash_1 = require("./CanBePoolKeyHash.js");
var CanBeStakeCreds_1 = require("./CanBeStakeCreds.js");
var forceAddr_1 = require("./forceAddr.js");
var ITxBuildVotingProcedure_1 = require("../../txBuild/ITxBuildVotingProcedure.js");
function cloneTask(task) {
    if (task.kind === 0 /* TxBuilderTaskKind.ResolveUTxO */ || task.kind === 1 /* TxBuilderTaskKind.ResolveTxIn */) {
        var _a = task, kind = _a.kind, arg = _a.arg, onResolved = _a.onResolved;
        return {
            kind: kind,
            arg: (0, CanResolveToUTxO_1.cloneCanResolveToUTxO)(arg),
            onResolved: onResolved
        };
    }
    return {
        kind: task.kind,
        getPromise: task.getPromise
    };
}
var readonlyValueDescriptor = Object.freeze({
    writable: false,
    enumerable: true,
    configurable: false
});
var _datumsCache = {};
var _datumsHashes = [];
var _MAX_DATUMS_CACHE_SIZE = 20;
function _saveResolvedDatum(datum, hash) {
    var theData = (0, plutus_data_1.cloneData)(datum);
    var actualHash = (0, uint8array_utils_1.toHex)(new Uint8Array((0, crypto_1.sha2_256)((0, plutus_data_1.dataToCbor)(datum).toBuffer())));
    var actualHashIdx = _datumsHashes.lastIndexOf(actualHash);
    if (actualHashIdx < 0) {
        _datumsHashes.push(actualHash);
        _datumsCache[actualHash] = theData;
    }
    if (hash) {
        var hashIdx = _datumsHashes.lastIndexOf(hash);
        if (hashIdx < 0) {
            _datumsHashes.push(hash);
            _datumsCache[hash] = theData;
        }
    }
    while (_datumsHashes.length > _MAX_DATUMS_CACHE_SIZE) {
        var h = _datumsHashes.shift();
        delete _datumsCache[h];
    }
}
function _getResolvedDatum(hash) {
    // no need to `cloneData` because this datum is used only internally
    return _datumsCache[hash];
}
var TxBuilderRunner = /** @class */ (function () {
    function TxBuilderRunner(txBuilder, provider) {
        if (!(0, obj_utils_1.isObject)(provider))
            provider = {};
        var self = this;
        var tasks = [];
        var buildArgs = {};
        var scripts = [];
        var scriptHashesStr = [];
        var refUtxos = [];
        var _collateralAmount = 5000000;
        var _setCollateralTask = undefined;
        (0, obj_utils_1.defineReadOnlyProperty)(this, "reset", function () {
            tasks.length = 0;
            // steps.length = 0;
            buildArgs = {};
            scripts.length = 0;
            scriptHashesStr.length = 0;
            refUtxos.length = 0;
            _collateralAmount = 5000000;
            _setCollateralTask = undefined;
            return self;
        });
        function _addRefUtxo(u) {
            if ((0, cardano_ledger_ts_1.isIUTxO)(u)) {
                refUtxos.push(new cardano_ledger_ts_1.UTxO(u));
                return;
            }
            // add before other resolveUtxOs (`unshift`)
            tasks.unshift({
                kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                arg: u,
                onResolved: function (utxo) { return refUtxos.push(utxo); }
            });
        }
        function _addAviableScript(scrpt) {
            var hStr = scrpt.hash.toString();
            if (!scriptHashesStr.includes(hStr)) {
                scripts.push(scrpt);
                scriptHashesStr.push(hStr);
            }
            return self;
        }
        Object.defineProperties(this, {
            tasks: {
                get: function () { return tasks.map(cloneTask); },
                set: function () { },
                enumerable: true,
                configurable: false
            },
            // steps: {
            //     get: () => steps.map( cloneStep ),
            //     set: () => {},
            //     enumerable: true,
            //     configurable: false
            // },
            buildArgs: {
                get: function () { return (0, txBuild_1.normalizeITxBuildArgs)(buildArgs); },
                set: function () { },
                enumerable: true,
                configurable: false
            }
        });
        function _addRequiredSignerKey(key) {
            key = new cardano_ledger_ts_1.PubKeyHash(key);
            if (buildArgs.requiredSigners === undefined) {
                buildArgs.requiredSigners = [key];
                return self;
            }
            if (!buildArgs.requiredSigners.some(function (sig) { return sig.toString() === key.toString(); })) {
                buildArgs.requiredSigners.push(key);
            }
            return self;
        }
        function _addRequiredSigner(signer) {
            if (typeof signer === "string") {
                if (signer.startsWith("addr")) {
                    signer = cardano_ledger_ts_1.Address.fromString(signer);
                }
                else if (signer.startsWith("stake")) {
                    signer = cardano_ledger_ts_1.StakeAddress.fromString(signer);
                }
                else
                    throw new Error("invalid string passed as address: " + signer);
            }
            if (signer instanceof cardano_ledger_ts_1.Address) {
                void _addRequiredSignerKey(signer.paymentCreds.hash);
                if (signer.stakeCreds !== undefined &&
                    !Array.isArray(signer.stakeCreds.hash)) {
                    void _addRequiredSignerKey(signer.stakeCreds.hash);
                }
                return self;
            }
            if (signer instanceof cardano_ledger_ts_1.StakeAddress) {
                return _addRequiredSignerKey(signer.credentials);
            }
            throw new Error("invalid required signer");
        }
        function _attachMemo(memo) {
            buildArgs.memo = memo;
            return self;
        }
        function _attachMetadata(label, metadatum) {
            var _a;
            var _b;
            var meta = (_b = buildArgs.metadata) === null || _b === void 0 ? void 0 : _b.metadata;
            var labelStr = (0, ints_1.forceBigUInt)(label).toString();
            buildArgs.metadata = new cardano_ledger_ts_1.TxMetadata(__assign(__assign({}, meta), (_a = {}, _a[labelStr] = metadatum, _a)));
            return self;
        }
        function _attachMetadataJson(label, json) {
            return _attachMetadata(label, (0, jsonToMetadata_1.jsonToMetadata)(json));
        }
        function _attachMetadataJsonWithConversion(label, json) {
            return _attachMetadata(label, (0, jsonToMetadata_1.jsonToMetadata)(json, true));
        }
        function _setChangeAddress(addr) {
            buildArgs.changeAddress = addr;
            return self;
        }
        function _validFromSlot(slot) {
            tasks = tasks.filter(function (_a) {
                var kind = _a.kind;
                return kind !== 2 /* TxBuilderTaskKind.ValidFromPOSIX */;
            });
            buildArgs.invalidBefore = (0, ints_1.forceBigUInt)(slot);
            return self;
        }
        function _validFromPOSIX(POSIX) {
            var _this = this;
            tasks.push({
                kind: 2 /* TxBuilderTaskKind.ValidFromPOSIX */,
                getPromise: function () { return __awaiter(_this, void 0, void 0, function () {
                    var _a, _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                if (!!(0, GenesisInfos_1.isGenesisInfos)(txBuilder.genesisInfos)) return [3 /*break*/, 2];
                                if (typeof provider.getGenesisInfos !== "function") {
                                    throw new Error("validFromPOSIX requires either a tx builder with genesis infos or a provider that can fetch them; but none is present");
                                }
                                _b = (_a = txBuilder).setGenesisInfos;
                                return [4 /*yield*/, provider.getGenesisInfos()];
                            case 1:
                                _b.apply(_a, [_c.sent()]);
                                _c.label = 2;
                            case 2:
                                buildArgs.invalidBefore = (0, ints_1.forceBigUInt)(txBuilder.posixToSlot(POSIX));
                                return [2 /*return*/];
                        }
                    });
                }); }
            });
            return self;
        }
        function _validToSlot(slot) {
            tasks = tasks.filter(function (_a) {
                var kind = _a.kind;
                return kind !== 3 /* TxBuilderTaskKind.ValidToPOSIX */;
            });
            buildArgs.invalidAfter = (0, ints_1.forceBigUInt)(slot);
            return self;
        }
        function _validToPOSIX(POSIX) {
            var _this = this;
            tasks.push({
                kind: 3 /* TxBuilderTaskKind.ValidToPOSIX */,
                getPromise: function () { return __awaiter(_this, void 0, void 0, function () {
                    var _a, _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                if (!!(0, GenesisInfos_1.isGenesisInfos)(txBuilder.genesisInfos)) return [3 /*break*/, 2];
                                if (typeof provider.getGenesisInfos !== "function") {
                                    throw new Error("validToPOSIX requires either a tx builder with genesis infos or a provider that can fetch them; but none is present");
                                }
                                _b = (_a = txBuilder).setGenesisInfos;
                                return [4 /*yield*/, provider.getGenesisInfos()];
                            case 1:
                                _b.apply(_a, [_c.sent()]);
                                _c.label = 2;
                            case 2:
                                buildArgs.invalidAfter = (0, ints_1.forceBigUInt)(txBuilder.posixToSlot(POSIX));
                                return [2 /*return*/];
                        }
                    });
                }); }
            });
            return self;
        }
        function _referenceUTxOs(utxos) {
            var e_1, _a;
            if (utxos.length <= 0)
                return self;
            try {
                for (var utxos_1 = __values(utxos), utxos_1_1 = utxos_1.next(); !utxos_1_1.done; utxos_1_1 = utxos_1.next()) {
                    var u = utxos_1_1.value;
                    _addRefUtxo(u);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (utxos_1_1 && !utxos_1_1.done && (_a = utxos_1.return)) _a.call(utxos_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return self;
        }
        function _addCertificate(cert, script) {
            if (!(buildArgs.certificates)) {
                buildArgs.certificates = [{
                        cert: cert,
                        script: script
                    }];
                return;
            }
            else {
                buildArgs.certificates.push({
                    cert: cert,
                    script: script
                });
            }
        }
        function _addWithdraw(withdrawal, script) {
            if (!(buildArgs.withdrawals)) {
                buildArgs.withdrawals = [{
                        withdrawal: withdrawal,
                        script: script
                    }];
                return;
            }
            else {
                buildArgs.withdrawals.push({
                    withdrawal: withdrawal,
                    script: script
                });
            }
        }
        function _tryGetRefScript(scriptHashStr) {
            var theRef = refUtxos.find(function (ref) { var _a, _b; return ((_b = (_a = ref.resolved.refScript) === null || _a === void 0 ? void 0 : _a.hash) === null || _b === void 0 ? void 0 : _b.toString()) === scriptHashStr; });
            if (theRef === undefined)
                return undefined;
            return theRef;
        }
        function _tryGetScript(scriptHashStr) {
            var theScript = scripts.find(function (scr) { return scr.hash.toString() === scriptHashStr; });
            if (theScript === undefined)
                return undefined;
            return theScript;
        }
        function _tryGetRefStakeScript(stakeCreds) {
            var scriptHash = stakeCreds.hash;
            if (Array.isArray(scriptHash))
                return undefined;
            return _tryGetRefScript(scriptHash.toString());
        }
        function _tryGetStakeScript(stakeCreds) {
            var scriptHash = stakeCreds.hash;
            if (Array.isArray(scriptHash))
                return undefined;
            return _tryGetScript(scriptHash.toString());
        }
        function _ensureStakeScript(stakeCreds, script_or_ref, redeemer, script) {
            if (stakeCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                if (redeemer === undefined) {
                    throw new Error("stake credenials are \"script\" but \"redeemer\" is missing");
                }
                if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                    throw new Error("unresolved TxOutRef used as ref UTxO");
                }
                if (!(script)) {
                    script_or_ref = _tryGetRefStakeScript(stakeCreds);
                    if (script_or_ref === undefined) {
                        script_or_ref = _tryGetStakeScript(stakeCreds);
                    }
                    if (script_or_ref === undefined) {
                        throw new Error("missing script with hash: " + stakeCreds.hash);
                    }
                    if ((0, cardano_ledger_ts_1.isIUTxO)(script_or_ref)) {
                        script = {
                            ref: new cardano_ledger_ts_1.UTxO(script_or_ref),
                            redeemer: redeemer
                        };
                    }
                    else {
                        script = {
                            inline: script_or_ref,
                            redeemer: redeemer
                        };
                    }
                }
            }
            return script;
        }
        function _delegateTo(delegator, poolId, redeemer, script_or_ref) {
            var _this = this;
            var stakeCreds = (0, CanBeStakeCreds_1.forceStakeCreds)(delegator);
            var poolKeyHash = (0, CanBePoolKeyHash_1.forcePoolKeyHash)(poolId);
            var script = undefined;
            if (delegator instanceof cardano_ledger_ts_1.Script &&
                (script_or_ref === undefined || script_or_ref instanceof cardano_ledger_ts_1.Script)) {
                script_or_ref = delegator;
            }
            if (stakeCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                if (redeemer === undefined) {
                    throw new Error("in \"delegateTo\"; stake credenials are \"script\" but \"redeemer\" is missing");
                }
                if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                    _addRefUtxo;
                    tasks.unshift({
                        kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                        arg: script_or_ref,
                        onResolved: function (utxo) {
                            script_or_ref = utxo;
                            script = {
                                ref: utxo,
                                redeemer: redeemer
                            };
                        }
                    });
                }
            }
            tasks.push({
                kind: 4 /* TxBuilderTaskKind.DelegateTo */,
                getPromise: function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        script = _ensureStakeScript(stakeCreds, script_or_ref, redeemer, script);
                        _addCertificate(new cardano_ledger_ts_1.CertStakeDelegation({
                            stakeCredential: stakeCreds,
                            poolKeyHash: poolKeyHash
                        }), script);
                        return [2 /*return*/];
                    });
                }); }
            });
            return self;
        }
        function _deregisterStake(delegator, redeemer, script_or_ref) {
            var _this = this;
            var stakeCreds = (0, CanBeStakeCreds_1.forceStakeCreds)(delegator);
            var script = undefined;
            if (delegator instanceof cardano_ledger_ts_1.Script &&
                (script_or_ref === undefined || script_or_ref instanceof cardano_ledger_ts_1.Script)) {
                script_or_ref = delegator;
            }
            if (stakeCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                if (redeemer === undefined) {
                    throw new Error("in \"deregisterStake\"; stake credenials are \"script\" but \"redeemer\" is missing");
                }
                if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                    tasks.push({
                        kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                        arg: script_or_ref,
                        onResolved: function (utxo) {
                            script_or_ref = utxo;
                            script = {
                                ref: utxo,
                                redeemer: redeemer
                            };
                        }
                    });
                }
            }
            tasks.push({
                kind: 5 /* TxBuilderTaskKind.DeregisterStake */,
                getPromise: function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        script = _ensureStakeScript(stakeCreds, script_or_ref, redeemer, script);
                        _addCertificate(new cardano_ledger_ts_1.CertStakeDeRegistration({
                            stakeCredential: stakeCreds,
                        }), script);
                        return [2 /*return*/];
                    });
                }); }
            });
            return self;
        }
        function _registerStake(delegator, redeemer, script_or_ref) {
            var _this = this;
            var stakeCreds = (0, CanBeStakeCreds_1.forceStakeCreds)(delegator);
            var script = undefined;
            if (delegator instanceof cardano_ledger_ts_1.Script &&
                (script_or_ref === undefined || script_or_ref instanceof cardano_ledger_ts_1.Script)) {
                script_or_ref = delegator;
            }
            if (stakeCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                if (redeemer === undefined) {
                    throw new Error("in \"registerStake\"; stake credenials are \"script\" but \"redeemer\" is missing");
                }
                if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                    tasks.push({
                        kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                        arg: script_or_ref,
                        onResolved: function (utxo) {
                            script_or_ref = utxo;
                            script = {
                                ref: utxo,
                                redeemer: redeemer
                            };
                        }
                    });
                }
            }
            tasks.push({
                kind: 7 /* TxBuilderTaskKind.RegisterStake */,
                getPromise: function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        script = _ensureStakeScript(stakeCreds, script_or_ref, redeemer, script);
                        _addCertificate(new cardano_ledger_ts_1.CertStakeRegistration({
                            stakeCredential: stakeCreds,
                        }), script);
                        return [2 /*return*/];
                    });
                }); }
            });
            return self;
        }
        function _registerPool(poolParams) {
            _addCertificate(new cardano_ledger_ts_1.CertPoolRegistration({
                poolParams: new cardano_ledger_ts_1.PoolParams(poolParams)
            }));
            return self;
        }
        function _retirePool(poolId, epoch) {
            _addCertificate(new cardano_ledger_ts_1.CertPoolRetirement({
                poolHash: new cardano_ledger_ts_1.PoolKeyHash(poolId),
                epoch: epoch
            }));
            return self;
        }
        function _withdraw(stakeAddress, amount, redeemer, script_or_ref) {
            var _this = this;
            var stakeCreds = (0, CanBeStakeCreds_1.forceStakeCreds)(stakeAddress);
            var script = undefined;
            if (stakeAddress instanceof cardano_ledger_ts_1.Script &&
                (script_or_ref === undefined || script_or_ref instanceof cardano_ledger_ts_1.Script)) {
                script_or_ref = stakeAddress;
            }
            if (stakeCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                if (redeemer === undefined) {
                    throw new Error("in \"withdraw\"; stake credenials are \"script\" but \"redeemer\" is missing");
                }
                if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                    tasks.push({
                        kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                        arg: script_or_ref,
                        onResolved: function (utxo) {
                            script_or_ref = utxo;
                            script = {
                                ref: utxo,
                                redeemer: redeemer
                            };
                        }
                    });
                }
            }
            tasks.push({
                kind: 6 /* TxBuilderTaskKind.Withdraw */,
                getPromise: function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        script = _ensureStakeScript(stakeCreds, script_or_ref, redeemer, script);
                        if (Array.isArray(stakeCreds.hash)) {
                            throw new Error("unexpected pointer stake credentials");
                        }
                        _addWithdraw({
                            rewardAccount: stakeCreds.hash,
                            amount: amount
                        }, script);
                        return [2 /*return*/];
                    });
                }); }
            });
            return self;
        }
        function _pushInput(utxo, redeemer, script_or_ref) {
            var _a, _b, _c;
            var paymentCreds = utxo.resolved.address.paymentCreds;
            if (paymentCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                if (!(0, CanBeData_1.canBeData)(redeemer))
                    throw new Error("script input " + utxo.utxoRef.toString() + " is missing a redeemer");
                else
                    redeemer = (0, CanBeData_1.forceData)(redeemer);
                if ((0, cardano_ledger_ts_1.isIUTxO)(script_or_ref)) {
                    refUtxos.push(new cardano_ledger_ts_1.UTxO(script_or_ref));
                }
                if (script_or_ref instanceof cardano_ledger_ts_1.Script) {
                    _addAviableScript(script_or_ref);
                }
                if (!(0, cardano_ledger_ts_1.isIUTxO)(script_or_ref) || !(script_or_ref instanceof cardano_ledger_ts_1.Script)) {
                    var scriptHash = paymentCreds.hash.toString();
                    script_or_ref = (_a = _tryGetRefScript(scriptHash)) !== null && _a !== void 0 ? _a : _tryGetScript(scriptHash);
                    if (!!(0, cardano_ledger_ts_1.isIUTxO)(script_or_ref) || !(script_or_ref instanceof cardano_ledger_ts_1.Script)) {
                        throw new Error("script input " + utxo.utxoRef.toString() + " is missing the script source");
                    }
                }
                if (!Array.isArray(buildArgs.inputs)) {
                    buildArgs.inputs = [];
                }
                var isInlineDatum = (0, plutus_data_1.isData)(utxo.resolved.datum);
                var datumHashStr = (_c = (_b = utxo.resolved.datum) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : "undefined";
                var datum = bytestring_1.ByteString.isValidHexValue(datumHashStr) &&
                    datumHashStr.length === 64 ?
                    _getResolvedDatum(datumHashStr) : undefined;
                if (!isInlineDatum && !(0, plutus_data_1.isData)(datum))
                    throw new Error("missing datum for script input " + +utxo.utxoRef.toString());
                if ((0, cardano_ledger_ts_1.isIUTxO)(script_or_ref)) {
                    var ref = script_or_ref instanceof cardano_ledger_ts_1.UTxO ? script_or_ref : new cardano_ledger_ts_1.UTxO(script_or_ref);
                    buildArgs.inputs.push({
                        utxo: utxo,
                        referenceScript: {
                            refUtxo: ref,
                            redeemer: redeemer,
                            datum: isInlineDatum ? "inline" : datum
                        }
                    });
                }
                else {
                    buildArgs.inputs.push({
                        utxo: utxo,
                        inputScript: {
                            script: script_or_ref,
                            redeemer: redeemer,
                            datum: isInlineDatum ? "inline" : datum
                        }
                    });
                }
                return;
            }
            // not script
            if (!Array.isArray(buildArgs.inputs)) {
                buildArgs.inputs = [{ utxo: utxo }];
            }
            else {
                buildArgs.inputs.push({ utxo: utxo });
            }
        }
        function _addInput(utxo, redeemer, script_or_ref, datum) {
            var _a;
            if (datum && (0, CanBeData_1.canBeData)(datum)) {
                try {
                    datum = (0, CanBeData_1.forceData)(datum);
                    _saveResolvedDatum(datum);
                }
                catch (_b) { }
            }
            utxo = utxo instanceof cardano_ledger_ts_1.UTxO ? utxo : new cardano_ledger_ts_1.UTxO(utxo);
            var paymentCreds = utxo.resolved.address.paymentCreds;
            if (paymentCreds.type === cardano_ledger_ts_1.CredentialType.Script) {
                var hashStr = paymentCreds.hash.toString();
                if (!(0, cardano_ledger_ts_1.isIUTxO)(script_or_ref))
                    script_or_ref = (_a = _tryGetRefScript(hashStr)) !== null && _a !== void 0 ? _a : script_or_ref;
                if (!script_or_ref)
                    script_or_ref = _tryGetScript(hashStr);
                if (!script_or_ref)
                    throw new Error("missing script for utxo: " + utxo.utxoRef.toString());
                if ((0, cardano_ledger_ts_1.isIUTxO)(script_or_ref))
                    script_or_ref = new cardano_ledger_ts_1.UTxO(script_or_ref);
            }
            _pushInput(utxo, redeemer, script_or_ref);
        }
        function __addInptus(utxos, redeemer, script_or_ref, datum) {
            var e_2, _a;
            // save datum before resolving utxo
            if (datum && (0, CanBeData_1.canBeData)(datum)) {
                try {
                    datum = (0, CanBeData_1.forceData)(datum);
                    _saveResolvedDatum(datum);
                }
                catch (_b) { }
            }
            try {
                for (var utxos_2 = __values(utxos), utxos_2_1 = utxos_2.next(); !utxos_2_1.done; utxos_2_1 = utxos_2.next()) {
                    var _utxo = utxos_2_1.value;
                    tasks.push({
                        kind: 1 /* TxBuilderTaskKind.ResolveTxIn */,
                        arg: _utxo,
                        onResolved: function (txIn) {
                            _addInput(txIn, redeemer, script_or_ref);
                        }
                    });
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (utxos_2_1 && !utxos_2_1.done && (_a = utxos_2.return)) _a.call(utxos_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return self;
        }
        function _addInputs(utxos, redeemer, script_or_ref, datum) {
            datum = datum === "inline" ? undefined : datum;
            if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                // save datum before resolving utxo
                if (datum && (0, CanBeData_1.canBeData)(datum)) {
                    try {
                        datum = (0, CanBeData_1.forceData)(datum);
                        _saveResolvedDatum(datum);
                    }
                    catch (_a) { }
                }
                tasks.push({
                    kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                    arg: script_or_ref,
                    onResolved: function (ref) {
                        __addInptus(utxos, redeemer, ref);
                    }
                });
                return self;
            }
            return __addInptus(utxos, redeemer, script_or_ref, datum);
        }
        function _addSingleInput(utxo, redeemer, script_or_ref, datum) {
            return _addInputs([utxo], redeemer, script_or_ref, datum);
        }
        function _payTo(address, amount, datum, refScript) {
            if (!Array.isArray(buildArgs.outputs)) {
                buildArgs.outputs = [];
            }
            buildArgs.outputs.push({
                address: typeof address === "string" ? cardano_ledger_ts_1.Address.fromString(address) : address,
                value: (0, ints_1.canBeUInteger)(amount) ? cardano_ledger_ts_1.Value.lovelaces(amount) : amount,
                datum: datum !== undefined && (0, CanBeData_1.canBeData)(datum) ? (0, CanBeData_1.forceData)(datum) : undefined,
                refScript: refScript
            });
            return self;
        }
        function _setCollateral(collateral, collateralOutput) {
            _setCollateralTask = {
                kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                arg: collateral,
                onResolved: function (utxo) {
                    if (!cardano_ledger_ts_1.Value.isAdaOnly(utxo.resolved.value) && !(0, cardano_ledger_ts_1.isITxOut)(collateralOutput)) {
                        collateralOutput = {
                            address: utxo.resolved.address,
                            value: cardano_ledger_ts_1.Value.sub(utxo.resolved.value, cardano_ledger_ts_1.Value.lovelaces((0, ints_1.forceBigUInt)(_collateralAmount)))
                        };
                    }
                    buildArgs.collaterals = [utxo];
                    if ((0, cardano_ledger_ts_1.isITxOut)(collateralOutput)) {
                        if (typeof collateralOutput.address === "string")
                            collateralOutput.address = cardano_ledger_ts_1.Address.fromString(collateralOutput.address);
                        buildArgs.collateralReturn = collateralOutput;
                    }
                }
            };
            return self;
        }
        function _setCollateralAmount(amount) {
            if ((0, ints_1.canBeUInteger)(amount))
                _collateralAmount = amount;
            return self;
        }
        function __mintAssets(assets, script_or_ref, redeemer) {
            redeemer = redeemer === undefined ? new plutus_data_1.DataI(0) : (0, CanBeData_1.forceData)(redeemer);
            if (!Array.isArray(buildArgs.mints)) {
                buildArgs.mints = [];
            }
            buildArgs.mints.push({
                value: assets,
                script: (0, cardano_ledger_ts_1.isIUTxO)(script_or_ref) ?
                    {
                        ref: new cardano_ledger_ts_1.UTxO(script_or_ref),
                        // policyId: assets.policy,
                        redeemer: redeemer
                    } : {
                    inline: script_or_ref,
                    // policyId: assets.policy,
                    redeemer: redeemer
                }
            });
            return self;
        }
        function _mintAssets(assets, script_or_ref, redeemer) {
            if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                tasks.push({
                    kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                    arg: script_or_ref,
                    onResolved: function (ref) {
                        __mintAssets(assets, ref, redeemer);
                    }
                });
                return self;
            }
            else
                return __mintAssets(assets, script_or_ref, redeemer);
        }
        function __vote(voter, govActionId, vote, anchor, redeemer, script_or_ref) {
            govActionId = (0, cardano_ledger_ts_1.forceTxOutRef)(govActionId);
            if (!Array.isArray(buildArgs.votingProcedures))
                buildArgs.votingProcedures = [];
            var govActionVote = {
                govActionId: govActionId,
                vote: {
                    vote: vote,
                    anchor: anchor
                },
            };
            var votingProcedure = {
                voter: voter,
                votes: [govActionVote]
            };
            var entry = buildArgs.votingProcedures.find(function (elem) {
                var votingProcedure = (0, cardano_ledger_ts_1.isIVotingProceduresEntry)(elem) ? elem : elem.votingProcedure;
                return (0, ITxBuildVotingProcedure_1.eqIVoter)(voter, votingProcedure.voter);
            });
            if (!entry) {
                buildArgs.votingProcedures.push({
                    votingProcedure: votingProcedure,
                    script: redeemer === undefined ? undefined :
                        (0, cardano_ledger_ts_1.isIUTxO)(script_or_ref) ? {
                            ref: script_or_ref,
                            redeemer: redeemer
                        } : (script_or_ref instanceof cardano_ledger_ts_1.Script ? {
                            inline: script_or_ref,
                            redeemer: redeemer
                        } : undefined)
                });
            }
            else {
                var votingProcedure_1 = (0, cardano_ledger_ts_1.isIVotingProceduresEntry)(entry) ? entry : entry.votingProcedure;
                var govActionEntry = votingProcedure_1.votes.find(function (_a) {
                    var entryGovActionId = _a.govActionId;
                    return (0, cardano_ledger_ts_1.eqITxOutRef)(govActionId, entryGovActionId);
                });
                if (!govActionEntry) {
                    votingProcedure_1.votes.push(govActionVote);
                }
                else {
                    govActionEntry.vote = {
                        vote: vote,
                        anchor: anchor
                    };
                }
            }
            return self;
        }
        function _vote(voter, governanceActionId, vote, anchor, redeemer, script_or_ref) {
            redeemer = redeemer && (0, CanBeData_1.canBeData)(redeemer) ? (0, CanBeData_1.forceData)(redeemer) : undefined;
            if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                tasks.push({
                    kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                    arg: script_or_ref,
                    onResolved: function (ref) {
                        __vote(voter, governanceActionId, vote, anchor, redeemer, ref);
                    }
                });
                return self;
            }
            else
                return __vote(voter, governanceActionId, vote, anchor, redeemer, script_or_ref);
        }
        function _voteDRep(drepKeyHash, governanceActionId, vote, anchor) {
            return _vote({
                kind: cardano_ledger_ts_1.VoterKind.DRepKeyHash,
                hash: drepKeyHash
            }, governanceActionId, vote, anchor);
        }
        function _voteScriptDRep(drepScriptHash, governanceActionId, vote, anchor, redeemer, script_or_ref) {
            return _vote({
                kind: cardano_ledger_ts_1.VoterKind.DRepScript,
                hash: drepScriptHash
            }, governanceActionId, vote, anchor, redeemer, script_or_ref);
        }
        function _voteConstitutionalComittee(memberKeyHash, governanceActionId, vote, anchor) {
            return _vote({
                kind: cardano_ledger_ts_1.VoterKind.ConstitutionalCommitteKeyHash,
                hash: memberKeyHash
            }, governanceActionId, vote, anchor);
        }
        function _voteScriptConstitutionalComittee(memberScriptHash, governanceActionId, vote, anchor, redeemer, script_or_ref) {
            return _vote({
                kind: cardano_ledger_ts_1.VoterKind.ConstitutionalCommitteScript,
                hash: memberScriptHash
            }, governanceActionId, vote, anchor, redeemer, script_or_ref);
        }
        function _voteStakePool(poolId, governanceActionId, vote, anchor) {
            return _vote({
                kind: cardano_ledger_ts_1.VoterKind.StakingPoolKeyHash,
                hash: poolId
            }, governanceActionId, vote, anchor);
        }
        function __propose(proposal, redeemer, script_or_ref) {
            if (!Array.isArray(buildArgs.proposalProcedures))
                buildArgs.proposalProcedures = [];
            buildArgs.proposalProcedures.push({
                proposalProcedure: proposal,
                script: redeemer === undefined ? undefined :
                    (0, cardano_ledger_ts_1.isIUTxO)(script_or_ref) ? {
                        ref: script_or_ref,
                        redeemer: redeemer
                    } : ((script_or_ref instanceof cardano_ledger_ts_1.Script) ? {
                        inline: script_or_ref,
                        redeemer: redeemer
                    } : undefined)
            });
            var _proposalProcedure = buildArgs.proposalProcedures[buildArgs.proposalProcedures.length - 1];
            var govActionRef = (0, cardano_ledger_ts_1.isIProposalProcedure)(_proposalProcedure) ?
                _proposalProcedure.govAction :
                _proposalProcedure.proposalProcedure.govAction;
            if ((govActionRef.govActionType === cardano_ledger_ts_1.GovActionType.ParameterChange ||
                govActionRef.govActionType === cardano_ledger_ts_1.GovActionType.TreasuryWithdrawals) &&
                govActionRef.policyHash === undefined) {
                if ((0, cardano_ledger_ts_1.isIUTxO)(script_or_ref) &&
                    script_or_ref.resolved.refScript instanceof cardano_ledger_ts_1.Script) {
                    govActionRef.policyHash = script_or_ref.resolved.refScript.hash;
                }
                else if (script_or_ref instanceof cardano_ledger_ts_1.Script) {
                    govActionRef.policyHash = script_or_ref.hash;
                }
            }
            return self;
        }
        function _propose(proposal, redeemer, script_or_ref) {
            redeemer = redeemer && (0, CanBeData_1.canBeData)(redeemer) ? (0, CanBeData_1.forceData)(redeemer) : undefined;
            if ((0, CanResolveToUTxO_1.shouldResolveToUTxO)(script_or_ref)) {
                tasks.push({
                    kind: 0 /* TxBuilderTaskKind.ResolveUTxO */,
                    arg: script_or_ref,
                    onResolved: function (ref) {
                        __propose(proposal, redeemer, ref);
                    }
                });
                return self;
            }
            else
                return __propose(proposal, redeemer, script_or_ref);
        }
        function _proposeParametersChanges(changes, procedureInfos, govActionId, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.ParameterChange,
                    protocolParamsUpdate: changes,
                    govActionId: govActionId ? (0, cardano_ledger_ts_1.forceTxOutRef)(govActionId) : undefined,
                    // policyHash // script hash if any specified
                } }), redeemer, script_or_ref);
        }
        function _proposeHardForkInitiation(nextProtocolVersion, procedureInfos, govActionId, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.InitHardFork,
                    protocolVersion: nextProtocolVersion,
                    govActionId: govActionId ? (0, cardano_ledger_ts_1.forceTxOutRef)(govActionId) : undefined,
                } }), redeemer, script_or_ref);
        }
        function _proposeTreasuryWithdrawal(withdrawals, procedureInfos, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.TreasuryWithdrawals,
                    withdrawals: withdrawals,
                    // policyHash // script hash if any specified
                } }), redeemer, script_or_ref);
        }
        function _proposeNoConfidence(procedureInfos, govActionId, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.NoConfidence,
                    govActionId: govActionId ? (0, cardano_ledger_ts_1.forceTxOutRef)(govActionId) : undefined,
                    // policyHash // script hash if any specified
                } }), redeemer, script_or_ref);
        }
        function _proposeComitteeUpdate(toRemove, toAdd, threshold, procedureInfos, govActionId, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.UpdateCommittee,
                    toRemove: toRemove,
                    toAdd: toAdd,
                    threshold: threshold,
                    govActionId: govActionId ? (0, cardano_ledger_ts_1.forceTxOutRef)(govActionId) : undefined,
                } }), redeemer, script_or_ref);
        }
        function _proposeNewConstitution(constitution, procedureInfos, govActionId, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.NewConstitution,
                    constitution: constitution,
                    govActionId: govActionId ? (0, cardano_ledger_ts_1.forceTxOutRef)(govActionId) : undefined,
                } }), redeemer, script_or_ref);
        }
        function _proposeInfos(procedureInfos, redeemer, script_or_ref) {
            return _propose(__assign(__assign({}, procedureInfos), { govAction: {
                    govActionType: cardano_ledger_ts_1.GovActionType.Info,
                } }), redeemer, script_or_ref);
        }
        function _build() {
            var _a, _b, _c, _d;
            return __awaiter(this, void 0, void 0, function () {
                function resolveUtxos(_tasks) {
                    return __awaiter(this, void 0, void 0, function () {
                        var utxosToFind, uLen, resolvedUtxos, iLen, _tasks_1, _tasks_1_1, arg, _a, _b, _c, _d, datumHashesToResolve, resolvedDatums, resolvedDatums_1, resolvedDatums_1_1, _e, hash, datum, forced, _loop_1, resolvedUtxos_1, resolvedUtxos_1_1, u;
                        var e_5, _f, e_6, _g, e_7, _h;
                        return __generator(this, function (_j) {
                            switch (_j.label) {
                                case 0:
                                    utxosToFind = new Array(_tasks.length);
                                    uLen = 0;
                                    resolvedUtxos = new Array(_tasks.length);
                                    iLen = 0;
                                    try {
                                        for (_tasks_1 = __values(_tasks), _tasks_1_1 = _tasks_1.next(); !_tasks_1_1.done; _tasks_1_1 = _tasks_1.next()) {
                                            arg = _tasks_1_1.value.arg;
                                            if (arg instanceof cardano_ledger_ts_1.UTxO)
                                                resolvedUtxos[iLen++] = arg;
                                            else if ((0, cardano_ledger_ts_1.isIUTxO)(arg))
                                                resolvedUtxos[iLen++] = new cardano_ledger_ts_1.UTxO(arg);
                                            else
                                                utxosToFind[uLen++] = arg;
                                        }
                                    }
                                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                    finally {
                                        try {
                                            if (_tasks_1_1 && !_tasks_1_1.done && (_f = _tasks_1.return)) _f.call(_tasks_1);
                                        }
                                        finally { if (e_5) throw e_5.error; }
                                    }
                                    utxosToFind.length = uLen;
                                    resolvedUtxos.length = iLen;
                                    if (!(uLen > 0)) return [3 /*break*/, 2];
                                    if (typeof provider.resolveUtxos !== "function") {
                                        throw new Error("some unresolved utxos where used and the provider is missing the 'resolveUtxos' method to resolve them");
                                    }
                                    _b = (_a = resolvedUtxos.push).apply;
                                    _c = [resolvedUtxos];
                                    _d = [[]];
                                    return [4 /*yield*/, provider.resolveUtxos(utxosToFind)];
                                case 1:
                                    _b.apply(_a, _c.concat([__spreadArray.apply(void 0, _d.concat([__read.apply(void 0, [(_j.sent())]), false]))]));
                                    _j.label = 2;
                                case 2:
                                    datumHashesToResolve = resolvedUtxos.filter(function (u) {
                                        var _a, _b;
                                        var dat = (_b = (_a = u.resolved.datum) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "undefined";
                                        return (bytestring_1.ByteString.isValidHexValue(dat) &&
                                            dat.length === 64 && // 32 * 2
                                            !_datumsHashes.includes(dat));
                                    })
                                        .map(function (u) { return u.resolved.datum; });
                                    if (!(datumHashesToResolve.length > 0)) return [3 /*break*/, 4];
                                    if (typeof provider.resolveDatumHashes !== "function") {
                                        throw new Error("provider is missing 'resolveDatumHashes' function but some unresolved datum hashes where found");
                                    }
                                    return [4 /*yield*/, provider.resolveDatumHashes(datumHashesToResolve)];
                                case 3:
                                    resolvedDatums = _j.sent();
                                    try {
                                        for (resolvedDatums_1 = __values(resolvedDatums), resolvedDatums_1_1 = resolvedDatums_1.next(); !resolvedDatums_1_1.done; resolvedDatums_1_1 = resolvedDatums_1.next()) {
                                            _e = resolvedDatums_1_1.value, hash = _e.hash, datum = _e.datum;
                                            try {
                                                forced = (0, CanBeData_1.forceData)(datum);
                                                _saveResolvedDatum(forced, hash.toString());
                                            }
                                            catch (_k) { }
                                        }
                                    }
                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                                    finally {
                                        try {
                                            if (resolvedDatums_1_1 && !resolvedDatums_1_1.done && (_g = resolvedDatums_1.return)) _g.call(resolvedDatums_1);
                                        }
                                        finally { if (e_6) throw e_6.error; }
                                    }
                                    _j.label = 4;
                                case 4:
                                    _loop_1 = function (u) {
                                        var resolvedIdx = _tasks.findIndex(function (t) { return (0, cardano_ledger_ts_1.forceTxOutRefStr)(t.arg) === u.utxoRef.toString(); });
                                        if (resolvedIdx < 0) {
                                            return "continue";
                                        }
                                        var task = void 0;
                                        if (resolvedIdx === 0) {
                                            task = _tasks.shift();
                                        }
                                        else {
                                            task = _tasks[resolvedIdx];
                                            // remove in-place
                                            void _tasks.splice(resolvedIdx, 1);
                                        }
                                        task.onResolved(u);
                                    };
                                    try {
                                        for (resolvedUtxos_1 = __values(resolvedUtxos), resolvedUtxos_1_1 = resolvedUtxos_1.next(); !resolvedUtxos_1_1.done; resolvedUtxos_1_1 = resolvedUtxos_1.next()) {
                                            u = resolvedUtxos_1_1.value;
                                            _loop_1(u);
                                        }
                                    }
                                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                                    finally {
                                        try {
                                            if (resolvedUtxos_1_1 && !resolvedUtxos_1_1.done && (_h = resolvedUtxos_1.return)) _h.call(resolvedUtxos_1);
                                        }
                                        finally { if (e_7) throw e_7.error; }
                                    }
                                    // should already be 0 but just to be sure;
                                    _tasks.length = 0;
                                    return [2 /*return*/];
                            }
                        });
                    });
                }
                var otherTasks, oLen, utxoTasks, uLen, insTasks, iLen, tasks_1, tasks_1_1, task, hasUTxOTasks, tasks_2, tasks_2_1, task, _e, _f, _g, kind, getPromise, _h, _j, _k, _changeInput, tx;
                var e_3, _l, e_4, _m, _o;
                return __generator(this, function (_p) {
                    switch (_p.label) {
                        case 0:
                            otherTasks = new Array(tasks.length);
                            oLen = 0;
                            utxoTasks = new Array(tasks.length);
                            uLen = 0;
                            insTasks = new Array(tasks.length);
                            iLen = 0;
                            try {
                                // collect tasks first time
                                for (tasks_1 = __values(tasks), tasks_1_1 = tasks_1.next(); !tasks_1_1.done; tasks_1_1 = tasks_1.next()) {
                                    task = tasks_1_1.value;
                                    switch (task.kind) {
                                        case 0 /* TxBuilderTaskKind.ResolveUTxO */:
                                            utxoTasks[uLen++] = task;
                                            break;
                                        case 1 /* TxBuilderTaskKind.ResolveTxIn */:
                                            insTasks[iLen++] = task;
                                            break;
                                        default:
                                            otherTasks[oLen++] = task;
                                            break;
                                    }
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (tasks_1_1 && !tasks_1_1.done && (_l = tasks_1.return)) _l.call(tasks_1);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                            tasks.length = 0;
                            utxoTasks.length = uLen;
                            insTasks.length = iLen;
                            otherTasks.length = oLen;
                            _setCollateralTask && utxoTasks.push(_setCollateralTask);
                            return [4 /*yield*/, resolveUtxos(utxoTasks)];
                        case 1:
                            _p.sent();
                            hasUTxOTasks = utxoTasks.length > 0;
                            _p.label = 2;
                        case 2:
                            try {
                                // collect any other thasks
                                for (tasks_2 = (e_4 = void 0, __values(tasks)), tasks_2_1 = tasks_2.next(); !tasks_2_1.done; tasks_2_1 = tasks_2.next()) {
                                    task = tasks_2_1.value;
                                    switch (task.kind) {
                                        case 0 /* TxBuilderTaskKind.ResolveUTxO */:
                                            utxoTasks.push(task);
                                            break;
                                        case 1 /* TxBuilderTaskKind.ResolveTxIn */:
                                            insTasks.push(task);
                                            break;
                                        default:
                                            otherTasks.push(task);
                                            break;
                                    }
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (tasks_2_1 && !tasks_2_1.done && (_m = tasks_2.return)) _m.call(tasks_2);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                            // clear all tasks
                            tasks.length = 0;
                            hasUTxOTasks = utxoTasks.length > 0;
                            _e = hasUTxOTasks;
                            if (!_e) return [3 /*break*/, 4];
                            return [4 /*yield*/, resolveUtxos(utxoTasks)];
                        case 3:
                            _e = (_p.sent());
                            _p.label = 4;
                        case 4:
                            _e;
                            _p.label = 5;
                        case 5:
                            if (hasUTxOTasks) return [3 /*break*/, 2];
                            _p.label = 6;
                        case 6:
                            _f = insTasks.length > 0;
                            if (!_f) return [3 /*break*/, 8];
                            return [4 /*yield*/, resolveUtxos(insTasks)];
                        case 7:
                            _f = (_p.sent());
                            _p.label = 8;
                        case 8:
                            _f;
                            _p.label = 9;
                        case 9:
                            if (!(otherTasks.length > 0)) return [3 /*break*/, 13];
                            _g = otherTasks.pop(), kind = _g.kind, getPromise = _g.getPromise;
                            if (!((kind === 2 /* TxBuilderTaskKind.ValidFromPOSIX */ || kind === 3 /* TxBuilderTaskKind.ValidToPOSIX */) &&
                                !(0, GenesisInfos_1.isGenesisInfos)(txBuilder.genesisInfos))) return [3 /*break*/, 11];
                            if (typeof provider.getGenesisInfos !== "function") {
                                throw new Error("POSIX operatoins do require either a tx builder with genesis infos or a provider that can fetch them; but none is present");
                            }
                            _j = (_h = txBuilder).setGenesisInfos;
                            return [4 /*yield*/, provider.getGenesisInfos()];
                        case 10:
                            _j.apply(_h, [_p.sent()]);
                            _p.label = 11;
                        case 11: return [4 /*yield*/, getPromise()];
                        case 12:
                            _p.sent();
                            return [3 /*break*/, 9];
                        case 13:
                            ;
                            if (!!buildArgs.changeAddress) return [3 /*break*/, 16];
                            if (!(typeof provider.getChangeAddress === "function")) return [3 /*break*/, 15];
                            _k = buildArgs;
                            return [4 /*yield*/, provider.getChangeAddress()];
                        case 14:
                            _k.changeAddress = _p.sent();
                            return [3 /*break*/, 16];
                        case 15:
                            if (!Array.isArray(buildArgs.inputs) ||
                                buildArgs.inputs.length === 0) {
                                throw new Error("can't deduce change Address; missing inputs");
                            }
                            _changeInput = (_a = buildArgs.inputs) === null || _a === void 0 ? void 0 : _a.find(function (_in) {
                                var addr = ((0, cardano_ledger_ts_1.isIUTxO)(_in) ? _in : _in.utxo).resolved.address;
                                return (addr instanceof cardano_ledger_ts_1.Address ?
                                    addr : cardano_ledger_ts_1.Address.fromString(addr)).paymentCreds.type === cardano_ledger_ts_1.CredentialType.KeyHash;
                            });
                            buildArgs.changeAddress =
                                (_b = ((0, cardano_ledger_ts_1.isIUTxO)(_changeInput) ?
                                    _changeInput :
                                    _changeInput === null || _changeInput === void 0 ? void 0 : _changeInput.utxo)) === null || _b === void 0 ? void 0 : _b.resolved.address;
                            if (!buildArgs.changeAddress) {
                                console.log(buildArgs.outputs);
                                console.log(Array.isArray(buildArgs.outputs));
                                if (Array.isArray(buildArgs.outputs)) {
                                    buildArgs.changeAddress = (_d = (_c = buildArgs.outputs) === null || _c === void 0 ? void 0 : _c.find(function (out) { return (0, forceAddr_1.forceAddr)(out.address).paymentCreds.type === cardano_ledger_ts_1.CredentialType.KeyHash; })) === null || _d === void 0 ? void 0 : _d.address;
                                }
                                else
                                    throw new Error("can't deduce change Address; only script inputs");
                                if (!buildArgs.changeAddress) {
                                    throw new Error("can't deduce change Address; only script inputs and scripts outputs");
                                }
                            }
                            _p.label = 16;
                        case 16:
                            if (refUtxos.length > 0) {
                                if (!Array.isArray(buildArgs.readonlyRefInputs)) {
                                    buildArgs.readonlyRefInputs = [];
                                }
                                void (_o = buildArgs.readonlyRefInputs).push.apply(_o, __spreadArray([], __read(refUtxos), false));
                            }
                            return [4 /*yield*/, txBuilder.build(buildArgs)];
                        case 17:
                            tx = _p.sent();
                            self.reset();
                            return [2 /*return*/, tx];
                    }
                });
            });
        }
        ;
        Object.defineProperties(this, {
            addSigner: __assign({ value: _addRequiredSigner }, readonlyValueDescriptor),
            addRequiredSigner: __assign({ value: _addRequiredSigner }, readonlyValueDescriptor),
            addSignerKey: __assign({ value: _addRequiredSignerKey }, readonlyValueDescriptor),
            addRequiredSignerKey: __assign({ value: _addRequiredSignerKey }, readonlyValueDescriptor),
            attachMetadata: __assign({ value: _attachMetadata }, readonlyValueDescriptor),
            setMetadata: __assign({ value: _attachMetadata }, readonlyValueDescriptor),
            attachMetadataJson: __assign({ value: _attachMetadataJson }, readonlyValueDescriptor),
            attachMetadataJsonWithConversion: __assign({ value: _attachMetadataJsonWithConversion }, readonlyValueDescriptor),
            setChangeAddress: __assign({ value: _setChangeAddress }, readonlyValueDescriptor),
            validFrom: __assign({ value: _validFromPOSIX }, readonlyValueDescriptor),
            validFromSlot: __assign({ value: _validFromSlot }, readonlyValueDescriptor),
            invalidBeforeSlot: __assign({ value: _validFromSlot }, readonlyValueDescriptor),
            validTo: __assign({ value: _validToPOSIX }, readonlyValueDescriptor),
            validToSlot: __assign({ value: _validToSlot }, readonlyValueDescriptor),
            invalidAfterSlot: __assign({ value: _validToSlot }, readonlyValueDescriptor),
            delegateTo: __assign({ value: _delegateTo }, readonlyValueDescriptor),
            deregisterStake: __assign({ value: _deregisterStake }, readonlyValueDescriptor),
            mintAssets: __assign({ value: _mintAssets }, readonlyValueDescriptor),
            registerStake: __assign({ value: _registerStake }, readonlyValueDescriptor),
            registerStakeAddress: __assign({ value: _registerStake }, readonlyValueDescriptor),
            registerPool: __assign({ value: _registerPool }, readonlyValueDescriptor),
            retirePool: __assign({ value: _retirePool }, readonlyValueDescriptor),
            withdraw: __assign({ value: _withdraw }, readonlyValueDescriptor),
            attachCertificateValidator: __assign({ value: _addAviableScript }, readonlyValueDescriptor),
            attachMintingValidator: __assign({ value: _addAviableScript }, readonlyValueDescriptor),
            attachSpendingValidator: __assign({ value: _addAviableScript }, readonlyValueDescriptor),
            attachWithdrawalValidator: __assign({ value: _addAviableScript }, readonlyValueDescriptor),
            attachValidator: __assign({ value: _addAviableScript }, readonlyValueDescriptor),
            readFrom: __assign({ value: _referenceUTxOs }, readonlyValueDescriptor),
            referenceUtxos: __assign({ value: _referenceUTxOs }, readonlyValueDescriptor),
            collectFrom: __assign({ value: _addInputs }, readonlyValueDescriptor),
            addInputs: __assign({ value: _addInputs }, readonlyValueDescriptor),
            addInput: __assign({ value: _addSingleInput }, readonlyValueDescriptor),
            payTo: __assign({ value: _payTo }, readonlyValueDescriptor),
            setCollateral: __assign({ value: _setCollateral }, readonlyValueDescriptor),
            setCollateralAmount: __assign({ value: _setCollateralAmount }, readonlyValueDescriptor),
            vote: __assign({ value: _vote }, readonlyValueDescriptor),
            voteDRep: __assign({ value: _voteDRep }, readonlyValueDescriptor),
            voteScriptDRep: __assign({ value: _voteScriptDRep }, readonlyValueDescriptor),
            voteConstitutionalComittee: __assign({ value: _voteConstitutionalComittee }, readonlyValueDescriptor),
            voteScriptConstitutionalComittee: __assign({ value: _voteScriptConstitutionalComittee }, readonlyValueDescriptor),
            voteStakePool: __assign({ value: _voteStakePool }, readonlyValueDescriptor),
            propose: __assign({ value: _propose }, readonlyValueDescriptor),
            proposeParametersChanges: __assign({ value: _proposeParametersChanges }, readonlyValueDescriptor),
            proposeHardForkInitiation: __assign({ value: _proposeHardForkInitiation }, readonlyValueDescriptor),
            proposeTreasuryWithdrawal: __assign({ value: _proposeTreasuryWithdrawal }, readonlyValueDescriptor),
            proposeNoConfidence: __assign({ value: _proposeNoConfidence }, readonlyValueDescriptor),
            proposeComitteeUpdate: __assign({ value: _proposeComitteeUpdate }, readonlyValueDescriptor),
            proposeNewConstitution: __assign({ value: _proposeNewConstitution }, readonlyValueDescriptor),
            proposeInfos: __assign({ value: _proposeInfos }, readonlyValueDescriptor),
            build: __assign({ value: _build }, readonlyValueDescriptor)
        });
    }
    return TxBuilderRunner;
}());
exports.TxBuilderRunner = TxBuilderRunner;
