"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jsonToMetadata = void 0;
var cardano_ledger_ts_1 = require("@harmoniclabs/cardano-ledger-ts");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
function jsonToMetadata(json, withConversion) {
    if (withConversion === void 0) { withConversion = false; }
    if (typeof json === "number" || typeof json === "bigint")
        return new cardano_ledger_ts_1.TxMetadatumInt(json);
    if (typeof json === "string") {
        if (withConversion && json.startsWith("0x")) {
            return new cardano_ledger_ts_1.TxMetadatumBytes((0, uint8array_utils_1.fromHex)(json.slice(2)));
        }
        return new cardano_ledger_ts_1.TxMetadatumText(json);
    }
    if (Array.isArray(json)) {
        return new cardano_ledger_ts_1.TxMetadatumList(json.map(function (el) { return jsonToMetadata(el, withConversion); }));
    }
    if ((0, obj_utils_1.isObject)(json)) {
        var keys = Object.keys(json);
        var len = keys.length;
        var entries = new Array(len);
        for (var i = 0; i < len; i++) {
            var ki = keys[i];
            entries[i] = {
                k: jsonToMetadata(ki, withConversion),
                v: jsonToMetadata(json[ki], withConversion)
            };
        }
        return new cardano_ledger_ts_1.TxMetadatumMap(entries);
    }
    throw new Error("unexpected tx metatada json");
}
exports.jsonToMetadata = jsonToMetadata;
