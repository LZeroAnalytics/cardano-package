"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Machine = void 0;
var uplc_1 = require("@harmoniclabs/uplc");
var BnCEK_1 = require("../BnCEK/BnCEK.js");
var PartialBuiltin_1 = require("../BnCEK/PartialBuiltin.js");
var CEKEnv_1 = require("../CEKEnv.js");
var CEKFrames_1 = require("../CEKFrames/CEKFrames.js");
var ForceFrame_1 = require("../CEKFrames/ForceFrame.js");
var LApp_1 = require("../CEKFrames/LApp.js");
var RApp_1 = require("../CEKFrames/RApp.js");
var CEKHeap_1 = require("../CEKHeap/index.js");
var CEKSteps_1 = require("../CEKSteps/index.js");
var CEKDelay_1 = require("../CEKValue/CEKDelay.js");
var CEKLambda_1 = require("../CEKValue/CEKLambda.js");
var BuiltinCosts_1 = require("./BuiltinCosts/BuiltinCosts.js");
var ExBudget_1 = require("./ExBudget.js");
var MachineCosts_1 = require("./MachineCosts.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var cardano_costmodels_ts_1 = require("@harmoniclabs/cardano-costmodels-ts");
var ConstrFrame_1 = require("../CEKFrames/ConstrFrame.js");
var CEKValue_1 = require("../CEKValue/CEKValue.js");
var CaseFrame_1 = require("../CEKFrames/CaseFrame.js");
var CEKError_1 = require("../CEKValue/CEKError.js");
var CEKConst_1 = require("../CEKValue/CEKConst.js");
var CEKConstr_1 = require("../CEKValue/CEKConstr.js");
var Machine = /** @class */ (function () {
    function Machine(costmodel) {
        var isV1 = (0, cardano_costmodels_ts_1.isCostModelsV1)(costmodel);
        var isV2 = (0, cardano_costmodels_ts_1.isCostModelsV2)(costmodel);
        var isV3 = (0, cardano_costmodels_ts_1.isCostModelsV3)(costmodel);
        if (!(isV3 || isV2 || isV1))
            throw new Error("invalid machine costs");
        // ALWAYS CHECK LATEST VERSION FIRST
        var costs = isV3 ? (0, cardano_costmodels_ts_1.toCostModelV3)(costmodel) :
            isV2 ? (0, cardano_costmodels_ts_1.costModelV2ToFakeV3)(costmodel) :
                isV1 ? (0, cardano_costmodels_ts_1.costModelV1ToFakeV3)(costmodel) :
                    cardano_costmodels_ts_1.defaultV3Costs; // never; we throw before
        (0, obj_utils_1.defineReadOnlyHiddenProperty)(this, "getBuiltinCostFuction", (0, BuiltinCosts_1.costModelV3ToBuiltinCosts)(costs));
        (0, obj_utils_1.defineReadOnlyHiddenProperty)(this, "machineCosts", (0, MachineCosts_1.costModelToMachineCosts)(costs));
    }
    Machine.evalSimple = function (_term, srcmap) {
        if (srcmap === void 0) { srcmap = undefined; }
        return new Machine(cardano_costmodels_ts_1.defaultV3Costs).eval(_term, srcmap).result;
    };
    Machine.eval = function (_term, srcmap) {
        if (srcmap === void 0) { srcmap = undefined; }
        return new Machine(cardano_costmodels_ts_1.defaultV3Costs).eval(_term, srcmap);
    };
    Machine.prototype.eval = function (_term, srcmap) {
        var _a, _b;
        if (srcmap === void 0) { srcmap = undefined; }
        var has_src = typeof srcmap === "object" && srcmap !== null;
        // new budget for each call
        var budget = new ExBudget_1.ExBudget({ mem: 0, cpu: 0 });
        var spend = budget.add.bind(budget);
        var logs = [];
        var machineCosts = this.machineCosts;
        var getBuiltinCostFuction = this.getBuiltinCostFuction;
        function spendBuiltin(bn) {
            var nForces = BigInt((0, uplc_1.getNRequiredForces)(bn.tag));
            if (nForces === BigInt(0)) {
                budget.add(machineCosts.builtinNode);
                return;
            }
            budget.add({
                mem: machineCosts.builtinNode.mem + (machineCosts.force.mem * nForces),
                cpu: machineCosts.builtinNode.cpu + (machineCosts.force.cpu * nForces)
            });
        }
        var bnCEK = new BnCEK_1.BnCEK(getBuiltinCostFuction, budget, logs);
        var frames = new CEKFrames_1.CEKFrames();
        var steps = new CEKSteps_1.CEKSteps();
        var heap = new CEKHeap_1.CEKHeap();
        var _poppedFrame = undefined;
        function popTopFrame() {
            return _poppedFrame = frames.pop();
        }
        function defineCallStack(thing) {
            if (!(0, obj_utils_1.isObject)(thing))
                return;
            if (typeof Object.isExtensible === "function" &&
                !Object.isExtensible(thing))
                return;
            if (!Array.isArray(thing.__call_stack__))
                return;
            var hasPoppedFrame = (0, CEKFrames_1.isFrame)(_poppedFrame);
            // re insert top frame for call stack to include it.
            if (hasPoppedFrame)
                frames.push(_poppedFrame);
            try {
                Object.defineProperty(thing, "__call_stack__", {
                    value: Object.freeze(frames.callStack()),
                    enumerable: true,
                    writable: true,
                    configurable: false
                });
            }
            catch (_a) { } // object was not extensible, we don't care
            // re-remove the top frame
            if (hasPoppedFrame)
                frames.pop();
        }
        var uplc = (0, uplc_1.isUPLCTerm)(_term) ? _term : _term.toUPLC(0);
        if (has_src) {
            indexNodes(uplc);
        }
        spend(machineCosts.startup);
        compute(uplc, new CEKEnv_1.CEKEnv(heap));
        while (!frames.isEmpty || steps.topIsCompute) {
            var nextStep = steps.top();
            if (nextStep === undefined) {
                throw new Error("step stack was empty; don't know how to proceed");
            }
            if (nextStep instanceof CEKSteps_1.ComputeStep) {
                void steps.pop();
                compute(nextStep.term, nextStep.env);
            }
            else if (nextStep instanceof CEKSteps_1.ReturnStep) {
                if (nextStep.value instanceof CEKError_1.CEKError) {
                    steps._clear();
                    steps.push(nextStep); // save error
                    break; // exit loop
                }
                void steps.pop();
                returnCEK(nextStep.value);
            }
            else
                throw new Error("unknown step");
        }
        function compute(term, env) {
            // n_compute++;
            if (term instanceof uplc_1.ErrorUPLC) {
                defineCallStack(term);
                // console.log( term );
                steps.push(new CEKSteps_1.ReturnStep(CEKError_1.CEKError.fromUplc(term, frames._frames)));
                return;
            }
            if (term instanceof uplc_1.UPLCVar) {
                var varValue = env.get(term.deBruijn);
                if (varValue === undefined) {
                    steps.push(new CEKSteps_1.ReturnStep(new CEKError_1.CEKError("unbound uplc variable")));
                    return;
                }
                budget.add(machineCosts.var);
                steps.push(new CEKSteps_1.ReturnStep(varValue));
                return;
            }
            if (term instanceof uplc_1.UPLCConst) {
                budget.add(machineCosts.constant);
                steps.push(new CEKSteps_1.ReturnStep(CEKConst_1.CEKConst.fromUplc(term)));
                return;
            }
            if (term instanceof uplc_1.Lambda) {
                budget.add(machineCosts.lam);
                steps.push(new CEKSteps_1.ReturnStep(new CEKLambda_1.CEKLambda(term.body, env.clone())));
                return;
            }
            if (term instanceof uplc_1.Delay) {
                budget.add(machineCosts.delay);
                steps.push(new CEKSteps_1.ReturnStep(new CEKDelay_1.CEKDelay(term.delayedTerm, env.clone())));
                return;
            }
            if (term instanceof uplc_1.Force) {
                budget.add(machineCosts.force);
                frames.push(new ForceFrame_1.ForceFrame());
                steps.push(new CEKSteps_1.ComputeStep(term.termToForce, env));
                return;
            }
            // 𝑠; 𝜌 ⊳ [𝑀 𝑁]↦ [_ (𝑁, 𝜌)]⋅𝑠; 𝜌 ⊳ 𝑀
            if (term instanceof uplc_1.Application) {
                budget.add(machineCosts.apply);
                var rapp = new RApp_1.RApp(term.argTerm, env.clone());
                // [_ (𝑁, 𝜌)]⋅𝑠;
                frames.push(rapp);
                // 𝜌 ⊳ 𝑀
                steps.push(new CEKSteps_1.ComputeStep(term.funcTerm, env));
                if (has_src && typeof (term.__node_index__) === "number")
                    rapp.src = srcmap[term.__node_index__];
                return;
            }
            // 𝑠; 𝜌 ⊳ (constr 𝑖 𝑀⋅𝑀[])↦ (constr 𝑖 _ (𝑀[], 𝜌))⋅𝑠; 𝜌 ⊳ 𝑀
            // 𝑠; 𝜌 ⊳ (constr 𝑖 [])↦ 𝑠 ⊲ 〈constr 𝑖 []〉
            if (term instanceof uplc_1.Constr) {
                budget.add(machineCosts.constr);
                // 𝑠; 𝜌 ⊳ (constr 𝑖 𝑀⋅𝑀[])↦ (constr 𝑖 _ (𝑀[], 𝜌))⋅𝑠; 𝜌 ⊳ 𝑀
                if (term.terms.length > 0) {
                    // (constr 𝑖 _ (𝑀[], 𝜌))⋅𝑠;
                    frames.push(new ConstrFrame_1.ConstrFrame(term.index, term.terms.slice(1), [], env));
                    // 𝜌 ⊳ 𝑀
                    steps.push(new CEKSteps_1.ComputeStep(term.terms[0], env));
                }
                // 𝑠; 𝜌 ⊳ (constr 𝑖 [])↦ 𝑠 ⊲ 〈constr 𝑖 []〉
                else {
                    steps.push(new CEKSteps_1.ReturnStep(new CEKConstr_1.CEKConstr(term.index, [])));
                }
                return;
            }
            // 𝑠; 𝜌 ⊳ (case 𝑁 𝑀[])↦ (case _ (𝑀[], 𝜌))⋅𝑠; 𝜌 ⊳ 𝑁
            if (term instanceof uplc_1.Case) {
                budget.add(machineCosts.case);
                // (case _ (𝑀[], 𝜌))⋅𝑠;
                frames.push(new CaseFrame_1.CaseFrame(term.continuations, env.clone()));
                // 𝜌 ⊳ 𝑁
                steps.push(new CEKSteps_1.ComputeStep(term.constrTerm, env));
                return;
            }
            // 𝑠; 𝜌 ⊳ (builtin 𝑏)↦ 𝑠 ⊲ 〈builtin 𝑏 [] 𝛼(𝑏)〉
            if (term instanceof uplc_1.Builtin ||
                term instanceof PartialBuiltin_1.PartialBuiltin) {
                if (term instanceof uplc_1.Builtin)
                    spendBuiltin(term);
                // 𝑠 ⊲ 〈builtin 𝑏 [] 𝛼(𝑏)〉
                steps.push(new CEKSteps_1.ReturnStep(term instanceof PartialBuiltin_1.PartialBuiltin ? term : new PartialBuiltin_1.PartialBuiltin(term.tag)));
                return;
            }
            var err = new CEKError_1.CEKError("ComputeStep/no match", { term: term });
            defineCallStack(err);
            steps.push(new CEKSteps_1.ReturnStep(err));
            return;
        }
        function returnCEK(v) {
            if (v instanceof uplc_1.ErrorUPLC) {
                defineCallStack(v);
                steps._clear();
                // terminates while loop
                steps.push(new CEKSteps_1.ReturnStep(v));
                return;
            }
            if (v instanceof PartialBuiltin_1.PartialBuiltin) {
                if (v.nMissingArgs === 0) {
                    console.log(v);
                    var evalResult = bnCEK.eval(v);
                    if (evalResult instanceof uplc_1.ErrorUPLC) {
                        defineCallStack(evalResult);
                    }
                    steps.push(new CEKSteps_1.ReturnStep(evalResult));
                    return;
                }
                if (frames.isEmpty) {
                    var err_1 = new uplc_1.ErrorUPLC("ReturnStep/PartialBuiltin/empty frames");
                    defineCallStack(err_1);
                    steps.push(new CEKSteps_1.ReturnStep(err_1));
                    return;
                }
            }
            function applyBuiltin(bn, value) {
                if (bn instanceof uplc_1.Builtin) {
                    spendBuiltin(bn);
                    bn = new PartialBuiltin_1.PartialBuiltin(bn.tag);
                }
                bn.apply(value);
                if (bn.nMissingArgs === 0) {
                    var evalResult = bnCEK.eval(bn);
                    if (evalResult instanceof CEKError_1.CEKError)
                        defineCallStack(evalResult);
                    steps.push(new CEKSteps_1.ReturnStep(evalResult));
                    return;
                }
                // choose what to do based on the frames
                steps.push(new CEKSteps_1.ReturnStep(bn));
                return;
            }
            //[] ⊲ 𝑉 ↦ ◻𝑉
            if (frames.isEmpty) {
                // ends while loop
                steps.push(new CEKSteps_1.ReturnStep(v));
                return;
            }
            var topFrame = popTopFrame();
            if (topFrame instanceof RApp_1.RApp) {
                if ((0, CEKValue_1.isCEKValue)(topFrame.arg)) {
                    // right application to value
                    // and value is lambda
                    // has the same result
                    // of left application to lambda
                    // [_ 𝑉 ]⋅𝑠 ⊲ 〈lam 𝑥 𝑀 𝜌〉↦ 𝑠; 𝜌[𝑥 ↦ 𝑉 ] ⊳ 𝑀
                    if (v instanceof CEKLambda_1.CEKLambda) {
                        var env = v.env.clone();
                        // 𝜌[𝑥 ↦ 𝑉 ]
                        env.push(topFrame.arg);
                        // ⊳ 𝑀
                        steps.push(new CEKSteps_1.ComputeStep(v.body, env));
                        return;
                    }
                    // [_ 𝑉 ]⋅𝑠 ⊲ 〈builtin 𝑏 𝑉 (𝜄⋅𝜂)〉 ↦ 𝑠 ⊲ 〈builtin 𝑏 (𝑉 ⋅𝑉 ) 𝜂〉 if 𝜄 ∈ U# ∪ V∗
                    else if (v instanceof PartialBuiltin_1.PartialBuiltin ||
                        v instanceof uplc_1.Builtin) {
                        applyBuiltin(v.clone(), topFrame.arg);
                        return;
                    }
                    return;
                }
                // [_ (𝑀, 𝜌)]⋅𝑠 ⊲ 𝑉 ↦ [𝑉 _]⋅𝑠; 𝜌 ⊳ 𝑀
                else {
                    // [𝑉 _]⋅𝑠;
                    frames.push(new LApp_1.LApp(v, topFrame.src));
                    // 𝜌 ⊳ 𝑀
                    steps.push(new CEKSteps_1.ComputeStep(topFrame.arg, topFrame.env));
                    return;
                }
                return;
            }
            if (topFrame instanceof LApp_1.LApp) {
                // [〈builtin 𝑏 𝑉 (𝜄⋅𝜂)〉 _]⋅𝑠 ⊲ 𝑉 ↦ 𝑠 ⊲ 〈builtin 𝑏 (𝑉 ⋅𝑉 ) 𝜂〉 if 𝜄 ∈ U# ∪ V∗
                // [〈builtin 𝑏 𝑉 [𝜄]〉 _]⋅𝑠 ⊲ 𝑉 ↦ 𝖤𝗏𝖺𝗅 𝖢𝖤𝖪 (𝑠, 𝑏, 𝑉 ⋅𝑉 ) if 𝜄 ∈ U# ∪ V∗
                if (topFrame.func instanceof uplc_1.Builtin ||
                    topFrame.func instanceof PartialBuiltin_1.PartialBuiltin) {
                    applyBuiltin(topFrame.func.clone(), v);
                    return;
                }
                if (topFrame.func instanceof uplc_1.Lambda ||
                    topFrame.func instanceof CEKLambda_1.CEKLambda) {
                    var _env = topFrame.func instanceof CEKLambda_1.CEKLambda ?
                        topFrame.func.env :
                        new CEKEnv_1.CEKEnv(heap);
                    _env.push(v);
                    steps.push(new CEKSteps_1.ComputeStep(topFrame.func.body, _env));
                    return;
                }
                return;
            }
            // builtin forces are added only at compile time
            // hence not present in plu-ts UPLCTerm
            if (topFrame instanceof ForceFrame_1.ForceFrame) {
                if (v instanceof uplc_1.Delay ||
                    v instanceof CEKDelay_1.CEKDelay) {
                    steps.push(new CEKSteps_1.ComputeStep(v.delayedTerm, v instanceof CEKDelay_1.CEKDelay ? v.env : new CEKEnv_1.CEKEnv(heap)));
                    return;
                }
                // not sure about the env...
                steps.push(new CEKSteps_1.ComputeStep(v, new CEKEnv_1.CEKEnv(heap)));
                return;
            }
            if (topFrame instanceof ConstrFrame_1.ConstrFrame) {
                // (constr 𝑖 𝑉[] _ ([], 𝜌))⋅𝑠 ⊲ 𝑉 ↦ 𝑠 ⊲ 〈constr 𝑖 𝑉 ⋅𝑉[] 〉
                if (topFrame.terms.length === 0) {
                    // 𝑠 ⊲ 〈constr 𝑖 𝑉 ⋅𝑉[] 〉
                    steps.push(new CEKSteps_1.ReturnStep(new CEKConstr_1.CEKConstr(topFrame.tag, 
                    // 𝑉 ⋅𝑉[]
                    [v].concat(topFrame.values))));
                    return;
                }
                // (constr 𝑖 𝑉[] _ (𝑀⋅𝑀[], 𝜌))⋅𝑠 ⊲ 𝑉 ↦ (constr 𝑖 𝑉 ⋅𝑉[] _ (𝑀[], 𝜌))⋅𝑠; 𝜌 ⊳ 𝑀
                else {
                    // (constr 𝑖 𝑉 ⋅𝑉[] _ (𝑀[], 𝜌))⋅𝑠
                    frames.push(new ConstrFrame_1.ConstrFrame(
                    // 𝑖
                    topFrame.tag, 
                    // 𝑀[]
                    topFrame.terms.slice(1), 
                    // 𝑉 ⋅𝑉[]
                    [v].concat(topFrame.values), 
                    // 𝜌
                    topFrame.env.clone()));
                    // 𝜌 ⊳ 𝑀
                    steps.push(new CEKSteps_1.ComputeStep(topFrame.terms[0], topFrame.env));
                    return;
                }
                return;
            }
            // (case _ (𝑀0 … 𝑀𝑛 , 𝜌))⋅𝑠 ⊲ 〈constr 𝑖 𝑉0 … 𝑉𝑚 〉 ↦ [_ 𝑉𝑚 ]⋅⋯⋅[_ 𝑉0 ]⋅𝑠; 𝜌 ⊳ 𝑀𝑖 if 0 ≤ 𝑖 ≤ 𝑛
            if (topFrame instanceof CaseFrame_1.CaseFrame) {
                if (!(v instanceof CEKConstr_1.CEKConstr)) {
                    steps.push(new CEKSteps_1.ReturnStep(new CEKError_1.CEKError("case frame did not receive constr value", { value: v })));
                    return;
                }
                //[_ 𝑉𝑚 ]⋅⋯⋅[_ 𝑉0 ]⋅𝑠;
                frames.push.apply(frames, __spreadArray([], __read(v.values
                    .map(function (v) { return new RApp_1.RApp(v, topFrame.env.clone()); })
                // .reverse()
                ), false));
                var n = topFrame.terms.length;
                var i = Number(v.tag);
                // if 0 ≤ 𝑖 ≤ 𝑛
                if (!(0 <= i && i <= n)) {
                    steps._clear();
                    steps.push(new CEKSteps_1.ReturnStep(new CEKError_1.CEKError("case frame received constr with tag " + i +
                        "; but only ad aviable " + n + " term continuations")));
                    return;
                }
                // 𝜌 ⊳ 𝑀𝑖
                steps.push(new CEKSteps_1.ComputeStep(topFrame.terms[i], topFrame.env));
                return;
            }
            var err = new CEKError_1.CEKError("ReturnStep/LApp", { topFrame: topFrame });
            defineCallStack(err);
            steps.push(new CEKSteps_1.ReturnStep(err));
            return;
        }
        // Debug.timeEnd(timeTag);
        return {
            result: (_b = (_a = steps.pop()) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : new CEKError_1.CEKError("steps.pop() was not a ReturnStep"),
            budgetSpent: budget,
            logs: logs
        };
    };
    return Machine;
}());
exports.Machine = Machine;
// export interface EvalDebugOptions {
//     onComputeStep: () => void
//     onReturnStep: () => void
// }
function indexNodes(uplc, idx) {
    if (idx === void 0) { idx = 0; }
    Object.defineProperty(uplc, "__node_index__", {
        value: Number(idx),
        writable: false,
        enumerable: true,
        configurable: false
    });
    if (uplc instanceof uplc_1.Application) {
        var max_fn = indexNodes(uplc.funcTerm, idx + 1);
        return indexNodes(uplc.argTerm, max_fn + 1);
    }
    if (uplc instanceof uplc_1.Force)
        return indexNodes(uplc.termToForce, idx);
    if (uplc instanceof uplc_1.Delay)
        return indexNodes(uplc.delayedTerm, idx);
    if (uplc instanceof uplc_1.Lambda)
        return indexNodes(uplc.body, idx);
    // UPLCVar | UPLCConst | ErrorUPLC | Builtin
    // have no childs
    return idx;
}
