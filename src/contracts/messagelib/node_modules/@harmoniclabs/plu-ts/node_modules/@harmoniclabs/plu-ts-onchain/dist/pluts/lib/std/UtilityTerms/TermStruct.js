"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPStructMethods = void 0;
var Term_1 = require("../../../Term/index.js");
// !!! IMPORTANT !!!
// DO NOT change the order of imports
// `../../../Term/Type/kinds` is also a dependecy of `pmatch`
var pmatch_1 = require("../../../PTypes/PStruct/pmatch/index.js");
var type_system_1 = require("../../../type_system/index.js");
var data_1 = require("../../builtins/data/index.js");
var fromData_minimal_1 = require("../data/conversion/fromData_minimal.js");
var punsafeConvertType_1 = require("../../punsafeConvertType/index.js");
var TermInt_1 = require("./TermInt.js");
var TermList_1 = require("./TermList.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var IRHoisted_1 = require("../../../../IR/IRNodes/IRHoisted.js");
var IRFunc_1 = require("../../../../IR/IRNodes/IRFunc.js");
var IRApp_1 = require("../../../../IR/IRNodes/IRApp.js");
var IRNative_1 = require("../../../../IR/IRNodes/IRNative/index.js");
var IRVar_1 = require("../../../../IR/IRNodes/IRVar.js");
var IRLetted_1 = require("../../../../IR/IRNodes/IRLetted.js");
var addUserMethods_1 = require("./userMethods/addUserMethods.js");
var plet_1 = require("../../plet/index.js");
var hoisted_getFields = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // struct
new IRApp_1.IRApp(IRNative_1.IRNative.sndPair, new IRApp_1.IRApp(IRNative_1.IRNative.unConstrData, new IRVar_1.IRVar(0))), "hoisted_getFields"));
function addPStructMethods(struct) {
    var t = struct.type;
    if (!(0, type_system_1.isStructType)(t))
        return struct;
    var sDef = t[1];
    if (typeof sDef === "symbol" || !(0, type_system_1.isStructDefinition)(sDef))
        return struct;
    var ctors = Object.keys(sDef);
    // shortcut for single ctors structs
    if (ctors.length === 1) {
        var ctorName = ctors[0];
        var ctor = sDef[ctorName];
        var fieldsNames = Object.keys(ctor);
        var nFields = fieldsNames.length;
        var letted_fieldsListData = new Term_1.Term((0, type_system_1.list)(type_system_1.data), function (dbn) { return new IRLetted_1.IRLetted(Number(dbn), new IRApp_1.IRApp(hoisted_getFields.clone(), struct.toIR(dbn))); });
        for (var i = 0; i < nFields; i++) {
            var thisFieldName = fieldsNames[i];
            var thisFieldType = ctor[thisFieldName];
            (!(0, obj_utils_1.hasOwn)(struct, thisFieldName)) && Object.defineProperty(struct, thisFieldName, {
                value: (0, punsafeConvertType_1.punsafeConvertType)((0, plet_1.plet)((0, fromData_minimal_1._fromData)(thisFieldType)((0, pmatch_1.getElemAtTerm)(i).$(letted_fieldsListData)), ctorName + "::" + thisFieldName
                // (dbn, ir) => {
                //     if(ctorName + "::" + thisFieldName !== "PScriptContext::purpose") return;
                // 
                //     const [ _dbn, term ] = getNormalizedLettedArgs( ir.dbn, ir.value ) ?? [ 0, new IRVar( 0 )] ;
                //     console.log(
                //         "PScriptContext::purpose at dbn:", dbn, 
                //         "\nnormalized value:", prettyIRJsonStr( term, 2, { hoisted: false } ),
                //         "\nnormalized value hash:", toHex( term.hash ),
                //         "\nnormalized dbn:", _dbn,
                //     );
                // }
                ), thisFieldType),
                writable: false,
                enumerable: true,
                configurable: false
            });
        }
        /**
         * @deprecated
         */
        (0, obj_utils_1.defineReadOnlyProperty)(struct, "extract", function () {
            var fields = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fields[_i] = arguments[_i];
            }
            return {
                in: function (expr) { return expr(struct); }
            };
        });
    }
    (0, obj_utils_1.definePropertyIfNotPresent)(struct, "peq", {
        get: function () { return (0, plet_1.plet)(data_1.peqData.$(struct)); },
        set: function () { },
        configurable: false,
        enumerable: true
    });
    (0, obj_utils_1.defineReadOnlyProperty)(struct, "eq", function (other) { return data_1.peqData.$(struct).$(other); });
    var letted_unconstred = new Term_1.Term((0, type_system_1.pair)(type_system_1.int, (0, type_system_1.list)(type_system_1.data)), function (dbn) { return new IRLetted_1.IRLetted(Number(dbn), new IRApp_1.IRApp(IRNative_1.IRNative.unConstrData, struct.toIR(dbn))); });
    var letted_ctorIdx = new Term_1.Term(type_system_1.int, function (dbn) { return new IRLetted_1.IRLetted(Number(dbn), new IRApp_1.IRApp(IRNative_1.IRNative.fstPair, letted_unconstred.toIR(dbn))); });
    var letted_rawFields = new Term_1.Term((0, type_system_1.list)(type_system_1.data), function (dbn) { return new IRLetted_1.IRLetted(Number(dbn), new IRApp_1.IRApp(IRNative_1.IRNative.sndPair, letted_unconstred.toIR(dbn))); });
    (0, obj_utils_1.defineReadOnlyProperty)(struct, "raw", Object.freeze({
        index: (0, TermInt_1.addPIntMethods)(letted_ctorIdx),
        fields: (0, TermList_1.addPListMethods)(letted_rawFields)
    }));
    struct = (0, addUserMethods_1.addUserMethods)(struct, t[2]);
    return struct;
}
exports.addPStructMethods = addPStructMethods;
