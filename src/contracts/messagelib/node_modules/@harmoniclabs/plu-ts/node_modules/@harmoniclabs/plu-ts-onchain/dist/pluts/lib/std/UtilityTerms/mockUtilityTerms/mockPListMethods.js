"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockPListMethods = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var Term_1 = require("../../../../Term/index.js");
var type_system_1 = require("../../../../type_system/index.js");
var tyArgs_1 = require("../../../../type_system/tyArgs/index.js");
var utils_1 = require("../../../../type_system/utils.js");
var PMaybe_1 = require("../../PMaybe/PMaybe.js");
var makeMockUtilityTerm_1 = require("./makeMockUtilityTerm.js");
var mockPIntMethods_1 = require("./mockPIntMethods.js");
var mockPBoolMethods_1 = require("./mockPBoolMethods.js");
var getterOnly = {
    set: function () { },
    configurable: false,
    enumerable: true
};
function mockPListMethods(lst) {
    var elemsT = (0, tyArgs_1.getElemsT)(lst.type);
    var _lst = new Term_1.Term((0, type_system_1.list)(elemsT), 
    // needs to be wrapped to prevent the garbage collector to collect garbage (lst)
    function (dbn) { return lst.toIR(dbn); }, lst.isConstant);
    if (!(0, type_system_1.isWellFormedGenericType)(elemsT)) {
        throw new Error("`addPListMethods` can only be used on lists with concrete types; the type of the _lst was: " + (0, utils_1.termTypeToString)(_lst.type));
    }
    _mockPListMethods(lst);
    _mockPListMethods(_lst);
    return _lst;
}
exports.mockPListMethods = mockPListMethods;
function _mockPListMethods(_lst) {
    var elemsT = (0, tyArgs_1.getElemsT)(_lst.type);
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "head", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)(elemsT); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "tail", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.list)(elemsT)); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "length", __assign({ get: function () { return (0, mockPIntMethods_1.makeMockTermInt)(); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "reversed", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.list)(elemsT)); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "pat", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)(type_system_1.int, elemsT)); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "at", function (index) { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)(elemsT); });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "pfind", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)((0, type_system_1.lam)(elemsT, type_system_1.bool), (0, PMaybe_1.PMaybe)(elemsT).type)); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "find", function (predicate) { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, PMaybe_1.PMaybe)(elemsT).type); });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "pfilter", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)((0, type_system_1.lam)(elemsT, type_system_1.bool), (0, type_system_1.list)(elemsT))); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "filter", function (predicate) { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.list)(elemsT)); });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "pprepend", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)(elemsT, (0, type_system_1.list)(elemsT))); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "prepend", function (elem) { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.list)(elemsT)); });
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "pmap", function (toType) { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)((0, type_system_1.lam)(elemsT, toType), (0, type_system_1.list)(toType))); });
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "map", function (f) {
        var predicateTy = f.type;
        if (!(predicateTy[0] === "lam" /* PrimType.Lambda */ &&
            (0, type_system_1.isWellFormedGenericType)(predicateTy[2])))
            throw new Error("can't map plu-ts fuction of type \"".concat(predicateTy, "\" over a _lst of type \"_lst(").concat((0, utils_1.termTypeToString)(elemsT), ")\""));
        return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.list)(predicateTy[2]));
    });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "pevery", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)((0, type_system_1.lam)(elemsT, type_system_1.bool), type_system_1.bool)); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "every", function (predicate) { return (0, mockPBoolMethods_1.makeMockTermBool)(); });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "psome", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)((0, type_system_1.lam)(elemsT, type_system_1.bool), type_system_1.bool)); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "some", function (predicate) { return (0, mockPBoolMethods_1.makeMockTermBool)(); });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "pincludes", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)(elemsT, type_system_1.bool)); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "includes", function (elem) { return (0, mockPBoolMethods_1.makeMockTermBool)(); });
    (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "peq", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)((0, type_system_1.list)(elemsT), type_system_1.bool)); } }, getterOnly));
    (0, obj_utils_1.defineReadOnlyProperty)(_lst, "eq", function (other) { return (0, mockPBoolMethods_1.makeMockTermBool)(); });
    if ((0, type_system_1.typeExtends)(elemsT, (0, type_system_1.pair)((0, type_system_1.tyVar)(), (0, type_system_1.tyVar)()))) {
        var kT_1 = (0, tyArgs_1.unwrapAsData)((0, tyArgs_1.getFstT)(elemsT));
        var vT = (0, tyArgs_1.unwrapAsData)((0, tyArgs_1.getSndT)(elemsT));
        var PMaybeVal_1 = (0, PMaybe_1.PMaybe)(vT);
        (0, obj_utils_1.definePropertyIfNotPresent)(_lst, "plookup", __assign({ get: function () { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)((0, type_system_1.lam)(kT_1, PMaybeVal_1.type)); } }, getterOnly));
        (0, obj_utils_1.defineReadOnlyProperty)(_lst, "lookup", function (key) { return (0, makeMockUtilityTerm_1.makeMockUtilityTerm)(PMaybeVal_1.type); });
    }
    return _lst;
}
