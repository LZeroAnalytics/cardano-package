import { PLam, PByteString, PBool, PInt, TermFn } from "../../../PTypes/index.js";
import { Term } from "../../../Term/index.js";
import { PappArg } from "../../pappArg.js";
import { TermBS } from "../../std/UtilityTerms/TermBS.js";
import { TermBool } from "../../std/UtilityTerms/TermBool.js";
import { TermInt } from "../../std/UtilityTerms/TermInt.js";
export type ByteStrBinOPToBS = Term<PLam<PByteString, PLam<PByteString, PByteString>>> & {
    $: (input: PappArg<PByteString>) => Term<PLam<PByteString, PByteString>> & {
        $: (input: PappArg<PByteString>) => TermBS;
    };
};
export type ByteStrBinOPToBool = Term<PLam<PByteString, PLam<PByteString, PBool>>> & {
    $: (input: PappArg<PByteString>) => Term<PLam<PByteString, PBool>> & {
        $: (input: PappArg<PByteString>) => TermBool;
    };
};
export declare const pappendBs: ByteStrBinOPToBS;
export declare const pconsBs: Term<PLam<PInt, PLam<PByteString, PByteString>>> & {
    $: (input: PappArg<PInt>) => Term<PLam<PByteString, PByteString>> & {
        $: (input: PappArg<PByteString>) => TermBS;
    };
};
export declare const flippedCons: Term<PLam<PByteString, PLam<PInt, PByteString>>> & {
    $: (input: PappArg<PByteString>) => Term<PLam<PInt, PByteString>> & {
        $: (input: PappArg<PInt>) => import("../../index.js").UtilityTermOf<PByteString>;
    };
};
export declare const psliceBs: Term<PLam<PInt, PLam<PInt, PLam<PByteString, PByteString>>>> & {
    $: (fromIndex: PappArg<PInt>) => Term<PLam<PInt, PLam<PByteString, PByteString>>> & {
        $: (ofLength: PappArg<PInt>) => Term<PLam<PByteString, PByteString>> & {
            $: (onByteString: PappArg<PByteString>) => TermBS;
        };
    };
};
export declare const plengthBs: TermFn<[PByteString], PInt>;
export declare const pindexBs: Term<PLam<PByteString, PLam<PInt, PInt>>> & {
    $: (ofByteString: PappArg<PByteString>) => Term<PLam<PInt, PInt>> & {
        $: (index: PappArg<PInt>) => TermInt;
    };
};
export declare const peqBs: ByteStrBinOPToBool;
export declare const plessBs: ByteStrBinOPToBool;
export declare const plessEqBs: ByteStrBinOPToBool;
export declare const pgreaterBS: ByteStrBinOPToBool;
export declare const pgreaterEqBS: ByteStrBinOPToBool;
export declare const psha2_256: TermFn<[PByteString], PByteString>;
export declare const psha3_256: TermFn<[PByteString], PByteString>;
export declare const pblake2b_256: TermFn<[PByteString], PByteString>;
/**
 * performs cryptographic signature verification using the Ed25519 scheme
 *
 * @param {PByteString} key ```PByteString``` of length 32 ( ```PubKeyHash``` )
 * @param {PByteString} message abitrary length ```PByteString```
 * @param {PByteString} signature ```PByteString``` of length 64
 * @returns {PBool}
 *
 * @throws
 * @fails
 */
export declare const pverifyEd25519: TermFn<[PByteString, PByteString, PByteString], PBool>;
/**
 * performs elliptic curve digital signature verification (ANSI [2005, 2020], Johnson and Menezes)
 * over the secp256k1 curve (see Certicom Research [2010], ¬ß2.4.1) and conforms to the interface described in
 * Note 5 of Section A.2. The arguments must have the following sizes:
 * ‚Ä¢ ùëò: 64 bytes
 * ‚Ä¢ ùëö: 32 bytes
 * ‚Ä¢ ùë†: 64 bytes.
 * The ECDSA scheme admits two distinct valid signatures for a given message and private key. We follow
 * the restriction imposed by Bitcoin (see Lau and Wuilie [2016], LOW_S) and only accept the smaller
 * signature: verifyEcdsaSecp256k1Signature will return false if the larger one is supplied.
 *
 * @param {PByteString} key ```PByteString``` of length 32 ( ```PubKeyHash``` )
 * @param {PByteString} message ```PByteString``` of length 32
 * @param {PByteString} signature ```PByteString``` of length 64
 * @returns {PBool}
 *
 * @throws
 * @fails
 */
export declare const pverifySecp256k1ECDSA: TermFn<[PByteString, PByteString, PByteString], PBool>;
/**
* performs verification of Schnorr signatures ( Schnorr [1989], Lau et al. [2020]) over the secp256k1 curve
*
* @param {PByteString} key ```PByteString``` of length 64
* @param {PByteString} message abitrary length ```PByteString```
* @param {PByteString} signature ```PByteString``` of length 64
* @returns {PBool}
*
* @throws
* @fails
*/
export declare const pverifySecp256k1Schnorr: TermFn<[PByteString, PByteString, PByteString], PBool>;
