"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakeCredentials = exports.StakeValidatorHash = void 0;
var cbor_1 = require("@harmoniclabs/cbor");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var Hash28_1 = require("../hashes/Hash28/Hash28.js");
var ints_1 = require("../utils/ints.js");
var PaymentCredentials_1 = require("./PaymentCredentials.js");
var StakeKeyHash_1 = require("./StakeKeyHash.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var assert_1 = require("../utils/assert.js");
var StakeValidatorHash = /** @class */ (function (_super) {
    __extends(StakeValidatorHash, _super);
    function StakeValidatorHash() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StakeValidatorHash;
}(Hash28_1.Hash28));
exports.StakeValidatorHash = StakeValidatorHash;
var StakeCredentials = /** @class */ (function () {
    function StakeCredentials(type, hash) {
        (0, assert_1.assert)(hash instanceof Hash28_1.Hash28, "can't construct 'StakeCredentials'; hash must be instance of an 'Hash28'");
        (0, assert_1.assert)(type === "stakeKey" || type === "script" || type === "pointer", "can't construct 'PaymentCredentials'; specified type is nor 'addres' nor 'script'");
        (0, obj_utils_1.defineReadOnlyProperty)(this, "type", type);
        if (type === "pointer") {
            if (!(Array.isArray(hash) &&
                hash.length === 3 &&
                hash.every(ints_1.canBeUInteger)))
                throw new Error("invalid argument for stake credentials of type " + type);
            (0, obj_utils_1.defineReadOnlyProperty)(this, "hash", hash.map(ints_1.forceBigUInt));
        }
        else {
            if (!(hash instanceof Hash28_1.Hash28))
                throw new Error("invalid argument for stake credentials of type " + type);
            (0, obj_utils_1.defineReadOnlyProperty)(this, "hash", type === "stakeKey" ?
                (hash instanceof StakeKeyHash_1.StakeKeyHash ? hash : new StakeKeyHash_1.StakeKeyHash(hash.asBytes)) :
                (hash instanceof StakeValidatorHash ? hash : new StakeValidatorHash(hash.asBytes)));
        }
    }
    StakeCredentials.prototype.clone = function () {
        return new StakeCredentials(this.type, this.hash);
    };
    StakeCredentials.prototype.toData = function () {
        if (this.type === "pointer") {
            return new plutus_data_1.DataConstr(1, // PStakingPtr
            this.hash
                .map(function (n) { return new plutus_data_1.DataI((0, ints_1.forceBigUInt)(n)); }));
        }
        return new plutus_data_1.DataConstr(0, // PStakingHash
        [
            new PaymentCredentials_1.PaymentCredentials(this.type === "stakeKey" ? "pubKey" : "script", this.hash).toData()
        ]);
    };
    StakeCredentials.prototype.toCbor = function () {
        return cbor_1.Cbor.encode(this.toCborObj());
    };
    StakeCredentials.prototype.toCborObj = function () {
        return new cbor_1.CborArray([
            new cbor_1.CborUInt(this.type === "stakeKey" ? 0 : 1),
            Array.isArray(this.hash) ?
                new cbor_1.CborArray(this.hash
                    .map(function (n) { return new cbor_1.CborUInt((0, ints_1.forceBigUInt)(n)); })) :
                this.hash.toCborObj()
        ]);
    };
    StakeCredentials.fromCbor = function (cObj) {
        return StakeCredentials.fromCborObj(cbor_1.Cbor.parse((0, cbor_1.forceCborString)(cObj)));
    };
    StakeCredentials.fromCborObj = function (cObj) {
        if (!(cObj instanceof cbor_1.CborArray))
            throw new Error("Invalid CBOR fromat for \"Certificate\"");
        var _a = __read(cObj.array, 2), _type = _a[0], _creds = _a[1];
        if (!(_type instanceof cbor_1.CborUInt))
            throw new Error("Invalid CBOR fromat for \"Certificate\"");
        if (!(_creds instanceof cbor_1.CborArray || _creds instanceof cbor_1.CborBytes))
            throw new Error("Invalid CBOR fromat for \"Certificate\"");
        if (_creds instanceof cbor_1.CborArray) {
            if (!_creds.array.every(function (n) { return n instanceof cbor_1.CborUInt; }))
                throw new Error("Invalid CBOR fromat for \"Certificate\"");
            return new StakeCredentials("pointer", _creds.array.map(function (n) { return n.num; }));
        }
        return new StakeCredentials(_type.num === BigInt(0) ? "stakeKey" : "script", Hash28_1.Hash28.fromCborObj(_creds));
    };
    StakeCredentials.prototype.toJson = function () {
        switch (this.type) {
            case "script":
                return {
                    type: "script",
                    hash: this.hash.toString()
                };
            case "stakeKey":
                return {
                    type: "stakeKey",
                    hash: this.hash.toString()
                };
            case "pointer":
                return {
                    type: "pointer",
                    pointer: this.hash
                        .map(function (n) { return (0, ints_1.forceBigUInt)(n).toString(); })
                };
            default:
                throw new Error("unknown stake credentials type");
        }
    };
    return StakeCredentials;
}());
exports.StakeCredentials = StakeCredentials;
