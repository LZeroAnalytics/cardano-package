"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleLetted = exports._handleLetted = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var IRApp_1 = require("../../../IRNodes/IRApp.js");
var IRFunc_1 = require("../../../IRNodes/IRFunc.js");
var IRLetted_1 = require("../../../IRNodes/IRLetted.js");
var IRVar_1 = require("../../../IRNodes/IRVar.js");
var _modifyChildFromTo_1 = require("../../_internal/_modifyChildFromTo.js");
var findAll_1 = require("../../_internal/findAll.js");
var getDebruijnInTerm_1 = require("../../_internal/getDebruijnInTerm.js");
var groupByScope_1 = require("./groupByScope.js");
var IRDelayed_1 = require("../../../IRNodes/IRDelayed.js");
var IRForced_1 = require("../../../IRNodes/IRForced.js");
var lowestCommonAncestor_1 = require("../../_internal/lowestCommonAncestor.js");
var isIRTerm_1 = require("../../../utils/isIRTerm.js");
var markRecursiveHoistsAsForced_1 = require("../markRecursiveHoistsAsForced.js");
var IRConst_1 = require("../../../IRNodes/IRConst.js");
var incrementUnboundDbns_1 = require("./incrementUnboundDbns.js");
var IRNodes_1 = require("../../../IRNodes/index.js");
function onlyLettedTerm(setEntry) {
    return setEntry.letted;
}
function lettedHash(_a) {
    var hash = _a.hash;
    return hash;
}
function lettedHashHex(_a) {
    var hash = _a.hash;
    return (0, uint8array_utils_1.toHex)(hash);
}
function _handleLetted(term) {
    var _a;
    // most of the time we are just compiling small
    // pre-execuded terms (hence constants)
    if (term instanceof IRConst_1.IRConst)
        return;
    // TODO: should probably merge `markRecursiveHoistsAsForced` inside `getLettedTerms` to iter once
    (0, markRecursiveHoistsAsForced_1.markRecursiveHoistsAsForced)(term);
    var allDirectLetted = (0, IRLetted_1.getLettedTerms)(term, { all: false, includeHoisted: false });
    // in case there are no letted terms there is no work to do
    if (allDirectLetted.length === 0)
        return;
    var allLettedRefs = (0, IRLetted_1.getLettedTerms)(term, { all: true, includeHoisted: false }).map(onlyLettedTerm);
    var sortedLettedSet = (0, IRLetted_1.getSortedLettedSet)(allDirectLetted);
    var allScopes = sortedLettedSet.map(function (_a) {
        var e_1, _b;
        var _c;
        var letted = _a.letted;
        var theHash = letted.hash;
        var allSameLetted = allLettedRefs.filter(function (_a) {
            var hash = _a.hash;
            return (0, uint8array_utils_1.uint8ArrayEq)(hash, theHash);
        });
        var scopes = new Array();
        var _loop_2 = function (letted_1) {
            var _maxScope = findLettedMaxScope(letted_1);
            var idx = scopes.findIndex(function (_a) {
                var maxScope = _a.maxScope;
                return maxScope === _maxScope;
            });
            if (idx < 0) {
                scopes.push({
                    maxScope: _maxScope,
                    lettedRefs: [letted_1],
                    forceHoist: letted_1.meta.forceHoist === true
                });
            }
            else {
                scopes[idx].lettedRefs.push(letted_1);
                (_c = scopes[idx]).forceHoist || (_c.forceHoist = letted_1.meta.forceHoist === true);
            }
        };
        try {
            for (var allSameLetted_1 = __values(allSameLetted), allSameLetted_1_1 = allSameLetted_1.next(); !allSameLetted_1_1.done; allSameLetted_1_1 = allSameLetted_1.next()) {
                var letted_1 = allSameLetted_1_1.value;
                _loop_2(letted_1);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (allSameLetted_1_1 && !allSameLetted_1_1.done && (_b = allSameLetted_1.return)) _b.call(allSameLetted_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return scopes;
    }).reduce(function (a, b) { return a.concat(b); });
    var _loop_1 = function () {
        var e_2, _b, e_3, _c;
        var _d = allScopes.pop(), maxScope = _d.maxScope, sameLettedRefs = _d.lettedRefs, forceHoist = _d.forceHoist;
        // const maxScope = findLettedMaxScope( lettedExampleElem );
        var setLettedHash = sameLettedRefs[0].hash;
        var lettedExampleElem = sameLettedRefs[0];
        if (!lettedExampleElem)
            return "continue";
        // inline single references
        if (!forceHoist &&
            sameLettedRefs.length <= 1) {
            (0, _modifyChildFromTo_1._modifyChildFromTo)(lettedExampleElem.parent, lettedExampleElem, lettedExampleElem.value);
            return "continue";
        }
        // always inline letted vars
        if (lettedExampleElem.value instanceof IRVar_1.IRVar) {
            try {
                for (var sameLettedRefs_1 = (e_2 = void 0, __values(sameLettedRefs)), sameLettedRefs_1_1 = sameLettedRefs_1.next(); !sameLettedRefs_1_1.done; sameLettedRefs_1_1 = sameLettedRefs_1.next()) {
                    var elem = sameLettedRefs_1_1.value;
                    // inline
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(elem.parent, elem, elem.value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (sameLettedRefs_1_1 && !sameLettedRefs_1_1.done && (_b = sameLettedRefs_1.return)) _b.call(sameLettedRefs_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return "continue";
        }
        var lca = sameLettedRefs[0];
        // if `froceHoist` is true;
        // we append directly to `maxScope`
        // hence no need to look for `lca`
        if (!forceHoist) {
            for (var j = 1; j < sameLettedRefs.length; j++) {
                lca = (0, lowestCommonAncestor_1.lowestCommonAncestor)(lca, sameLettedRefs[j], maxScope);
                if (!(0, isIRTerm_1.isIRTerm)(lca))
                    break;
            }
            if (!(0, isIRTerm_1.isIRTerm)(lca)) {
                // default to maxScope
                lca = maxScope;
                throw new Error("letting nodes with hash " + (0, uint8array_utils_1.toHex)(setLettedHash) + " from different trees");
            }
            else {
                // point to the first func or delay node above the lca
                // (worst case scenario we hit the maxScope; which is an IRFunc)
                while (!(lca instanceof IRFunc_1.IRFunc ||
                    lca instanceof IRDelayed_1.IRDelayed)) {
                    lca = (_a = lca === null || lca === void 0 ? void 0 : lca.parent) !== null && _a !== void 0 ? _a : undefined;
                    // if somehow we hit the root
                    if (!(0, isIRTerm_1.isIRTerm)(lca)) {
                        throw new Error("lowest common ancestor outside the max scope");
                    }
                }
            }
        }
        var parentNode = forceHoist ? maxScope : lca;
        var parentNodeDirectChild = parentNode instanceof IRFunc_1.IRFunc ? parentNode.body : parentNode.delayed;
        // add 1 to every var's DeBruijn that accesses stuff outside the parent node
        // not including the `parentNode` node
        // since the new function introdcued substituting the letted term
        // is added inside the `parentNode` node
        (0, incrementUnboundDbns_1.incrementUnboundDbns)(parentNodeDirectChild, 
        // shouldNotModifyLetted
        function (_a) {
            var hash = _a.hash;
            return (0, uint8array_utils_1.uint8ArrayEq)(hash, setLettedHash);
        });
        // get the difference in DeBruijn
        // between the maxScope and the letted term
        var diffDbn = 0; // getDiffDbn( parentNodeDirectChild, letted );
        //*
        var tmpNode = lettedExampleElem;
        while (tmpNode !== parentNode) {
            tmpNode = tmpNode.parent;
            if ( // is an intermediate `IRFunc`
            tmpNode instanceof IRFunc_1.IRFunc &&
                tmpNode !== parentNode // avoid counting parent node arity if IRFunc 
            ) {
                // increment differential in DeBruijn by n vars indroduced here
                diffDbn += tmpNode.arity;
            }
        }
        //*/
        // now we replace
        var lettedValue = lettedExampleElem.value.clone();
        // if there is any actual difference between the letted term
        // and the position where it will be finally placed
        // the value needs to be modified accoridingly
        if (diffDbn > 0) {
            var stack = [{ term: lettedValue, dbn: 0 }];
            while (stack.length > 0) {
                var _e = stack.pop(), t = _e.term, dbn = _e.dbn;
                if (t instanceof IRVar_1.IRVar &&
                    t.dbn > dbn) {
                    t.dbn -= diffDbn;
                }
                if (t instanceof IRLetted_1.IRLetted) {
                    t.dbn -= diffDbn;
                    // reduce dbn in letted value too
                    stack.push({ term: t.value, dbn: dbn });
                    continue;
                }
                if (t instanceof IRApp_1.IRApp) {
                    stack.push({ term: t.arg, dbn: dbn }, { term: t.fn, dbn: dbn });
                    continue;
                }
                if (t instanceof IRDelayed_1.IRDelayed) {
                    stack.push({ term: t.delayed, dbn: dbn });
                    continue;
                }
                if (t instanceof IRForced_1.IRForced) {
                    stack.push({ term: t.forced, dbn: dbn });
                    continue;
                }
                if (t instanceof IRFunc_1.IRFunc) {
                    stack.push({ term: t.body, dbn: dbn + t.arity });
                    continue;
                }
                // no hoisted
            }
        }
        // save parent so when replacing we don't create a circular sameLettedRefs
        var parent_1 = parentNode;
        var newNode = new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, parentNodeDirectChild), lettedValue);
        (0, _modifyChildFromTo_1._modifyChildFromTo)(parent_1, parentNodeDirectChild, // not really used since we know parent is not `IRApp`
        newNode);
        sameLettedRefs = (0, findAll_1.findAllNoHoisted)(parentNodeDirectChild, function (term) {
            return term instanceof IRLetted_1.IRLetted &&
                (sameLettedRefs.includes(term) ||
                    sameLettedRefs.some(function (_a) {
                        var hash = _a.hash;
                        return (0, uint8array_utils_1.uint8ArrayEq)(hash, setLettedHash);
                    }));
        });
        try {
            for (var sameLettedRefs_2 = (e_3 = void 0, __values(sameLettedRefs)), sameLettedRefs_2_1 = sameLettedRefs_2.next(); !sameLettedRefs_2_1.done; sameLettedRefs_2_1 = sameLettedRefs_2.next()) {
                var ref = sameLettedRefs_2_1.value;
                if (isChildOf(ref, parentNodeDirectChild)) {
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(ref.parent, ref, new IRVar_1.IRVar((0, getDebruijnInTerm_1.getDebruijnInTerm)(parentNodeDirectChild, ref)));
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (sameLettedRefs_2_1 && !sameLettedRefs_2_1.done && (_c = sameLettedRefs_2.return)) _c.call(sameLettedRefs_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    // needs to go from last to first so that letted terms' hashes will not change
    // (aka. we replace dependents before dependecies)
    while (allScopes.length > 0) {
        _loop_1();
    }
}
exports._handleLetted = _handleLetted;
function handleLetted(term) {
    var _a;
    // console.log(" ------------------------------------------- handleLetted ------------------------------------------- ");
    // console.log( prettyIRJsonStr( term ))
    // most of the time we are just compiling small
    // pre-execuded terms (hence constants)
    if (term instanceof IRConst_1.IRConst)
        return;
    // TODO: should probably merge `markRecursiveHoistsAsForced` inside `getLettedTerms` to iter once
    (0, markRecursiveHoistsAsForced_1.markRecursiveHoistsAsForced)(term);
    var _loop_3 = function () {
        var e_4, _b, e_5, _c;
        var allDirectLetted = (0, IRLetted_1.getLettedTerms)(term, { all: false, includeHoisted: false });
        // console.log("found ", allDirectLetted.length, "letted terms");
        // in case there are no letted terms there is no work to do
        if (allDirectLetted.length === 0)
            return { value: void 0 };
        var sortedLettedSet = (0, IRLetted_1.getSortedLettedSet)(allDirectLetted);
        var _d = sortedLettedSet.pop(), letted = _d.letted, nReferences = _d.nReferences;
        // console.log(` ------------------ working with ${lettedToStr(letted)} ------------------ `);
        if (nReferences === 1) {
            // console.log("inlining letted (single reference) with value", prettyIRText( letted.value ) )
            (0, _modifyChildFromTo_1._modifyChildFromTo)(letted.parent, letted, letted.value);
            return "continue";
        }
        var maxScope = findLettedMaxScope(letted);
        var lettedHash_1 = letted.hash;
        var sameLettedRefs = (0, findAll_1.findAllNoHoisted)(maxScope, function (node) {
            return node instanceof IRLetted_1.IRLetted &&
                (0, uint8array_utils_1.uint8ArrayEq)(node.hash, lettedHash_1);
        });
        // console.log("found ", sameLettedRefs.length, "references of the letted terms");
        // just in case
        if (sameLettedRefs.length === 1) {
            // console.log("inlining letted (single reference pedantic) with value", prettyIRText( letted.value ) )
            (0, _modifyChildFromTo_1._modifyChildFromTo)(letted.parent, letted, letted.value);
            return "continue";
        }
        // always inline letted vars
        if (letted.value instanceof IRVar_1.IRVar) {
            try {
                // console.log("inlining letted (value is var) with value", prettyIRText( letted.value ) )
                for (var sameLettedRefs_3 = (e_4 = void 0, __values(sameLettedRefs)), sameLettedRefs_3_1 = sameLettedRefs_3.next(); !sameLettedRefs_3_1.done; sameLettedRefs_3_1 = sameLettedRefs_3.next()) {
                    var elem = sameLettedRefs_3_1.value;
                    // inline
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(elem.parent, elem, elem.value);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (sameLettedRefs_3_1 && !sameLettedRefs_3_1.done && (_b = sameLettedRefs_3.return)) _b.call(sameLettedRefs_3);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return "continue";
        }
        var lca = sameLettedRefs[0];
        var forceHoist = sameLettedRefs.some(function (letted) { return letted.meta.forceHoist === true; });
        // if `froceHoist` is true;
        // we append directly to `maxScope`
        // hence no need to look for `lca`
        if (!forceHoist) {
            for (var j = 1; j < sameLettedRefs.length; j++) {
                lca = (0, lowestCommonAncestor_1.lowestCommonAncestor)(lca, sameLettedRefs[j], maxScope);
                if (!(0, isIRTerm_1.isIRTerm)(lca))
                    break;
            }
            if (!(0, isIRTerm_1.isIRTerm)(lca)) {
                // default to maxScope
                // lca = maxScope;
                throw new Error("letting nodes with hash " + (0, uint8array_utils_1.toHex)(lettedHash_1) + " from different trees");
            }
            else {
                // point to the first func or delay node above the lca
                // (worst case scenario we hit the maxScope; which is an IRFunc)
                while (!(lca instanceof IRFunc_1.IRFunc ||
                    lca instanceof IRDelayed_1.IRDelayed)) {
                    lca = (_a = lca === null || lca === void 0 ? void 0 : lca.parent) !== null && _a !== void 0 ? _a : undefined;
                    // if somehow we hit the root
                    if (!(0, isIRTerm_1.isIRTerm)(lca)) {
                        throw new Error("lowest common ancestor outside the max scope");
                    }
                }
            }
        }
        var parentNode = forceHoist ? maxScope : lca;
        var parentNodeDirectChild = parentNode instanceof IRFunc_1.IRFunc ? parentNode.body : parentNode.delayed;
        // add 1 to every var's DeBruijn that accesses stuff outside the parent node
        // not including the `parentNode` node
        // since the new function introdcued substituting the letted term
        // is added inside the `parentNode` node
        (0, incrementUnboundDbns_1.incrementUnboundDbns)(parentNodeDirectChild, 
        // `shouldNotModifyLetted` arg (given the hash returns `true` if it should NOT modify the term)
        function (_a) {
            var hash = _a.hash;
            return (0, uint8array_utils_1.uint8ArrayEq)(hash, lettedHash_1);
        });
        // get the difference in DeBruijn
        // between the maxScope and the letted term
        var diffDbn = 0; // getDiffDbn( parentNodeDirectChild, letted );
        //*
        var tmpNode = letted;
        while (tmpNode !== parentNode) {
            tmpNode = tmpNode.parent;
            if ( // is an intermediate `IRFunc`
            tmpNode instanceof IRFunc_1.IRFunc &&
                tmpNode !== parentNode // avoid counting parent node arity if IRFunc 
            ) {
                // increment differential in DeBruijn by n vars indroduced here
                diffDbn += tmpNode.arity;
            }
        }
        //*/
        // now we replace
        var lettedValue = letted.value.clone();
        // if there is any actual difference between the letted term
        // and the position where it will be finally placed
        // the value needs to be modified accoridingly
        if (diffDbn > 0) {
            var stack = [{ term: lettedValue, dbn: 0 }];
            while (stack.length > 0) {
                var _e = stack.pop(), t = _e.term, dbn = _e.dbn;
                if (t instanceof IRVar_1.IRVar &&
                    t.dbn > dbn) {
                    t.dbn -= diffDbn;
                }
                if (t instanceof IRLetted_1.IRLetted) {
                    t.dbn -= diffDbn;
                    // reduce dbn in letted value too
                    stack.push({ term: t.value, dbn: dbn });
                    continue;
                }
                if (t instanceof IRApp_1.IRApp) {
                    stack.push({ term: t.arg, dbn: dbn }, { term: t.fn, dbn: dbn });
                    continue;
                }
                if (t instanceof IRDelayed_1.IRDelayed) {
                    stack.push({ term: t.delayed, dbn: dbn });
                    continue;
                }
                if (t instanceof IRForced_1.IRForced) {
                    stack.push({ term: t.forced, dbn: dbn });
                    continue;
                }
                if (t instanceof IRFunc_1.IRFunc) {
                    stack.push({ term: t.body, dbn: dbn + t.arity });
                    continue;
                }
                // no hoisted
            }
        }
        var newNode = new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, parentNodeDirectChild), lettedValue, { __src__: letted.meta.__src__ });
        // replace child with new node
        if (parentNode instanceof IRFunc_1.IRFunc)
            parentNode.body = newNode;
        else
            parentNode.delayed = newNode;
        try {
            // console.log("replacing letted with value", prettyIRText( letted.value ) )
            for (var sameLettedRefs_4 = (e_5 = void 0, __values(sameLettedRefs)), sameLettedRefs_4_1 = sameLettedRefs_4.next(); !sameLettedRefs_4_1.done; sameLettedRefs_4_1 = sameLettedRefs_4.next()) {
                var ref = sameLettedRefs_4_1.value;
                (0, _modifyChildFromTo_1._modifyChildFromTo)(ref.parent, ref, new IRVar_1.IRVar((0, getDebruijnInTerm_1.getDebruijnInTerm)(parentNodeDirectChild, ref)));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (sameLettedRefs_4_1 && !sameLettedRefs_4_1.done && (_c = sameLettedRefs_4.return)) _c.call(sameLettedRefs_4);
            }
            finally { if (e_5) throw e_5.error; }
        }
        var delayed = parentNode instanceof IRDelayed_1.IRDelayed;
        var finalMaxScope = parentNode;
        while (!(finalMaxScope instanceof IRFunc_1.IRFunc)) {
            finalMaxScope = finalMaxScope.parent;
        }
    };
    while (true) {
        var state_1 = _loop_3();
        if (typeof state_1 === "object")
            return state_1.value;
    }
}
exports.handleLetted = handleLetted;
function remove(array, shouldRemove) {
    for (var i = 0; i < array.length; i++) {
        if (shouldRemove(array[i], i)) {
            array.splice(i, 1);
        }
    }
}
function removeFirst(array, shouldRemove) {
    for (var i = 0; i < array.length; i++) {
        if (shouldRemove(array[i], i)) {
            array.splice(i, 1);
            break;
        }
    }
}
function removeIdx(array, idx) {
    array.slice(idx, 1);
}
function filterWithIndex(array, predicate) {
    return array.map(function (elem, i) { return ({ elem: elem, i: i }); }).filter(function (_a) {
        var elem = _a.elem, i = _a.i;
        return predicate(elem, i);
    });
}
function isChildOf(child, parent) {
    do {
        if (!child)
            return false;
        if (child === parent)
            return true;
    } while (child = child === null || child === void 0 ? void 0 : child.parent);
    return false;
}
function hasChild(parent, child) {
    if (child === parent)
        return true;
    if (parent instanceof IRApp_1.IRApp)
        return hasChild(parent.fn, child) || hasChild(parent.arg, child);
    if (parent instanceof IRDelayed_1.IRDelayed)
        return hasChild(parent.delayed, child);
    if (parent instanceof IRForced_1.IRForced)
        return hasChild(parent.forced, child);
    if (parent instanceof IRFunc_1.IRFunc)
        return hasChild(parent.body, child);
    if (parent instanceof IRLetted_1.IRLetted)
        return hasChild(parent.value, child);
    if (parent instanceof IRNodes_1.IRHoisted)
        return hasChild(parent.hoisted, child);
    return false;
}
/**
 *
 * @param letted
 * @returns {IRFunc} the lowest `IRFunc` in the tree that defines all the variables needed for the
 */
function findLettedMaxScope(letted) {
    var minUnboundDbn = (0, groupByScope_1._getMinUnboundDbn)(letted.value);
    if (minUnboundDbn === undefined) {
        var tmp_1 = letted;
        var maxScope_1 = undefined;
        while (tmp_1.parent) {
            tmp_1 = tmp_1.parent;
            if (tmp_1 instanceof IRFunc_1.IRFunc)
                maxScope_1 = tmp_1;
        }
        ;
        if (!maxScope_1)
            throw new Error("could not find a max scope for letted value with hash ".concat((0, uint8array_utils_1.toHex)(letted.hash)));
        return maxScope_1;
    }
    var tmp = letted;
    var maxScope = undefined;
    while (minUnboundDbn >= 0) {
        if (!tmp.parent) {
            throw new Error("could not find a max scope for letted value with hash ".concat((0, uint8array_utils_1.toHex)(letted.hash), "; ") +
                "the max parent found leaves the term open (reached root)");
        }
        tmp = tmp.parent;
        if (tmp instanceof IRFunc_1.IRFunc) {
            minUnboundDbn -= tmp.arity;
            maxScope = tmp;
        }
    }
    // just ts sillyness here
    if (!maxScope) {
        throw new Error("could not find a max scope for letted value with hash ".concat((0, uint8array_utils_1.toHex)(letted.hash), "; ") +
            "no IRFunc found");
    }
    return maxScope;
}
