import { UPLCTerm, UPLCConst, ErrorUPLC, UPLCBuiltinTag } from "@harmoniclabs/uplc";
import { BuiltinCostsOf } from "../Machine/BuiltinCosts/BuiltinCosts.js";
import { ExBudget } from "../Machine/ExBudget.js";
import { PartialBuiltin } from "./PartialBuiltin.js";
export declare function haskellQuot(a: bigint, b: bigint): bigint | undefined;
export declare function haskellRem(a: bigint, b: bigint): bigint | undefined;
export declare function haskellDiv(a: bigint, b: bigint): bigint | undefined;
export declare function haskellMod(a: bigint, b: bigint): bigint | undefined;
type ConstOrErr = UPLCConst | ErrorUPLC;
export declare class BnCEK {
    readonly getBuiltinCostFunc: <Tag extends UPLCBuiltinTag>(tag: Tag) => BuiltinCostsOf<Tag>;
    readonly logs: string[];
    /**
     * **reference** to the budget of the actual machine
    **/
    readonly machineBudget: ExBudget;
    constructor(getBuiltinCostFunc: <Tag extends UPLCBuiltinTag>(tag: Tag) => BuiltinCostsOf<Tag>, machineBudget: ExBudget, logs: string[]);
    eval(bn: PartialBuiltin): ConstOrErr;
    addInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    subtractInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    multiplyInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    divideInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    quotientInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    remainderInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    modInteger(_a: UPLCTerm, _b: UPLCTerm): ConstOrErr;
    equalsInteger(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    lessThanInteger(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    lessThanEqualInteger(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    appendByteString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    consByteString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    sliceByteString(fromIdx: UPLCTerm, ofLength: UPLCTerm, bs: UPLCTerm): ConstOrErr;
    lengthOfByteString(bs: UPLCTerm): ConstOrErr;
    indexByteString(bs: UPLCTerm, idx: UPLCTerm): ConstOrErr;
    equalsByteString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    lessThanByteString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    lessThanEqualsByteString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    sha2_256(stuff: UPLCTerm): ConstOrErr;
    sha3_256(stuff: UPLCTerm): ConstOrErr;
    blake2b_256(stuff: UPLCTerm): ConstOrErr;
    verifyEd25519Signature(key: UPLCTerm, message: UPLCTerm, signature: UPLCTerm): ConstOrErr;
    appendString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    equalsString(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    encodeUtf8(a: UPLCTerm): ConstOrErr;
    decodeUtf8(a: UPLCTerm): ConstOrErr;
    ifThenElse(condition: UPLCTerm, caseTrue: ConstOrErr, caseFalse: ConstOrErr): ConstOrErr;
    chooseUnit(unit: UPLCTerm, b: UPLCTerm): UPLCTerm;
    trace(msg: UPLCConst, result: UPLCTerm): UPLCTerm;
    fstPair(pair: UPLCTerm): ConstOrErr;
    sndPair(pair: UPLCTerm): ConstOrErr;
    chooseList(list: UPLCTerm, whateverA: UPLCTerm, whateverB: UPLCTerm): UPLCTerm;
    mkCons(elem: UPLCTerm, list: UPLCTerm): UPLCConst | ErrorUPLC;
    headList(list: UPLCTerm): ConstOrErr;
    tailList(list: UPLCTerm): ConstOrErr;
    nullList(list: UPLCTerm): ConstOrErr;
    chooseData(data: UPLCTerm, constr: UPLCTerm, map: UPLCTerm, list: UPLCTerm, int: UPLCTerm, bs: UPLCTerm): ConstOrErr;
    constrData(idx: UPLCTerm, fields: UPLCTerm): ConstOrErr;
    mapData(listOfPair: UPLCTerm): ConstOrErr;
    listData(listOfData: UPLCTerm): ConstOrErr;
    iData(int: UPLCTerm): ConstOrErr;
    bData(bs: UPLCTerm): ConstOrErr;
    unConstrData(data: UPLCTerm): ConstOrErr;
    unMapData(data: UPLCTerm): ConstOrErr;
    unListData(data: UPLCTerm): ConstOrErr;
    unIData(data: UPLCTerm): ConstOrErr;
    unBData(data: UPLCTerm): ConstOrErr;
    equalsData(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    mkPairData(a: UPLCTerm, b: UPLCTerm): ConstOrErr;
    mkNilData(unit: UPLCTerm): ConstOrErr;
    mkNilPairData(unit: UPLCTerm): ConstOrErr;
    serialiseData(data: UPLCTerm): ConstOrErr;
}
export {};
