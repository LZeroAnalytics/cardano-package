"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nativeToIR = void 0;
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var types_1 = require("../../../../pluts/type_system/types.js");
var IRApp_1 = require("../../../IRNodes/IRApp.js");
var IRConst_1 = require("../../../IRNodes/IRConst.js");
var IRDelayed_1 = require("../../../IRNodes/IRDelayed.js");
var IRForced_1 = require("../../../IRNodes/IRForced.js");
var IRFunc_1 = require("../../../IRNodes/IRFunc.js");
var IRHoisted_1 = require("../../../IRNodes/IRHoisted.js");
var IRNative_1 = require("../../../IRNodes/IRNative/index.js");
var IRVar_1 = require("../../../IRNodes/IRVar.js");
var _ir_apps_1 = require("../../../tree_utils/_ir_apps.js");
var innerZ = new IRFunc_1.IRFunc(1, new IRApp_1.IRApp(new IRVar_1.IRVar(1), // Z
new IRFunc_1.IRFunc(1, new IRApp_1.IRApp(new IRApp_1.IRApp(new IRVar_1.IRVar(1), // toMakeRecursive
new IRVar_1.IRVar(1) // toMakeRecursive ( self )
), new IRVar_1.IRVar(0) // first argument (other than self)
))));
var hoisted_z_comb = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, new IRApp_1.IRApp(innerZ.clone(), innerZ.clone())));
var hoisted_matchList = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(3, new IRForced_1.IRForced((0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.strictChooseList, new IRVar_1.IRVar(0), // list, last argument of IRFunc above
new IRVar_1.IRVar(2), // matchNil (`delayed( resultT )`)
new IRDelayed_1.IRDelayed((0, _ir_apps_1._ir_apps)(new IRVar_1.IRVar(1), // matchCons
new IRApp_1.IRApp(IRNative_1.IRNative.headList, new IRVar_1.IRVar(0) // list
), new IRApp_1.IRApp(IRNative_1.IRNative.tailList, new IRVar_1.IRVar(0) // list
)))))));
var hoisted_lazyIfThenElse = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(3, // condition, delayed_caseTrue, delayed_caseFalse
new IRForced_1.IRForced((0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.strictIfThenElse, new IRVar_1.IRVar(2), // condition
new IRVar_1.IRVar(1), // delayed_caseTrue
new IRVar_1.IRVar(0) // delayed_caseFalse
))));
var hoisted_dropList = new IRHoisted_1.IRHoisted(new IRApp_1.IRApp(hoisted_z_comb.clone(), new IRFunc_1.IRFunc(3, // self, lst, n
new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, // tailOfTheList (pletted)
(0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.equalsInteger, new IRConst_1.IRConst(types_1.int, 1), // constant 1
new IRVar_1.IRVar(1) // n
), 
// then
new IRVar_1.IRVar(0), // tailOfTheList
// else
(0, _ir_apps_1._ir_apps)(new IRVar_1.IRVar(3), // self
(0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.subtractInteger, new IRVar_1.IRVar(1), // n
new IRConst_1.IRConst(types_1.int, 1)), new IRVar_1.IRVar(0) // tailOfTheList
))), new IRApp_1.IRApp(IRNative_1.IRNative.tailList, new IRVar_1.IRVar(1) // lst
)))));
var hoisted_recursiveList = new IRHoisted_1.IRHoisted(new IRApp_1.IRApp(hoisted_z_comb.clone(), new IRFunc_1.IRFunc(4, // self, matchNil, mathcCons, lst
new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, // finalSelf
(0, _ir_apps_1._ir_apps)(hoisted_matchList.clone(), new IRApp_1.IRApp(new IRVar_1.IRVar(3), // matchNil
new IRVar_1.IRVar(0) // finalSelf
), new IRApp_1.IRApp(new IRVar_1.IRVar(2), // matchCons,
new IRVar_1.IRVar(0) // finalSelf
), new IRVar_1.IRVar(1))), (0, _ir_apps_1._ir_apps)(new IRVar_1.IRVar(3), // self
new IRVar_1.IRVar(2), // matchNil
new IRVar_1.IRVar(1) // matchCons
)))));
var hoisted_lazyOr = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
(0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), new IRVar_1.IRVar(1), // a
new IRConst_1.IRConst(types_1.bool, true), // a == true  -> true
new IRVar_1.IRVar(0) // a == false -> whatever b is
)));
var hoisted_lazyAnd = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
(0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), new IRVar_1.IRVar(1), // a
new IRVar_1.IRVar(0), // a == true  -> whatever b is
new IRConst_1.IRConst(types_1.bool, false) // a == false -> false
)));
var hoisted_foldr = new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // reduceFunc, accmulator
(0, _ir_apps_1._ir_apps)(hoisted_recursiveList.clone(), new IRFunc_1.IRFunc(1, // _self
new IRDelayed_1.IRDelayed(new IRVar_1.IRVar(1))), new IRFunc_1.IRFunc(3, // self, head, tail
(0, _ir_apps_1._ir_apps)(new IRVar_1.IRVar(4), // reduceFunc ( up to 2 are of callback, 3 is accum, 4 is reduce )
new IRVar_1.IRVar(1), // head
// strictly evaluated
// recursive call happens before this `reduce` call
new IRApp_1.IRApp(new IRVar_1.IRVar(2), // self
new IRVar_1.IRVar(0) // tail
))))));
function nativeToIR(native) {
    // positive natives are translated to uplc builtins (no need to hoist)
    if (native.tag >= 0)
        return native;
    switch (native.tag) {
        case -1 /* IRNativeTag.z_comb */:
            return hoisted_z_comb.clone();
            break;
        case -2 /* IRNativeTag._matchList */:
            return hoisted_matchList.clone();
            break;
        case -3 /* IRNativeTag._recursiveList */:
            return hoisted_recursiveList.clone();
            break;
        case -4 /* IRNativeTag._dropList */:
            return hoisted_dropList.clone();
            break;
        case -5 /* IRNativeTag._indexList */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(3, // self, lst, n
            (0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.equalsInteger, new IRConst_1.IRConst(types_1.int, 0), // constant 0
            new IRVar_1.IRVar(0) // n
            ), 
            // then
            new IRApp_1.IRApp(IRNative_1.IRNative.headList, new IRVar_1.IRVar(1)), 
            // else
            new IRApp_1.IRApp(// drop n and take head
            IRNative_1.IRNative.headList, (0, _ir_apps_1._ir_apps)(hoisted_dropList.clone(), new IRVar_1.IRVar(1), // list
            new IRVar_1.IRVar(0) // n
            )))));
            break;
        case -6 /* IRNativeTag._foldr */:
            return hoisted_foldr.clone();
            break;
        case -7 /* IRNativeTag._foldl */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // reduceFunc
            new IRApp_1.IRApp(hoisted_z_comb.clone(), new IRFunc_1.IRFunc(2, // self, accum
            (0, _ir_apps_1._ir_apps)(hoisted_matchList.clone(), new IRDelayed_1.IRDelayed(new IRVar_1.IRVar(0)), // pdelay( accum )
            new IRFunc_1.IRFunc(2, // head, tail
            (0, _ir_apps_1._ir_apps)(new IRVar_1.IRVar(3), // self
            // compute new accumoulator before proceeding
            (0, _ir_apps_1._ir_apps)(new IRVar_1.IRVar(4), // reduceFunc
            new IRVar_1.IRVar(2), // accum
            new IRVar_1.IRVar(1)), new IRVar_1.IRVar(0) // tail
            )))))));
            break;
        case -8 /* IRNativeTag._mkFind */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // elemToData, predicate
            new IRApp_1.IRApp(hoisted_z_comb.clone(), new IRFunc_1.IRFunc(2, // self, list
            (0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), new IRApp_1.IRApp(IRNative_1.IRNative.nullList, new IRVar_1.IRVar(0) // list
            ), 
            // then
            // Nothing data
            new IRConst_1.IRConst(types_1.data, new plutus_data_1.DataConstr(1, []) // Nothing is the second contructor
            ), 
            // else
            new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, // head (pletted)
            (0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), new IRApp_1.IRApp(new IRVar_1.IRVar(3), // predicate
            new IRVar_1.IRVar(0) // head
            ), 
            // then
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.constrData, new IRConst_1.IRConst(types_1.int, 0), // just contructor
            new IRApp_1.IRApp(new IRVar_1.IRVar(4), // elemToData
            new IRVar_1.IRVar(0) // head
            )))), new IRApp_1.IRApp(IRNative_1.IRNative.headList, new IRVar_1.IRVar(0) // list
            )))))));
            break;
        case -9 /* IRNativeTag._length */:
            return new IRHoisted_1.IRHoisted(new IRApp_1.IRApp(hoisted_z_comb.clone(), new IRFunc_1.IRFunc(2, // self, list
            (0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), new IRApp_1.IRApp(IRNative_1.IRNative.nullList, new IRVar_1.IRVar(0) // list
            ), 
            // then
            new IRConst_1.IRConst(types_1.int, 0), 
            // else
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.addInteger, new IRConst_1.IRConst(types_1.int, 1), new IRApp_1.IRApp(new IRVar_1.IRVar(1), // self
            new IRApp_1.IRApp(// list.tail
            IRNative_1.IRNative.tailList, new IRVar_1.IRVar(0) // list
            )))))));
            break;
        case -10 /* IRNativeTag._some */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // predicate
            (0, _ir_apps_1._ir_apps)(hoisted_recursiveList.clone(), new IRFunc_1.IRFunc(1, // _self
            new IRDelayed_1.IRDelayed(// pdelay( pBool( true ) )
            new IRConst_1.IRConst(types_1.bool, false))), new IRFunc_1.IRFunc(3, // self, head, tail
            (0, _ir_apps_1._ir_apps)(hoisted_lazyOr.clone(), // lazy in second
            new IRApp_1.IRApp(new IRVar_1.IRVar(3), // predicate ( 0, 1, 2 are of callback, 3 is predicate )
            new IRVar_1.IRVar(1)), new IRDelayed_1.IRDelayed(new IRApp_1.IRApp(new IRVar_1.IRVar(2), // self
            new IRVar_1.IRVar(0) // tail
            )))))));
            break;
        case -11 /* IRNativeTag._every */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // predicate
            (0, _ir_apps_1._ir_apps)(hoisted_recursiveList.clone(), new IRFunc_1.IRFunc(1, // _self
            new IRDelayed_1.IRDelayed(// pdelay( pBool( true ) )
            new IRConst_1.IRConst(types_1.bool, true))), new IRFunc_1.IRFunc(3, // self, head, tail
            (0, _ir_apps_1._ir_apps)(hoisted_lazyAnd.clone(), // lazy in second
            new IRApp_1.IRApp(new IRVar_1.IRVar(3), // predicate ( 0, 1, 2 are of callback, 3 is predicate )
            new IRVar_1.IRVar(1)), new IRDelayed_1.IRDelayed(new IRApp_1.IRApp(new IRVar_1.IRVar(2), // self
            new IRVar_1.IRVar(0) // tail
            )))))));
            break;
        case -12 /* IRNativeTag._mkFilter */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // pnilOfType, predicate
            (0, _ir_apps_1._ir_apps)(hoisted_foldr.clone(), new IRFunc_1.IRFunc(2, // elem, accum
            (0, _ir_apps_1._ir_apps)(hoisted_lazyIfThenElse.clone(), new IRApp_1.IRApp(new IRVar_1.IRVar(2), // predicate
            new IRVar_1.IRVar(1) // elem
            ), 
            // then
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.mkCons, new IRVar_1.IRVar(1), // elem
            new IRVar_1.IRVar(0) // accum
            ), 
            // else
            // filter out this element
            new IRVar_1.IRVar(0) // accum
            )), 
            // initial accum
            new IRVar_1.IRVar(3) // pnilOfType
            )));
            break;
        // case IRNativeTag._fstPair       :
        //     return new IRHoisted();
        // break;
        // case IRNativeTag._sndPair       :
        //     return new IRHoisted();
        // break;
        case -15 /* IRNativeTag._id */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, new IRVar_1.IRVar(0)));
            break;
        case -16 /* IRNativeTag._not */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // someBool
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.strictIfThenElse, new IRVar_1.IRVar(0), // someBool
            new IRConst_1.IRConst(types_1.bool, false), // someBool == true  -> false
            new IRConst_1.IRConst(types_1.bool, true) // someBool == false -> true 
            )));
            break;
        case -17 /* IRNativeTag._strictAnd */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.strictIfThenElse, new IRVar_1.IRVar(1), // a
            new IRVar_1.IRVar(0), // a == true  -> whatever b is
            new IRConst_1.IRConst(types_1.bool, false) // a == false -> false
            )));
            break;
        case -18 /* IRNativeTag._and */:
            return hoisted_lazyAnd.clone();
            break;
        case -19 /* IRNativeTag._strictOr */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.strictIfThenElse, new IRVar_1.IRVar(1), // a
            new IRConst_1.IRConst(types_1.bool, true), // a == true  -> true
            new IRVar_1.IRVar(0) // a == false -> whatever b is
            )));
            break;
        case -20 /* IRNativeTag._or */:
            return hoisted_lazyOr.clone();
            break;
        case -21 /* IRNativeTag._gtBS */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.lessThanByteString, new IRVar_1.IRVar(0), // b
            new IRVar_1.IRVar(1))));
            break;
        case -22 /* IRNativeTag._gtEqBS */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.lessThanEqualsByteString, new IRVar_1.IRVar(0), // b
            new IRVar_1.IRVar(1))));
            break;
        case -23 /* IRNativeTag._gtInt */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.lessThanInteger, new IRVar_1.IRVar(0), // b
            new IRVar_1.IRVar(1))));
            break;
        case -24 /* IRNativeTag._gtEqInt */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(2, // a, b
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.lessThanEqualInteger, new IRVar_1.IRVar(0), // b
            new IRVar_1.IRVar(1))));
            break;
        case -25 /* IRNativeTag._strToData */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // str
            new IRApp_1.IRApp(IRNative_1.IRNative.bData, new IRApp_1.IRApp(IRNative_1.IRNative.encodeUtf8, new IRVar_1.IRVar(0) // str
            ))));
            break;
        case -26 /* IRNativeTag._pairDataToData */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // pair
            new IRApp_1.IRApp(IRNative_1.IRNative.listData, (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.mkCons, new IRApp_1.IRApp(IRNative_1.IRNative.fstPair, new IRVar_1.IRVar(0)), (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.mkCons, new IRApp_1.IRApp(IRNative_1.IRNative.sndPair, new IRVar_1.IRVar(0)), new IRApp_1.IRApp(IRNative_1.IRNative.mkNilData, new IRConst_1.IRConst(types_1.unit, undefined)))))));
            break;
        case -27 /* IRNativeTag._strFromData */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // data
            new IRApp_1.IRApp(IRNative_1.IRNative.decodeUtf8, new IRApp_1.IRApp(IRNative_1.IRNative.unBData, new IRVar_1.IRVar(0) // data
            ))));
            break;
        case -28 /* IRNativeTag._pairDataFromData */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(1, // data
            new IRApp_1.IRApp(new IRFunc_1.IRFunc(1, // unlisted_data
            (0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.mkPairData, new IRApp_1.IRApp(IRNative_1.IRNative.headList, new IRVar_1.IRVar(0) // unlised_data
            ), new IRApp_1.IRApp(IRNative_1.IRNative.headList, new IRApp_1.IRApp(IRNative_1.IRNative.tailList, new IRVar_1.IRVar(0) // unlised_data
            )))), new IRApp_1.IRApp(IRNative_1.IRNative.unListData, new IRVar_1.IRVar(0) // data
            ))));
            break;
        case -29 /* IRNativeTag._lazyChooseList */:
            return new IRHoisted_1.IRHoisted(new IRFunc_1.IRFunc(3, // list, delayed_caseNil, delayed_caseCons
            new IRForced_1.IRForced((0, _ir_apps_1._ir_apps)(IRNative_1.IRNative.strictChooseList, new IRVar_1.IRVar(2), new IRVar_1.IRVar(1), new IRVar_1.IRVar(0)))));
            break;
        case -30 /* IRNativeTag._lazyIfThenElse */:
            return hoisted_lazyIfThenElse.clone();
            break;
        default: throw new Error("unknown (negative) native calling 'nativeToIR'");
    }
}
exports.nativeToIR = nativeToIR;
