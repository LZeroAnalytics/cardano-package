"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneHoistedSetEntry = exports.getHoistedTerms = exports.getSortedHoistedSet = exports.IRHoisted = void 0;
var IRDelayed_1 = require("./IRDelayed.js");
var showIR_1 = require("../utils/showIR.js");
var crypto_1 = require("@harmoniclabs/crypto");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var BasePlutsError_1 = require("../../utils/BasePlutsError.js");
var concatUint8Arr_1 = require("../utils/concatUint8Arr.js");
var isClosedIRTerm_1 = require("../utils/isClosedIRTerm.js");
var IRApp_1 = require("./IRApp.js");
var IRForced_1 = require("./IRForced.js");
var IRFunc_1 = require("./IRFunc.js");
var IRLetted_1 = require("./IRLetted.js");
var isIRParentTerm_1 = require("../utils/isIRParentTerm.js");
var _modifyChildFromTo_1 = require("../toUPLC/_internal/_modifyChildFromTo.js");
var defaultHoistedMeta = (0, obj_utils_1.freezeAll)({
    forceHoist: false
});
var IRHoisted = /** @class */ (function () {
    function IRHoisted(hoisted, metadata) {
        if (metadata === void 0) { metadata = {}; }
        var _this = this;
        var _a;
        // unwrap
        // !!! IMPORTANT !!!
        while (hoisted instanceof IRHoisted)
            hoisted = hoisted.hoisted;
        if (!(0, isClosedIRTerm_1.isClosedIRTerm)(hoisted)) {
            console.log((0, showIR_1.prettyIRJsonStr)(hoisted));
            throw new BasePlutsError_1.BasePlutsError("only closed terms can be hoisted");
        }
        // initialize without calling "set"
        var _hoisted = hoisted;
        _hoisted.parent = this;
        var _deps = undefined;
        function _getDeps() {
            if (_deps === undefined)
                _deps = getSortedHoistedSet(getHoistedTerms(_hoisted));
            return _deps;
        }
        var hash = undefined;
        Object.defineProperty(this, "hash", {
            get: function () {
                if (!(hash instanceof Uint8Array)) {
                    hash = (0, crypto_1.blake2b_128)((0, concatUint8Arr_1.concatUint8Arr)(IRHoisted.tag, hoisted.hash));
                }
                return hash.slice();
            },
            set: function () { },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "markHashAsInvalid", {
            value: function () {
                var _a;
                hash = undefined;
                // tree changed; possibly dependencies too
                _deps = undefined;
                (_a = _this.parent) === null || _a === void 0 ? void 0 : _a.markHashAsInvalid();
            },
            writable: false,
            enumerable: false,
            configurable: false
        });
        Object.defineProperty(this, "hoisted", {
            get: function () { return _hoisted; },
            set: function (newHoisted) {
                if (!(0, isClosedIRTerm_1.isClosedIRTerm)(hoisted))
                    throw new BasePlutsError_1.BasePlutsError("only closed terms can be hoisted");
                _this.markHashAsInvalid();
                _deps = undefined;
                _hoisted = newHoisted;
                _hoisted.parent = _this;
            }
        });
        Object.defineProperty(this, "dependencies", {
            get: function () {
                return _getDeps();
            },
            set: function () { },
            enumerable: true,
            configurable: false
        });
        var _parent = undefined;
        Object.defineProperty(this, "parent", {
            get: function () { return _parent; },
            set: function (newParent) {
                if (!( // assert
                // new parent value is different than current
                _parent !== newParent && (
                // and the new parent value is valid
                newParent === undefined ||
                    (0, isIRParentTerm_1.isIRParentTerm)(newParent))))
                    return;
                // keep reference
                var oldParent = _parent;
                // change parent
                _parent = newParent;
                // if has old parent
                if (oldParent !== undefined && (0, isIRParentTerm_1.isIRParentTerm)(oldParent)) {
                    // change reference to a clone for safety
                    (0, _modifyChildFromTo_1._modifyChildFromTo)(oldParent, _this, _this.clone());
                }
            },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, "meta", {
            value: __assign(__assign(__assign({}, defaultHoistedMeta), metadata), { name: (_a = _hoisted.meta.name) !== null && _a !== void 0 ? _a : metadata.name }),
            writable: false,
            enumerable: true,
            configurable: false
        });
        (0, obj_utils_1.defineProperty)(this, "clone", function () {
            return new IRHoisted(_this.hoisted.clone(), __assign({}, _this.meta));
        });
    }
    Object.defineProperty(IRHoisted, "tag", {
        get: function () { return new Uint8Array([6]); },
        enumerable: false,
        configurable: true
    });
    IRHoisted.prototype.toJson = function () {
        return {
            type: "IRHoisted",
            hash: (0, uint8array_utils_1.toHex)(this.hash),
            hoisted: this.hoisted.toJson()
        };
    };
    return IRHoisted;
}());
exports.IRHoisted = IRHoisted;
/**
 * basically an insertion sort;
 *
 * @param {HoistedSetEntry[]} hoistedTerms
 * @returns {HoistedSetEntry[]} a **new** array with ```IRHoisted```s with no dependencies first, followed by the dependents
 */
function getSortedHoistedSet(hoistedTerms) {
    var set = [];
    var hashesSet = [];
    /**
     * **O((n * m) * d)**
     *
     * where
     *
     *      n = length of set
     *      m = number of terms passed
     *      d = number of unique dependencies among the passed terms
     */
    function addToSet() {
        var _terms = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _terms[_i] = arguments[_i];
        }
        var _loop_1 = function (i) {
            var thisHoistedEntry = _terms[i];
            var thisHash = thisHoistedEntry.hoisted.hash;
            var idxInSet = hashesSet.findIndex(function (hash) { return (0, uint8array_utils_1.uint8ArrayEq)(hash, thisHash); });
            // if( !hashesSet.includes( compiled ) )
            // "includes" uses standard equality (===)
            if (idxInSet < 0) // not present
             {
                // add dependencies first
                addToSet.apply(void 0, __spreadArray([], __read(_terms[i].hoisted.dependencies), false));
                hashesSet.push(thisHash);
                set.push(thisHoistedEntry);
            }
            else {
                var entry = set[idxInSet];
                entry.nReferences += thisHoistedEntry.nReferences;
                entry.hoisted.meta.forceHoist =
                    entry.hoisted.meta.forceHoist ||
                        thisHoistedEntry.hoisted.meta.forceHoist;
            }
        };
        for (var i = 0; i < _terms.length; i++) {
            _loop_1(i);
        }
    }
    addToSet.apply(void 0, __spreadArray([], __read(hoistedTerms), false));
    return set;
}
exports.getSortedHoistedSet = getSortedHoistedSet;
function getHoistedTerms(irTerm) {
    var hoisteds = [];
    function searchIn(term) {
        if (term instanceof IRHoisted) {
            // only push direct hoisteds
            // dependencies are counted calling `getSortedHoistedSet`
            hoisteds.push({ hoisted: term, nReferences: 1 });
            return;
        }
        if (term instanceof IRApp_1.IRApp) {
            searchIn(term.fn);
            searchIn(term.arg);
            return;
        }
        if (term instanceof IRFunc_1.IRFunc) {
            searchIn(term.body);
            return;
        }
        if (term instanceof IRLetted_1.IRLetted) {
            // useless
            // term.dependencies.forEach( searchIn )
            // dependecies are still in the body anyway (hoisted are closed)
            // experiment to remove new letted;
            // no good so far
            // handleLetted( term );
            searchIn(term.value);
            return;
        }
        if (term instanceof IRForced_1.IRForced) {
            searchIn(term.forced);
            return;
        }
        if (term instanceof IRDelayed_1.IRDelayed) {
            searchIn(term.delayed);
            return;
        }
        // if( term instanceof IRNative ) return;
        // if( term instanceof IRVar ) return;
        // if( term instanceof IRConst ) return;
        // if( term instanceof IRError ) return;
    }
    searchIn(irTerm);
    return hoisteds;
}
exports.getHoistedTerms = getHoistedTerms;
function cloneHoistedSetEntry(_a) {
    var hoisted = _a.hoisted, nReferences = _a.nReferences;
    return {
        hoisted: hoisted.clone(),
        nReferences: nReferences
    };
}
exports.cloneHoistedSetEntry = cloneHoistedSetEntry;
