"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.palias = void 0;
var punsafeConvertType_1 = require("../../lib/punsafeConvertType/index.js");
var types_1 = require("../../type_system/types.js");
var PDataRepresentable_1 = require("../../PType/PDataRepresentable.js");
var isWellFormedType_1 = require("../../type_system/kinds/isWellFormedType.js");
var typeExtends_1 = require("../../type_system/typeExtends.js");
var assert_1 = require("../../../utils/assert.js");
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var pappArg_1 = require("../../lib/pappArg.js");
var fromData_1 = require("../../lib/std/data/conversion/fromData.js");
var toData_1 = require("../../lib/std/data/conversion/toData.js");
/**
 * intermediate class useful to reconize structs form primitives
**/
var _PAlias = /** @class */ (function (_super) {
    __extends(_PAlias, _super);
    function _PAlias() {
        var _this = _super.call(this) || this;
        _this._isPType = true;
        return _this;
    }
    return _PAlias;
}(PDataRepresentable_1.PDataRepresentable));
function palias(type, getMethods, fromDataConstraint) {
    if (fromDataConstraint === void 0) { fromDataConstraint = undefined; }
    (0, assert_1.assert)((0, isWellFormedType_1.isWellFormedType)(type), "cannot construct 'PAlias' type; the type cannot be converted to an UPLC constant");
    getMethods = typeof getMethods === "function" ? getMethods : function (_self_t) { return {}; };
    //@ts-ignore
    var PAliasExtension = /** @class */ (function (_super) {
        __extends(PAliasExtension, _super);
        // private constructors are not a thing at js runtime
        // in any case constructing an instance is useless
        // private allows the typescript LSP to rise errors (not runtime) whet trying to extend the class
        function PAliasExtension() {
            return _super.call(this) || this;
        }
        PAliasExtension._isPType = true;
        return PAliasExtension;
    }(_PAlias));
    ;
    var thisTypeNoMethods = (0, types_1.alias)(type);
    var methods = getMethods(thisTypeNoMethods);
    var thisType = (0, types_1.alias)(type, methods);
    (0, obj_utils_1.defineReadOnlyProperty)(PAliasExtension, "type", thisType);
    (0, obj_utils_1.defineReadOnlyProperty)(PAliasExtension, "termType", thisType);
    (0, obj_utils_1.defineReadOnlyProperty)(PAliasExtension, "fromData", function (dataTerm) {
        (0, assert_1.assert)((0, typeExtends_1.typeExtends)(dataTerm.type, types_1.data), "trying to construct an alias using static method 'fromData'; but the `Data` argument is not a `Data.Constr`");
        var res = (0, fromData_1.fromData)(type)(dataTerm);
        if (typeof fromDataConstraint === "function") {
            var constrained = fromDataConstraint(res);
            (0, assert_1.assert)((0, typeExtends_1.typeExtends)(constrained.type, res.type), "'fromDataConstraint' changed the type of the term");
            return (0, punsafeConvertType_1.punsafeConvertType)(constrained, thisType);
        }
        return (0, punsafeConvertType_1.punsafeConvertType)(res, thisType);
    });
    (0, obj_utils_1.defineReadOnlyProperty)(PAliasExtension, "toData", function (aliasTerm) {
        var aliasT = aliasTerm.type;
        (0, assert_1.assert)(aliasT[0] === "alias" /* PrimType.Alias */ && (0, typeExtends_1.typeExtends)(aliasT, thisType), "trying to convert an alias type using the wrong class 'toData'");
        return (0, toData_1.toData)(type)((0, punsafeConvertType_1.punsafeConvertType)(aliasTerm, type));
    });
    (0, obj_utils_1.defineReadOnlyProperty)(PAliasExtension, "from", function (toAlias) {
        return (0, punsafeConvertType_1.punsafeConvertType)((0, pappArg_1.pappArgToTerm)(toAlias, type), thisType);
    });
    return PAliasExtension;
}
exports.palias = palias;
