"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPPairMethods = void 0;
var obj_utils_1 = require("@harmoniclabs/obj-utils");
var type_system_1 = require("../../../type_system/index.js");
var types_1 = require("../../../type_system/types.js");
var builtins_1 = require("../../builtins/index.js");
var plet_1 = require("../../plet/index.js");
var pair_1 = require("../pair/index.js");
var getterOnly = {
    set: function () { },
    configurable: false,
    enumerable: true
};
function addPPairMethods(_pair) {
    var pairT = (0, type_system_1.unwrapAlias)(_pair.type);
    if (!(0, type_system_1.typeExtends)(pairT, (0, types_1.pair)((0, types_1.tyVar)(), (0, types_1.tyVar)()))) {
        throw new Error("can't add pair methods to a term that is not a pair");
    }
    ;
    // MUST NOT unwrap `asData`
    // (needed by pfst and psnd to understand if the result should be transformed)
    var fstT = pairT[1];
    while (fstT[0] === "alias" /* PrimType.Alias */)
        fstT = fstT[1];
    // MUST NOT unwrap `asData`
    // (needed by pfst and psnd to understand if the result should be transformed) 
    var sndT = pairT[2];
    while (sndT[0] === "alias" /* PrimType.Alias */)
        sndT = sndT[1];
    if ((0, type_system_1.isWellFormedType)(fstT))
        (0, obj_utils_1.definePropertyIfNotPresent)(_pair, "fst", __assign({ get: function () { return (0, plet_1.plet)((0, builtins_1.pfstPair)(fstT, sndT).$(_pair)); } }, getterOnly));
    if ((0, type_system_1.isWellFormedType)(sndT))
        (0, obj_utils_1.definePropertyIfNotPresent)(_pair, "snd", __assign({ get: function () { return (0, plet_1.plet)((0, builtins_1.psndPair)(fstT, sndT).$(_pair)); } }, getterOnly));
    (0, obj_utils_1.definePropertyIfNotPresent)(_pair, "peq", {
        get: function () { return (0, pair_1.peqPair)(pairT).$(_pair); },
        set: function () { },
        enumerable: true,
        configurable: false
    });
    (0, obj_utils_1.defineReadOnlyProperty)(_pair, "eq", function (other) { return (0, pair_1.peqPair)(pairT).$(_pair).$(other); });
    return _pair;
}
exports.addPPairMethods = addPPairMethods;
